-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support library for Template Haskell
--   
--   This package provides modules containing facilities for manipulating
--   Haskell source code using Template Haskell.
--   
--   See <a>http://www.haskell.org/haskellwiki/Template_Haskell</a> for
--   more information.
@package template-haskell
@version 2.10.0.0


-- | Abstract syntax definitions for Template Haskell.
module Language.Haskell.TH.Syntax
class Monad m => Quasi m
qNewName :: Quasi m => String -> m Name
qReport :: Quasi m => Bool -> String -> m ()
qRecover :: Quasi m => m a -> m a -> m a
qLookupName :: Quasi m => Bool -> String -> m (Maybe Name)
qReify :: Quasi m => Name -> m Info
qReifyInstances :: Quasi m => Name -> [Type] -> m [Dec]
qReifyRoles :: Quasi m => Name -> m [Role]
qReifyAnnotations :: (Quasi m, Data a) => AnnLookup -> m [a]
qReifyModule :: Quasi m => Module -> m ModuleInfo
qLocation :: Quasi m => m Loc

-- | Input/output (dangerous)
qRunIO :: Quasi m => IO a -> m a
qAddDependentFile :: Quasi m => FilePath -> m ()
qAddTopDecls :: Quasi m => [Dec] -> m ()
qAddModFinalizer :: Quasi m => Q () -> m ()
qGetQ :: (Quasi m, Typeable a) => m (Maybe a)
qPutQ :: (Quasi m, Typeable a) => a -> m ()
badIO :: String -> IO a
counter :: IORef Int
newtype Q a
Q :: (forall m. Quasi m => m a) -> Q a
[unQ] :: Q a -> forall m. Quasi m => m a
runQ :: Quasi m => Q a -> m a
newtype TExp a
TExp :: Exp -> TExp a
[unType] :: TExp a -> Exp
unTypeQ :: Q (TExp a) -> Q Exp
unsafeTExpCoerce :: Q Exp -> Q (TExp a)

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = <a>mkName</a> "x"
--     return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: String -> Q Name

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a
lookupName :: Bool -> String -> Q (Maybe Name)

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <a>reify</a> looks up information about the <a>Name</a>.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyInstances nm tys</tt> returns a list of visible instances of
--   <tt>nm tys</tt>. That is, if <tt>nm</tt> is the name of a type class,
--   then all instances of this class at the types <tt>tys</tt> are
--   returned. Alternatively, if <tt>nm</tt> is the name of a data family
--   or type family, all instances of this family at the types <tt>tys</tt>
--   are returned.
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters of the tycon <tt>nm</tt>. Fails if <tt>nm</tt> cannot be
--   found or is not a tycon. The returned list should never contain
--   <a>InferR</a>.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <tt>thisModule</tt>.
reifyModule :: Module -> Q ModuleInfo

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
isInstance :: Name -> [Type] -> Q Bool

-- | The location at which this computation is spliced.
location :: Q Loc

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | Record external files that runIO is using (dependent upon). The
--   compiler can then recognize that it should re-compile the Haskell file
--   when an external file changes.
--   
--   Expects an absolute file path.
--   
--   Notes:
--   
--   <ul>
--   <li>ghc -M does not know about these dependencies - it does not
--   execute TH.</li>
--   <li>The dependency is based on file content, not a modification
--   time</li>
--   </ul>
addDependentFile :: FilePath -> Q ()

-- | Add additional top-level declarations. The added declarations will be
--   type checked along with the current declaration group.
addTopDecls :: [Dec] -> Q ()

-- | Add a finalizer that will run in the Q monad after the current module
--   has been type checked. This only makes sense when run within a
--   top-level splice.
addModFinalizer :: Q () -> Q ()

-- | Get state from the Q monad.
getQ :: Typeable a => Q (Maybe a)

-- | Replace the state in the Q monad.
putQ :: Typeable a => a -> Q ()
returnQ :: a -> Q a
bindQ :: Q a -> (a -> Q b) -> Q b
sequenceQ :: [Q a] -> Q [a]
class Lift t
lift :: Lift t => t -> Q Exp
liftString :: String -> Q Exp
trueName :: Name
falseName :: Name
nothingName :: Name
justName :: Name
leftName :: Name
rightName :: Name
newtype ModName
ModName :: String -> ModName
newtype PkgName
PkgName :: String -> PkgName

-- | Obtained from <a>reifyModule</a> and <tt>thisModule</tt>.
data Module
Module :: PkgName -> ModName -> Module
newtype OccName
OccName :: String -> OccName
mkModName :: String -> ModName
modString :: ModName -> String
mkPkgName :: String -> PkgName
pkgString :: PkgName -> String
mkOccName :: String -> OccName
occString :: OccName -> String

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
Name :: OccName -> NameFlavour -> Name
data NameFlavour

-- | An unqualified name; dynamically bound
NameS :: NameFlavour

-- | A qualified name; dynamically bound
NameQ :: ModName -> NameFlavour

-- | A unique local name
NameU :: !Int -> NameFlavour

-- | Local name bound outside of the TH AST
NameL :: !Int -> NameFlavour

-- | Global name bound outside of the TH AST: An original name (occurrences
--   only, not binders) Need the namespace too to be sure which thing we
--   are naming
NameG :: NameSpace -> PkgName -> ModName -> NameFlavour
data NameSpace

-- | Variables
VarName :: NameSpace

-- | Data constructors
DataName :: NameSpace

-- | Type constructors and classes; Haskell has them in the same name space
--   for now.
TcClsName :: NameSpace
type Uniq = Int

-- | The name without its module prefix
nameBase :: Name -> String

-- | Module prefix of a name, if it exists
nameModule :: Name -> Maybe String

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <tt>dyn</tt> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | Only used internally
mkNameU :: String -> Uniq -> Name

-- | Only used internally
mkNameL :: String -> Uniq -> Name

-- | Used for 'x etc, but not available to the programmer
mkNameG :: NameSpace -> String -> String -> String -> Name
mkNameG_v :: String -> String -> String -> Name
mkNameG_tc :: String -> String -> String -> Name
mkNameG_d :: String -> String -> String -> Name
data NameIs
Alone :: NameIs
Applied :: NameIs
Infix :: NameIs
showName :: Name -> String
showName' :: NameIs -> Name -> String

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Tuple type constructor
tupleTypeName :: Int -> Name
mk_tup_name :: Int -> NameSpace -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name
mk_unboxed_tup_name :: Int -> NameSpace -> Name
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos
type CharPos = (Int, Int)  Line and character position

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable -- including the RHS of the declaration --
--   or else <tt>Nothing</tt>, in the case where the RHS is unavailable to
--   the compiler. At present, this value is _always_ <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
VarI :: Name -> Type -> (Maybe Dec) -> Fixity -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
ModuleInfo :: [Module] -> ModuleInfo

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | <a>InstanceDec</a> desribes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type Addr#
StringPrimL :: [Word8] -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or <tt>c</tt> }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { () }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
ConP :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
type FieldPat = (Name, Pat)
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or <tt>c</tt>}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: (Maybe Exp) -> Exp -> (Maybe Exp) -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   {  p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
TupE :: [Exp] -> Exp

-- | <pre>
--   { () }
--   </pre>
UnboxedTupE :: [Exp] -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let x=e1;   y=e2 in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
DoE :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
StaticE :: Exp -> Exp
type FieldExp = (Name, Exp)
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard
data Stmt
BindS :: Pat -> Exp -> Stmt
LetS :: [Dec] -> Stmt
NoBindS :: Exp -> Stmt
ParS :: [[Stmt]] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)}
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr] -> Con -> [Name] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance Show w =&gt; Show [w]
--          where ds }
--   </pre>
InstanceD :: Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
InfixD :: Fixity -> Name -> Dec

-- | <pre>
--   { {--} }
--   </pre>
PragmaD :: Pragma -> Dec

-- | <pre>
--   { type family T a b c :: * }
--   </pre>
FamilyD :: FamFlavour -> Name -> [TyVarBndr] -> (Maybe Kind) -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x] = A x
--                                   | B (T x)
--          deriving (Z,W)}
--   </pre>
DataInstD :: Cxt -> Name -> [Type] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x] = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeInstD :: Cxt -> Name -> [Type] -> Con -> [Name] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
TySynInstD :: Name -> TySynEqn -> Dec

-- | <pre>
--   { type family F a b :: * where ... }
--   </pre>
ClosedTypeFamilyD :: Name -> [TyVarBndr] -> (Maybe Kind) -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
RoleAnnotD :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving instance Ord a =&gt; Ord (Foo a) }
--   </pre>
StandaloneDerivD :: Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
DefaultSigD :: Name -> Type -> Dec

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type patterns and the right-hand-side
--   result.
data TySynEqn
TySynEqn :: [Type] -> Type -> TySynEqn
data FunDep
FunDep :: [Name] -> [Name] -> FunDep
data FamFlavour
TypeFam :: FamFlavour
DataFam :: FamFlavour
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
SpecialiseP :: Name -> Type -> (Maybe Inline) -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
AnnP :: AnnTarget -> Exp -> Pragma
LineP :: Int -> String -> Pragma
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data AnnTarget
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget
type Cxt = [Pred]  @(Eq a, Ord b)@

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type
data Strict
IsStrict :: Strict
NotStrict :: Strict
Unpacked :: Strict
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [StrictType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarStrictType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: StrictType -> Name -> StrictType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr] -> Cxt -> Con -> Con
type StrictType = (Strict, Type)
type VarStrictType = (Name, Strict, Type)
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; -&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
TupleT :: Int -> Type

-- | <pre>
--   (), (), etc.
--   </pre>
UnboxedTupleT :: Int -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   ~
--   </pre>
EqualityT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <pre>
--   '(), '(,), '(,,), etc.
--   </pre>
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   (':)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <pre>
--   0,1,2, etc.
--   </pre>
LitT :: TyLit -> Type
data TyVarBndr

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> Kind -> TyVarBndr
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   <a>Hello</a>
--   </pre>
StrTyLit :: String -> TyLit

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
NominalR :: Role

-- | <pre>
--   representational
--   </pre>
RepresentationalR :: Role

-- | <pre>
--   phantom
--   </pre>
PhantomR :: Role

-- | <pre>
--   _
--   </pre>
InferR :: Role

-- | Annotation target for reifyAnnotations
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type
cmpEq :: Ordering -> Bool
thenCmp :: Ordering -> Ordering -> Ordering
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_7Info
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_6Info
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_5Info
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_4Info
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Info
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Info
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Info
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Info
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Info
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Range
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Range
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Range
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Range
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Range
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_5Pragma
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_4Pragma
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Pragma
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Pragma
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Pragma
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Pragma
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Pragma
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Stmt
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Stmt
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Stmt
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Stmt
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Stmt
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Guard
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Guard
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Guard
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Body
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Body
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Body
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Clause
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Clause
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_18Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_17Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_16Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_15Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_14Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_13Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_12Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_11Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_10Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_9Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_8Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_7Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_6Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_5Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_4Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Dec
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Dec
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_15Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_14Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_13Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_12Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_11Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_10Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_9Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_8Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_7Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_6Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_5Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_4Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Pat
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Pat
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Match
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Match
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_22Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_21Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_20Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_19Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_18Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_17Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_16Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_15Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_14Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_13Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_12Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_11Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_10Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_9Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_8Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_7Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_6Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_5Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_4Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Exp
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Exp
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0TySynEqn
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1TySynEqn
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Foreign
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Foreign
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Foreign
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1RuleBndr
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0RuleBndr
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1RuleBndr
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Con
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Con
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Con
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Con
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Con
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1TyVarBndr
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0TyVarBndr
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1TyVarBndr
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_16Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_15Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_14Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_13Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_12Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_11Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_10Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_9Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_8Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_7Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_6Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_5Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_4Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Type
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Type
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2AnnTarget
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1AnnTarget
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0AnnTarget
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1AnnTarget
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1AnnLookup
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0AnnLookup
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1AnnLookup
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0FunDep
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1FunDep
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Name
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Name
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Role
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Role
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Role
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Role
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Role
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1TyLit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0TyLit
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1TyLit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Strict
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Strict
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Strict
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Strict
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Phases
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Phases
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Phases
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Phases
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1RuleMatch
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0RuleMatch
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1RuleMatch
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Inline
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Inline
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Inline
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Inline
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Safety
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Safety
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Safety
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Safety
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_4Callconv
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Callconv
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Callconv
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Callconv
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Callconv
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Callconv
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1FamFlavour
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0FamFlavour
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1FamFlavour
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_8Lit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_7Lit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_6Lit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_5Lit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_4Lit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3Lit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2Lit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1Lit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Lit
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Lit
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Fixity
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Fixity
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2FixityDirection
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1FixityDirection
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0FixityDirection
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1FixityDirection
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0ModuleInfo
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1ModuleInfo
instance GHC.Generics.Selector Language.Haskell.TH.Syntax.S1_0_4Loc
instance GHC.Generics.Selector Language.Haskell.TH.Syntax.S1_0_3Loc
instance GHC.Generics.Selector Language.Haskell.TH.Syntax.S1_0_2Loc
instance GHC.Generics.Selector Language.Haskell.TH.Syntax.S1_0_1Loc
instance GHC.Generics.Selector Language.Haskell.TH.Syntax.S1_0_0Loc
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Loc
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Loc
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_4NameFlavour
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_3NameFlavour
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2NameFlavour
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1NameFlavour
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0NameFlavour
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1NameFlavour
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_2NameSpace
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_1NameSpace
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0NameSpace
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1NameSpace
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0OccName
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1OccName
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0Module
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1Module
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0PkgName
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1PkgName
instance GHC.Generics.Constructor Language.Haskell.TH.Syntax.C1_0ModName
instance GHC.Generics.Datatype Language.Haskell.TH.Syntax.D1ModName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Info
instance Data.Data.Data Language.Haskell.TH.Syntax.Info
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Info
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Info
instance GHC.Show.Show Language.Haskell.TH.Syntax.Info
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Range
instance Data.Data.Data Language.Haskell.TH.Syntax.Range
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Range
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Range
instance GHC.Show.Show Language.Haskell.TH.Syntax.Range
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Pragma
instance Data.Data.Data Language.Haskell.TH.Syntax.Pragma
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Pragma
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Pragma
instance GHC.Show.Show Language.Haskell.TH.Syntax.Pragma
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Stmt
instance Data.Data.Data Language.Haskell.TH.Syntax.Stmt
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Stmt
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Stmt
instance GHC.Show.Show Language.Haskell.TH.Syntax.Stmt
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Guard
instance Data.Data.Data Language.Haskell.TH.Syntax.Guard
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Guard
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Guard
instance GHC.Show.Show Language.Haskell.TH.Syntax.Guard
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Body
instance Data.Data.Data Language.Haskell.TH.Syntax.Body
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Body
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Body
instance GHC.Show.Show Language.Haskell.TH.Syntax.Body
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Clause
instance Data.Data.Data Language.Haskell.TH.Syntax.Clause
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Clause
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Clause
instance GHC.Show.Show Language.Haskell.TH.Syntax.Clause
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Dec
instance Data.Data.Data Language.Haskell.TH.Syntax.Dec
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Dec
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Dec
instance GHC.Show.Show Language.Haskell.TH.Syntax.Dec
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Pat
instance Data.Data.Data Language.Haskell.TH.Syntax.Pat
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Pat
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Pat
instance GHC.Show.Show Language.Haskell.TH.Syntax.Pat
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Match
instance Data.Data.Data Language.Haskell.TH.Syntax.Match
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Match
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Match
instance GHC.Show.Show Language.Haskell.TH.Syntax.Match
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Exp
instance Data.Data.Data Language.Haskell.TH.Syntax.Exp
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Exp
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Exp
instance GHC.Show.Show Language.Haskell.TH.Syntax.Exp
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TySynEqn
instance Data.Data.Data Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Show.Show Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Foreign
instance Data.Data.Data Language.Haskell.TH.Syntax.Foreign
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Foreign
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Foreign
instance GHC.Show.Show Language.Haskell.TH.Syntax.Foreign
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.RuleBndr
instance Data.Data.Data Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Show.Show Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Con
instance Data.Data.Data Language.Haskell.TH.Syntax.Con
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Con
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Con
instance GHC.Show.Show Language.Haskell.TH.Syntax.Con
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TyVarBndr
instance Data.Data.Data Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Show.Show Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Type
instance Data.Data.Data Language.Haskell.TH.Syntax.Type
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Type
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Type
instance GHC.Show.Show Language.Haskell.TH.Syntax.Type
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.AnnTarget
instance Data.Data.Data Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Show.Show Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.AnnLookup
instance Data.Data.Data Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Show.Show Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FunDep
instance Data.Data.Data Language.Haskell.TH.Syntax.FunDep
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FunDep
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FunDep
instance GHC.Show.Show Language.Haskell.TH.Syntax.FunDep
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Name
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Name
instance Data.Data.Data Language.Haskell.TH.Syntax.Name
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Role
instance Data.Data.Data Language.Haskell.TH.Syntax.Role
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Role
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Role
instance GHC.Show.Show Language.Haskell.TH.Syntax.Role
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TyLit
instance Data.Data.Data Language.Haskell.TH.Syntax.TyLit
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TyLit
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TyLit
instance GHC.Show.Show Language.Haskell.TH.Syntax.TyLit
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Strict
instance Data.Data.Data Language.Haskell.TH.Syntax.Strict
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Strict
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Strict
instance GHC.Show.Show Language.Haskell.TH.Syntax.Strict
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Phases
instance Data.Data.Data Language.Haskell.TH.Syntax.Phases
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Phases
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Phases
instance GHC.Show.Show Language.Haskell.TH.Syntax.Phases
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.RuleMatch
instance Data.Data.Data Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Show.Show Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Inline
instance Data.Data.Data Language.Haskell.TH.Syntax.Inline
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Inline
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Inline
instance GHC.Show.Show Language.Haskell.TH.Syntax.Inline
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Safety
instance Data.Data.Data Language.Haskell.TH.Syntax.Safety
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Safety
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Safety
instance GHC.Show.Show Language.Haskell.TH.Syntax.Safety
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Callconv
instance Data.Data.Data Language.Haskell.TH.Syntax.Callconv
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Callconv
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Callconv
instance GHC.Show.Show Language.Haskell.TH.Syntax.Callconv
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FamFlavour
instance Data.Data.Data Language.Haskell.TH.Syntax.FamFlavour
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FamFlavour
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FamFlavour
instance GHC.Show.Show Language.Haskell.TH.Syntax.FamFlavour
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Lit
instance Data.Data.Data Language.Haskell.TH.Syntax.Lit
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Lit
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Lit
instance GHC.Show.Show Language.Haskell.TH.Syntax.Lit
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Fixity
instance Data.Data.Data Language.Haskell.TH.Syntax.Fixity
instance GHC.Show.Show Language.Haskell.TH.Syntax.Fixity
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Fixity
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Fixity
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FixityDirection
instance Data.Data.Data Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Show.Show Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.ModuleInfo
instance Data.Data.Data Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Show.Show Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Loc
instance Data.Data.Data Language.Haskell.TH.Syntax.Loc
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Loc
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Loc
instance GHC.Show.Show Language.Haskell.TH.Syntax.Loc
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.NameFlavour
instance Data.Data.Data Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.NameSpace
instance Data.Data.Data Language.Haskell.TH.Syntax.NameSpace
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.NameSpace
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.NameSpace
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.OccName
instance Data.Data.Data Language.Haskell.TH.Syntax.OccName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.OccName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.OccName
instance GHC.Show.Show Language.Haskell.TH.Syntax.OccName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Module
instance Data.Data.Data Language.Haskell.TH.Syntax.Module
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Module
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Module
instance GHC.Show.Show Language.Haskell.TH.Syntax.Module
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PkgName
instance Data.Data.Data Language.Haskell.TH.Syntax.PkgName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PkgName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PkgName
instance GHC.Show.Show Language.Haskell.TH.Syntax.PkgName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.ModName
instance Data.Data.Data Language.Haskell.TH.Syntax.ModName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.ModName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.ModName
instance GHC.Show.Show Language.Haskell.TH.Syntax.ModName
instance Language.Haskell.TH.Syntax.Quasi GHC.Types.IO
instance GHC.Base.Monad Language.Haskell.TH.Syntax.Q
instance GHC.Base.Functor Language.Haskell.TH.Syntax.Q
instance GHC.Base.Applicative Language.Haskell.TH.Syntax.Q
instance Language.Haskell.TH.Syntax.Quasi Language.Haskell.TH.Syntax.Q
instance Language.Haskell.TH.Syntax.Lift GHC.Integer.Type.Integer
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Int
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int8
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int16
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int32
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int64
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Word
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word8
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word16
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word32
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word64
instance Language.Haskell.TH.Syntax.Lift GHC.Natural.Natural
instance GHC.Real.Integral a => Language.Haskell.TH.Syntax.Lift (GHC.Real.Ratio a)
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Float
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Double
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Char
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Bool
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (GHC.Base.Maybe a)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (Data.Either.Either a b)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift [a]
instance Language.Haskell.TH.Syntax.Lift ()
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (a, b)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c) => Language.Haskell.TH.Syntax.Lift (a, b, c)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d) => Language.Haskell.TH.Syntax.Lift (a, b, c, d)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e, f)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f, Language.Haskell.TH.Syntax.Lift g) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e, f, g)
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Name
instance GHC.Show.Show Language.Haskell.TH.Syntax.Name


-- | TH.Lib contains lots of useful helper functions for generating and
--   manipulating Template Haskell terms
module Language.Haskell.TH.Lib
type InfoQ = Q Info
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type ExpQ = Q Exp
type TExpQ a = Q (TExp a)
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
type Role = Role
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
rationalL :: Rational -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
unboxedTupP :: [PatQ] -> PatQ
conP :: Name -> [PatQ] -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> ExpQ

-- | <i>Deprecated: Use varE instead</i>
global :: Name -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
parensE :: ExpQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
lamCaseE :: [MatchQ] -> ExpQ
tupE :: [ExpQ] -> ExpQ
unboxedTupE :: [ExpQ] -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
multiIfE :: [Q (Guard, Exp)] -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
doE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
arithSeqE :: RangeQ -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: ExpQ -> ExpQ
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndr] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndr] -> [ConQ] -> [Name] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndr] -> ConQ -> [Name] -> DecQ
classD :: CxtQ -> Name -> [TyVarBndr] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
infixLD :: Int -> Name -> DecQ
infixRD :: Int -> Name -> DecQ
infixND :: Int -> Name -> DecQ
pragInlD :: Name -> Inline -> RuleMatch -> Phases -> DecQ
pragSpecD :: Name -> TypeQ -> Phases -> DecQ
pragSpecInlD :: Name -> TypeQ -> Inline -> Phases -> DecQ
pragSpecInstD :: TypeQ -> DecQ
pragRuleD :: String -> [RuleBndrQ] -> ExpQ -> ExpQ -> Phases -> DecQ
pragAnnD :: AnnTarget -> ExpQ -> DecQ
pragLineD :: Int -> String -> DecQ
familyNoKindD :: FamFlavour -> Name -> [TyVarBndr] -> DecQ
familyKindD :: FamFlavour -> Name -> [TyVarBndr] -> Kind -> DecQ
dataInstD :: CxtQ -> Name -> [TypeQ] -> [ConQ] -> [Name] -> DecQ
newtypeInstD :: CxtQ -> Name -> [TypeQ] -> ConQ -> [Name] -> DecQ
tySynInstD :: Name -> TySynEqnQ -> DecQ
closedTypeFamilyNoKindD :: Name -> [TyVarBndr] -> [TySynEqnQ] -> DecQ
closedTypeFamilyKindD :: Name -> [TyVarBndr] -> Kind -> [TySynEqnQ] -> DecQ
roleAnnotD :: Name -> [Role] -> DecQ
standaloneDerivD :: CxtQ -> TypeQ -> DecQ
defaultSigD :: Name -> TypeQ -> DecQ
tySynEqn :: [TypeQ] -> TypeQ -> TySynEqnQ
cxt :: [PredQ] -> CxtQ
normalC :: Name -> [StrictTypeQ] -> ConQ
recC :: Name -> [VarStrictTypeQ] -> ConQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
forallC :: [TyVarBndr] -> CxtQ -> ConQ -> ConQ
forallT :: [TyVarBndr] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
arrowT :: TypeQ
listT :: TypeQ
litT :: TyLitQ -> TypeQ
tupleT :: Int -> TypeQ
unboxedTupleT :: Int -> TypeQ
sigT :: TypeQ -> Kind -> TypeQ
equalityT :: TypeQ

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Name -> [Q Type] -> Q Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: TypeQ -> TypeQ -> PredQ
promotedT :: Name -> TypeQ
promotedTupleT :: Int -> TypeQ
promotedNilT :: TypeQ
promotedConsT :: TypeQ
isStrict :: Q Strict
notStrict :: Q Strict
unpacked :: Q Strict
strictType :: Q Strict -> TypeQ -> StrictTypeQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
numTyLit :: Integer -> TyLitQ
strTyLit :: String -> TyLitQ
plainTV :: Name -> TyVarBndr
kindedTV :: Name -> Kind -> TyVarBndr
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Kind
constraintK :: Kind
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
interruptible :: Safety
funDep :: [Name] -> [Name] -> FunDep
typeFam :: FamFlavour
dataFam :: FamFlavour
ruleVar :: Name -> RuleBndrQ
typedRuleVar :: Name -> TypeQ -> RuleBndrQ
valueAnnotation :: Name -> AnnTarget
typeAnnotation :: Name -> AnnTarget
moduleAnnotation :: AnnTarget
appsE :: [ExpQ] -> ExpQ

-- | Return the Module at the place of splicing. Can be used as an input
--   for <a>reifyModule</a>.
thisModule :: Q Module

module Language.Haskell.TH.Quote
data QuasiQuoter
QuasiQuoter :: (String -> Q Exp) -> (String -> Q Pat) -> (String -> Q Type) -> (String -> Q [Dec]) -> QuasiQuoter
[quoteExp] :: QuasiQuoter -> String -> Q Exp
[quotePat] :: QuasiQuoter -> String -> Q Pat
[quoteType] :: QuasiQuoter -> String -> Q Type
[quoteDec] :: QuasiQuoter -> String -> Q [Dec]
dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (forall b. Data b => b -> Maybe (Q q)) -> a -> Q q

-- | <a>dataToExpQ</a> converts a value to a 'Q Exp' representation of the
--   same value. It takes a function to handle type-specific cases.
dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp

-- | <a>dataToPatQ</a> converts a value to a 'Q Pat' representation of the
--   same value. It takes a function to handle type-specific cases.
dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat

-- | <a>quoteFile</a> takes a <a>QuasiQuoter</a> and lifts it into one that
--   read the data out of a file. For example, suppose <tt>asmq</tt> is an
--   assembly-language quoter, so that you can write [asmq| ld r1, r2 |] as
--   an expression. Then if you define <tt>asmq_f = quoteFile asmq</tt>,
--   then the quote [asmq_f|foo.s|] will take input from file
--   <tt>"foo.s"</tt> instead of the inline text
quoteFile :: QuasiQuoter -> QuasiQuoter


-- | Monadic front-end to Text.PrettyPrint
module Language.Haskell.TH.PprLib
type Doc = PprM Doc
data PprM a

-- | An empty document
empty :: Doc

-- | A ';' character
semi :: Doc

-- | A ',' character
comma :: Doc

-- | A <tt>:</tt> character
colon :: Doc

-- | A space character
space :: Doc

-- | A '=' character
equals :: Doc

-- | A "-&gt;" string
arrow :: Doc

-- | A '(' character
lparen :: Doc

-- | A ')' character
rparen :: Doc

-- | A '[' character
lbrack :: Doc

-- | A ']' character
rbrack :: Doc

-- | A '{' character
lbrace :: Doc

-- | A '}' character
rbrace :: Doc
text :: String -> Doc
char :: Char -> Doc
ptext :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc

-- | Wrap document in <tt>(...)</tt>
parens :: Doc -> Doc

-- | Wrap document in <tt>[...]</tt>
brackets :: Doc -> Doc

-- | Wrap document in <tt>{...}</tt>
braces :: Doc -> Doc

-- | Wrap document in <tt>'...'</tt>
quotes :: Doc -> Doc

-- | Wrap document in <tt>"..."</tt>
doubleQuotes :: Doc -> Doc

-- | Beside
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space
(<+>) :: Doc -> Doc -> Doc

-- | List version of <a>&lt;&gt;</a>
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>
hsep :: [Doc] -> Doc

-- | Above; if there is no overlap it "dovetails" the two
($$) :: Doc -> Doc -> Doc

-- | Above, without dovetailing.
($+$) :: Doc -> Doc -> Doc

-- | List version of <a>$$</a>
vcat :: [Doc] -> Doc

-- | Either hsep or vcat
sep :: [Doc] -> Doc

-- | Either hcat or vcat
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of sep
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of cat
fcat :: [Doc] -> Doc

-- | Nested
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> PprM Bool
to_HPJ_Doc :: Doc -> Doc
pprName :: Name -> Doc
pprName' :: NameIs -> Name -> Doc
instance GHC.Show.Show Language.Haskell.TH.PprLib.Doc
instance GHC.Base.Functor Language.Haskell.TH.PprLib.PprM
instance GHC.Base.Applicative Language.Haskell.TH.PprLib.PprM
instance GHC.Base.Monad Language.Haskell.TH.PprLib.PprM


-- | contains a prettyprinter for the Template Haskell datatypes
module Language.Haskell.TH.Ppr
nestDepth :: Int
type Precedence = Int
appPrec :: Precedence
unopPrec :: Precedence
opPrec :: Precedence
noPrec :: Precedence
parensIf :: Bool -> Doc -> Doc
pprint :: Ppr a => a -> String
class Ppr a where ppr_list = vcat . map ppr
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
ppr_sig :: Name -> Type -> Doc
pprFixity :: Name -> Fixity -> Doc
pprPrefixOcc :: Name -> Doc
isSymOcc :: Name -> Bool
isSymbolASCII :: Char -> Bool
pprInfixExp :: Exp -> Doc
pprExp :: Precedence -> Exp -> Doc
pprFields :: [(Name, Exp)] -> Doc
pprMaybeExp :: Precedence -> Maybe Exp -> Doc
pprGuarded :: Doc -> (Guard, Exp) -> Doc
pprBody :: Bool -> Body -> Doc
pprLit :: Precedence -> Lit -> Doc
bytesToString :: [Word8] -> String
pprString :: String -> Doc
pprPat :: Precedence -> Pat -> Doc
ppr_dec :: Bool -> Dec -> Doc
ppr_data :: Doc -> Cxt -> Name -> Doc -> [Con] -> [Name] -> Doc
ppr_newtype :: Doc -> Cxt -> Name -> Doc -> Con -> [Name] -> Doc
ppr_tySyn :: Doc -> Name -> Doc -> Type -> Doc
pprVarStrictType :: (Name, Strict, Type) -> Doc
pprStrictType :: (Strict, Type) -> Doc
pprParendType :: Type -> Doc
pprTyApp :: (Type, [Type]) -> Doc
pprFunArgType :: Type -> Doc
split :: Type -> (Type, [Type])
pprTyLit :: TyLit -> Doc
pprCxt :: Cxt -> Doc
where_clause :: [Dec] -> Doc
showtextl :: Show a => a -> Doc
hashParens :: Doc -> Doc
quoteParens :: Doc -> Doc
instance Language.Haskell.TH.Ppr.Ppr a => Language.Haskell.TH.Ppr.Ppr [a]
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Name
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Info
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Module
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.ModuleInfo
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Exp
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Stmt
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Match
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Lit
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Pat
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Dec
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.FunDep
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.FamFlavour
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Foreign
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Pragma
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Inline
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.RuleMatch
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Phases
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.RuleBndr
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Clause
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Con
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Type
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.TyLit
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.TyVarBndr
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Role
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Range
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Loc


-- | The public face of Template Haskell
--   
--   For other documentation, refer to:
--   <a>http://www.haskell.org/haskellwiki/Template_Haskell</a>
module Language.Haskell.TH
data Q a
runQ :: Quasi m => Q a -> m a

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a

-- | The location at which this computation is spliced.
location :: Q Loc
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | <a>reify</a> looks up information about the <a>Name</a>.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <tt>thisModule</tt>.
reifyModule :: Module -> Q ModuleInfo

-- | Return the Module at the place of splicing. Can be used as an input
--   for <a>reifyModule</a>.
thisModule :: Q Module

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable -- including the RHS of the declaration --
--   or else <tt>Nothing</tt>, in the case where the RHS is unavailable to
--   the compiler. At present, this value is _always_ <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
VarI :: Name -> Type -> (Maybe Dec) -> Fixity -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
ModuleInfo :: [Module] -> ModuleInfo

-- | <a>InstanceDec</a> desribes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <tt>reifyInstances nm tys</tt> returns a list of visible instances of
--   <tt>nm tys</tt>. That is, if <tt>nm</tt> is the name of a type class,
--   then all instances of this class at the types <tt>tys</tt> are
--   returned. Alternatively, if <tt>nm</tt> is the name of a data family
--   or type family, all instances of this family at the types <tt>tys</tt>
--   are returned.
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
isInstance :: Name -> [Type] -> Q Bool

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters of the tycon <tt>nm</tt>. Fails if <tt>nm</tt> cannot be
--   found or is not a tycon. The returned list should never contain
--   <a>InferR</a>.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | Annotation target for reifyAnnotations
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup
data TExp a
unType :: TExp a -> Exp

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
data NameSpace

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <tt>dyn</tt> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = <a>mkName</a> "x"
--     return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: String -> Q Name

-- | The name without its module prefix
nameBase :: Name -> String

-- | Module prefix of a name, if it exists
nameModule :: Name -> Maybe String

-- | Tuple type constructor
tupleTypeName :: Int -> Name

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)}
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr] -> Con -> [Name] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance Show w =&gt; Show [w]
--          where ds }
--   </pre>
InstanceD :: Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
InfixD :: Fixity -> Name -> Dec

-- | <pre>
--   { {--} }
--   </pre>
PragmaD :: Pragma -> Dec

-- | <pre>
--   { type family T a b c :: * }
--   </pre>
FamilyD :: FamFlavour -> Name -> [TyVarBndr] -> (Maybe Kind) -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x] = A x
--                                   | B (T x)
--          deriving (Z,W)}
--   </pre>
DataInstD :: Cxt -> Name -> [Type] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x] = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeInstD :: Cxt -> Name -> [Type] -> Con -> [Name] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
TySynInstD :: Name -> TySynEqn -> Dec

-- | <pre>
--   { type family F a b :: * where ... }
--   </pre>
ClosedTypeFamilyD :: Name -> [TyVarBndr] -> (Maybe Kind) -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
RoleAnnotD :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving instance Ord a =&gt; Ord (Foo a) }
--   </pre>
StandaloneDerivD :: Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
DefaultSigD :: Name -> Type -> Dec
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [StrictType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarStrictType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: StrictType -> Name -> StrictType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr] -> Cxt -> Con -> Con
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
data Strict
IsStrict :: Strict
NotStrict :: Strict
Unpacked :: Strict
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
SpecialiseP :: Name -> Type -> (Maybe Inline) -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
AnnP :: AnnTarget -> Exp -> Pragma
LineP :: Int -> String -> Pragma
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data AnnTarget
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget
data FunDep
FunDep :: [Name] -> [Name] -> FunDep
data FamFlavour
TypeFam :: FamFlavour
DataFam :: FamFlavour

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type patterns and the right-hand-side
--   result.
data TySynEqn
TySynEqn :: [Type] -> Type -> TySynEqn
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or <tt>c</tt>}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: (Maybe Exp) -> Exp -> (Maybe Exp) -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   {  p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
TupE :: [Exp] -> Exp

-- | <pre>
--   { () }
--   </pre>
UnboxedTupE :: [Exp] -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let x=e1;   y=e2 in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
DoE :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
StaticE :: Exp -> Exp
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard
data Stmt
BindS :: Pat -> Exp -> Stmt
LetS :: [Dec] -> Stmt
NoBindS :: Exp -> Stmt
ParS :: [[Stmt]] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type Addr#
StringPrimL :: [Word8] -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or <tt>c</tt> }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { () }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
ConP :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; -&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
TupleT :: Int -> Type

-- | <pre>
--   (), (), etc.
--   </pre>
UnboxedTupleT :: Int -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   ~
--   </pre>
EqualityT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <pre>
--   '(), '(,), '(,,), etc.
--   </pre>
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   (':)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <pre>
--   0,1,2, etc.
--   </pre>
LitT :: TyLit -> Type
data TyVarBndr

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> Kind -> TyVarBndr
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   <a>Hello</a>
--   </pre>
StrTyLit :: String -> TyLit

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type
type Cxt = [Pred]  @(Eq a, Ord b)@

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
NominalR :: Role

-- | <pre>
--   representational
--   </pre>
RepresentationalR :: Role

-- | <pre>
--   phantom
--   </pre>
PhantomR :: Role

-- | <pre>
--   _
--   </pre>
InferR :: Role
type InfoQ = Q Info
type ExpQ = Q Exp
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
rationalL :: Rational -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
conP :: Name -> [PatQ] -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> ExpQ

-- | <i>Deprecated: Use varE instead</i>
global :: Name -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
parensE :: ExpQ -> ExpQ

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
lamCaseE :: [MatchQ] -> ExpQ
tupE :: [ExpQ] -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
multiIfE :: [Q (Guard, Exp)] -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
appsE :: [ExpQ] -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
arithSeqE :: RangeQ -> ExpQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
doE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
forallT :: [TyVarBndr] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
arrowT :: TypeQ
equalityT :: TypeQ
listT :: TypeQ
tupleT :: Int -> TypeQ
sigT :: TypeQ -> Kind -> TypeQ
litT :: TyLitQ -> TypeQ
promotedT :: Name -> TypeQ
promotedTupleT :: Int -> TypeQ
promotedNilT :: TypeQ
promotedConsT :: TypeQ
numTyLit :: Integer -> TyLitQ
strTyLit :: String -> TyLitQ
isStrict :: Q Strict
notStrict :: Q Strict
strictType :: Q Strict -> TypeQ -> StrictTypeQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
cxt :: [PredQ] -> CxtQ

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Name -> [Q Type] -> Q Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: TypeQ -> TypeQ -> PredQ
normalC :: Name -> [StrictTypeQ] -> ConQ
recC :: Name -> [VarStrictTypeQ] -> ConQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
forallC :: [TyVarBndr] -> CxtQ -> ConQ -> ConQ
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Kind
constraintK :: Kind
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndr] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndr] -> [ConQ] -> [Name] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndr] -> ConQ -> [Name] -> DecQ
classD :: CxtQ -> Name -> [TyVarBndr] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
standaloneDerivD :: CxtQ -> TypeQ -> DecQ
defaultSigD :: Name -> TypeQ -> DecQ
roleAnnotD :: Name -> [Role] -> DecQ
familyNoKindD :: FamFlavour -> Name -> [TyVarBndr] -> DecQ
familyKindD :: FamFlavour -> Name -> [TyVarBndr] -> Kind -> DecQ
dataInstD :: CxtQ -> Name -> [TypeQ] -> [ConQ] -> [Name] -> DecQ
closedTypeFamilyNoKindD :: Name -> [TyVarBndr] -> [TySynEqnQ] -> DecQ
closedTypeFamilyKindD :: Name -> [TyVarBndr] -> Kind -> [TySynEqnQ] -> DecQ
newtypeInstD :: CxtQ -> Name -> [TypeQ] -> ConQ -> [Name] -> DecQ
tySynInstD :: Name -> TySynEqnQ -> DecQ
typeFam :: FamFlavour
dataFam :: FamFlavour
tySynEqn :: [TypeQ] -> TypeQ -> TySynEqnQ
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
ruleVar :: Name -> RuleBndrQ
typedRuleVar :: Name -> TypeQ -> RuleBndrQ
pragInlD :: Name -> Inline -> RuleMatch -> Phases -> DecQ
pragSpecD :: Name -> TypeQ -> Phases -> DecQ
pragSpecInlD :: Name -> TypeQ -> Inline -> Phases -> DecQ
pragSpecInstD :: TypeQ -> DecQ
pragRuleD :: String -> [RuleBndrQ] -> ExpQ -> ExpQ -> Phases -> DecQ
pragAnnD :: AnnTarget -> ExpQ -> DecQ
pragLineD :: Int -> String -> DecQ
class Ppr a where ppr_list = vcat . map ppr
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
pprint :: Ppr a => a -> String
pprExp :: Precedence -> Exp -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
pprParendType :: Type -> Doc

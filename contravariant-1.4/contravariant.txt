-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Contravariant functors
--   
--   Contravariant functors
@package contravariant
@version 1.4


-- | <a>Contravariant</a> functors, sometimes referred to colloquially as
--   <tt>Cofunctor</tt>, even though the dual of a <a>Functor</a> is just a
--   <a>Functor</a>. As with <a>Functor</a> the definition of
--   <a>Contravariant</a> for a given ADT is unambiguous.
module Data.Functor.Contravariant

-- | Any instance should be subject to the following laws:
--   
--   <pre>
--   contramap id = id
--   contramap f . contramap g = contramap (g . f)
--   </pre>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class Contravariant f where (>$) = contramap . const
contramap :: Contravariant f => (a -> b) -> f b -> f a

-- | Replace all locations in the output with the same value. The default
--   definition is <tt><a>contramap</a> . <a>const</a></tt>, but this may
--   be overridden with a more efficient version.
(>$) :: Contravariant f => b -> f b -> f a

-- | If <tt>f</tt> is both <a>Functor</a> and <a>Contravariant</a> then by
--   the time you factor in the laws of each of those classes, it can't
--   actually use it's argument in any meaningful capacity.
--   
--   This method is surprisingly useful. Where both instances exist and are
--   lawful we have the following laws:
--   
--   <pre>
--   <a>fmap</a> f ≡ <a>phantom</a>
--   <a>contramap</a> f ≡ <a>phantom</a>
--   </pre>
phantom :: (Functor f, Contravariant f) => f a -> f b

-- | This is an infix alias for <a>contramap</a>
(>$<) :: Contravariant f => (a -> b) -> f b -> f a

-- | This is an infix version of <a>contramap</a> with the arguments
--   flipped.
(>$$<) :: Contravariant f => f b -> (a -> b) -> f a

-- | This is <a>&gt;$</a> with its arguments flipped.
($<) :: Contravariant f => f b -> b -> f a
newtype Predicate a
Predicate :: (a -> Bool) -> Predicate a
[getPredicate] :: Predicate a -> a -> Bool

-- | Defines a total ordering on a type as per <a>compare</a>
--   
--   This condition is not checked by the types. You must ensure that the
--   supplied values are valid total orderings yourself.
newtype Comparison a
Comparison :: (a -> a -> Ordering) -> Comparison a
[getComparison] :: Comparison a -> a -> a -> Ordering

-- | Compare using <a>compare</a>
defaultComparison :: Ord a => Comparison a

-- | This data type represents an equivalence relation.
--   
--   Equivalence relations are expected to satisfy three laws:
--   
--   <b>Reflexivity</b>:
--   
--   <pre>
--   <a>getEquivalence</a> f a a = True
--   </pre>
--   
--   <b>Symmetry</b>:
--   
--   <pre>
--   <a>getEquivalence</a> f a b = <a>getEquivalence</a> f b a
--   </pre>
--   
--   <b>Transitivity</b>:
--   
--   If <tt><a>getEquivalence</a> f a b</tt> and <tt><a>getEquivalence</a>
--   f b c</tt> are both <a>True</a> then so is <tt><a>getEquivalence</a> f
--   a c</tt>
--   
--   The types alone do not enforce these laws, so you'll have to check
--   them yourself.
newtype Equivalence a
Equivalence :: (a -> a -> Bool) -> Equivalence a
[getEquivalence] :: Equivalence a -> a -> a -> Bool

-- | Check for equivalence with <a>==</a>
--   
--   Note: The instances for <a>Double</a> and <a>Float</a> violate
--   reflexivity for <tt>NaN</tt>.
defaultEquivalence :: Eq a => Equivalence a
comparisonEquivalence :: Comparison a -> Equivalence a

-- | Dual function arrows.
newtype Op a b
Op :: (b -> a) -> Op a b
[getOp] :: Op a b -> b -> a
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Data.Monoid.Alt f)
instance Data.Functor.Contravariant.Contravariant GHC.Generics.V1
instance Data.Functor.Contravariant.Contravariant GHC.Generics.U1
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (GHC.Generics.M1 i c f)
instance Data.Functor.Contravariant.Contravariant (GHC.Generics.K1 i c)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:*: g)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:.: g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:+: g)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Error.ErrorT e m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Constant.Constant a)
instance Data.Functor.Contravariant.Contravariant (Control.Applicative.Const a)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Compose.Compose f g)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Contravariant.Contravariant Data.StateVar.SettableStateVar
instance Data.Functor.Contravariant.Contravariant Data.Proxy.Proxy
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Predicate
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Comparison
instance Data.Semigroup.Semigroup (Data.Functor.Contravariant.Comparison a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a)
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Equivalence
instance Data.Semigroup.Semigroup (Data.Functor.Contravariant.Equivalence a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a)
instance Control.Category.Category Data.Functor.Contravariant.Op
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Op a)
instance Data.Semigroup.Semigroup a => Data.Semigroup.Semigroup (Data.Functor.Contravariant.Op a b)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Contravariant.Op a b)
instance GHC.Num.Num a => GHC.Num.Num (Data.Functor.Contravariant.Op a b)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Contravariant.Op a b)


-- | This module supplies contravariant analogues to the <a>Applicative</a>
--   and <a>Alternative</a> classes.
module Data.Functor.Contravariant.Divisible

-- | A <a>Divisible</a> contravariant functor is the contravariant analogue
--   of <a>Applicative</a>.
--   
--   In denser jargon, a <a>Divisible</a> contravariant functor is a monoid
--   object in the category of presheaves from Hask to Hask, equipped with
--   Day convolution mapping the Cartesian product of the source to the
--   Cartesian product of the target.
--   
--   By way of contrast, an <a>Applicative</a> functor can be viewed as a
--   monoid object in the category of copresheaves from Hask to Hask,
--   equipped with Day convolution mapping the Cartesian product of the
--   source to the Cartesian product of the target.
--   
--   Given the canonical diagonal morphism:
--   
--   <pre>
--   delta a = (a,a)
--   </pre>
--   
--   <tt><a>divide</a> <tt>delta</tt></tt> should be associative with
--   <a>conquer</a> as a unit
--   
--   <pre>
--   <a>divide</a> <tt>delta</tt> m <a>conquer</a> = m
--   <a>divide</a> <tt>delta</tt> <a>conquer</a> m = m
--   <a>divide</a> <tt>delta</tt> (<a>divide</a> <tt>delta</tt> m n) o = <a>divide</a> <tt>delta</tt> m (<a>divide</a> <tt>delta</tt> n o)
--   </pre>
--   
--   With more general arguments you'll need to reassociate and project
--   using the monoidal structure of the source category. (Here fst and snd
--   are used in lieu of the more restricted lambda and rho, but this
--   construction works with just a monoidal category.)
--   
--   <pre>
--   <a>divide</a> f m <a>conquer</a> = <a>contramap</a> (<a>fst</a> . f) m
--   <a>divide</a> f <a>conquer</a> m = <a>contramap</a> (<a>snd</a> . f) m
--   <a>divide</a> f (<a>divide</a> g m n) o = <a>divide</a> f' m (<a>divide</a> <a>id</a> n o) where
--     f' a = case f a of (bc,d) -&gt; case g bc of (b,c) -&gt; (a,(b,c))
--   </pre>
class Contravariant f => Divisible f
divide :: Divisible f => (a -> (b, c)) -> f b -> f c -> f a

-- | The underlying theory would suggest that this should be:
--   
--   <pre>
--   conquer :: (a -&gt; ()) -&gt; f a
--   </pre>
--   
--   However, as we are working over a Cartesian category (Hask) and the
--   Cartesian product, such an input morphism is uniquely determined to be
--   <tt><a>const</a> <a>mempty</a></tt>, so we elide it.
conquer :: Divisible f => f a

-- | <pre>
--   <a>divided</a> = <a>divide</a> <a>id</a>
--   </pre>
divided :: Divisible f => f a -> f b -> f (a, b)

-- | Redundant, but provided for symmetry.
--   
--   <pre>
--   <a>conquered</a> = <a>conquer</a>
--   </pre>
conquered :: Divisible f => f ()

-- | This is the divisible analogue of <a>liftA</a>. It gives a viable
--   default definition for <a>contramap</a> in terms of the members of
--   <a>Divisible</a>.
--   
--   <pre>
--   <a>liftD</a> f = <a>divide</a> ((,) () . f) <a>conquer</a>
--   </pre>
liftD :: Divisible f => (a -> b) -> f b -> f a

-- | A <a>Divisible</a> contravariant functor is a monoid object in the
--   category of presheaves from Hask to Hask, equipped with Day
--   convolution mapping the cartesian product of the source to the
--   Cartesian product of the target.
--   
--   <pre>
--   <a>choose</a> <a>Left</a> m (<a>lose</a> f)  = m
--   <a>choose</a> <a>Right</a> (<a>lose</a> f) m = m
--   <a>choose</a> f (<a>choose</a> g m n) o = <a>divide</a> f' m (<a>divide</a> <a>id</a> n o) where
--     f' bcd = <a>either</a> (<a>either</a> <a>id</a> (<a>Right</a> . <a>Left</a>) . g) (<a>Right</a> . <a>Right</a>) . f
--   </pre>
--   
--   In addition, we expect the same kind of distributive law as is
--   satisfied by the usual covariant <a>Alternative</a>, w.r.t
--   <a>Applicative</a>, which should be fully formulated and added here at
--   some point!
class Divisible f => Decidable f

-- | The only way to win is not to play.
lose :: Decidable f => (a -> Void) -> f a
choose :: Decidable f => (a -> Either b c) -> f b -> f c -> f a

-- | <pre>
--   <a>chosen</a> = <a>choose</a> <a>id</a>
--   </pre>
chosen :: Decidable f => f b -> f c -> f (Either b c)

-- | <pre>
--   <a>lost</a> = <a>lose</a> <a>id</a>
--   </pre>
lost :: Decidable f => f Void
instance GHC.Base.Monoid r => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Contravariant.Op r)
instance Data.Functor.Contravariant.Divisible.Divisible Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Divisible.Divisible Data.Functor.Contravariant.Equivalence
instance Data.Functor.Contravariant.Divisible.Divisible Data.Functor.Contravariant.Predicate
instance GHC.Base.Monoid m => Data.Functor.Contravariant.Divisible.Divisible (Control.Applicative.Const m)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Data.Monoid.Alt f)
instance Data.Functor.Contravariant.Divisible.Divisible GHC.Generics.U1
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (GHC.Generics.M1 i c f)
instance (Data.Functor.Contravariant.Divisible.Divisible f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (f GHC.Generics.:*: g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (f GHC.Generics.:.: g)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Error.ErrorT e m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Compose.Compose f g)
instance GHC.Base.Monoid m => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Constant.Constant m)
instance (Data.Functor.Contravariant.Divisible.Divisible f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Contravariant.Divisible.Divisible Data.Proxy.Proxy
instance Data.Functor.Contravariant.Divisible.Decidable Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Divisible.Decidable Data.Functor.Contravariant.Equivalence
instance Data.Functor.Contravariant.Divisible.Decidable Data.Functor.Contravariant.Predicate
instance GHC.Base.Monoid r => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Contravariant.Op r)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Data.Monoid.Alt f)
instance Data.Functor.Contravariant.Divisible.Decidable GHC.Generics.U1
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (GHC.Generics.M1 i c f)
instance (Data.Functor.Contravariant.Divisible.Decidable f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (f GHC.Generics.:*: g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (f GHC.Generics.:.: g)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Contravariant.Divisible.Decidable f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Contravariant.Divisible.Decidable Data.Proxy.Proxy


-- | Composition of contravariant functors.
module Data.Functor.Contravariant.Compose

-- | Composition of two contravariant functors
newtype Compose f g a
Compose :: f (g a) -> Compose f g a
[getCompose] :: Compose f g a -> f (g a)

-- | Composition of covariant and contravariant functors
newtype ComposeFC f g a
ComposeFC :: f (g a) -> ComposeFC f g a
[getComposeFC] :: ComposeFC f g a -> f (g a)

-- | Composition of contravariant and covariant functors
newtype ComposeCF f g a
ComposeCF :: f (g a) -> ComposeCF f g a
[getComposeCF] :: ComposeCF f g a -> f (g a)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => GHC.Base.Functor (Data.Functor.Contravariant.Compose.Compose f g)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (Data.Functor.Contravariant.Contravariant f, GHC.Base.Functor g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Compose.ComposeCF f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Contravariant.Compose.ComposeCF f g)
instance (Data.Functor.Contravariant.Divisible.Divisible f, GHC.Base.Applicative g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Contravariant.Compose.ComposeCF f g)


module Data.Functor.Contravariant.Generic

-- | This provides machinery for deconstructing an arbitrary <a>Generic</a>
--   instance using a <a>Decidable</a> <a>Contravariant</a> functor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   gcompare :: <a>Deciding</a> <a>Ord</a> a =&gt; a -&gt; a -&gt; <a>Ordering</a>
--   gcompare = <a>getComparison</a> $ <a>deciding</a> (Proxy :: Proxy <a>Ord</a>) (<a>Comparison</a> <a>compare</a>)
--   </pre>
--   
--   <pre>
--   geq :: <a>Deciding</a> <a>Eq</a> a =&gt; a -&gt; a -&gt; <a>Bool</a>
--   geq = <a>getEquivalence</a> $ <a>deciding</a> (Proxy :: Proxy <a>Eq</a>) (<a>Equivalence</a> (<a>==</a>))
--   </pre>
class (Generic a, GDeciding q (Rep a)) => Deciding q a
deciding :: (Deciding q a, Decidable f) => p q -> (forall b. q b => f b) -> f a

-- | This provides machinery for deconstructing an arbitrary
--   <a>Generic1</a> instance using a <a>Decidable</a> <a>Contravariant</a>
--   functor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   gcompare1 :: <a>Deciding1</a> <a>Ord</a> f =&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; f a -&gt; f a -&gt; <a>Ordering</a>
--   gcompare1 f = <a>getComparison</a> $ <a>deciding1</a> (Proxy :: Proxy <a>Ord</a>) (<a>Comparison</a> compare) (<a>Comparison</a> f)
--   </pre>
--   
--   <pre>
--   geq1 :: <a>Deciding1</a> <a>Eq</a> f =&gt; (a -&gt; a -&gt; <a>Bool</a>) -&gt; f a -&gt; f a -&gt; <a>Bool</a>
--   geq1 f = <a>getEquivalence</a> $ <a>deciding1</a> (Proxy :: Proxy <a>Eq</a>) (<a>Equivalence</a> (<a>==</a>)) (<a>Equivalence</a> f)
--   </pre>
class (Generic1 t, GDeciding1 q (Rep1 t)) => Deciding1 q t
deciding1 :: (Deciding1 q t, Decidable f) => p q -> (forall b. q b => f b) -> f a -> f (t a)
instance (GHC.Generics.Generic a, Data.Functor.Contravariant.Generic.GDeciding q (GHC.Generics.Rep a)) => Data.Functor.Contravariant.Generic.Deciding q a
instance (GHC.Generics.Generic1 t, Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.Rep1 t)) => Data.Functor.Contravariant.Generic.Deciding1 q t
instance Data.Functor.Contravariant.Generic.GDeciding q GHC.Generics.U1
instance Data.Functor.Contravariant.Generic.GDeciding q GHC.Generics.V1
instance (Data.Functor.Contravariant.Generic.GDeciding q f, Data.Functor.Contravariant.Generic.GDeciding q g) => Data.Functor.Contravariant.Generic.GDeciding q (f GHC.Generics.:*: g)
instance (Data.Functor.Contravariant.Generic.GDeciding q f, Data.Functor.Contravariant.Generic.GDeciding q g) => Data.Functor.Contravariant.Generic.GDeciding q (f GHC.Generics.:+: g)
instance q p => Data.Functor.Contravariant.Generic.GDeciding q (GHC.Generics.K1 i p)
instance Data.Functor.Contravariant.Generic.GDeciding q f => Data.Functor.Contravariant.Generic.GDeciding q (GHC.Generics.M1 i c f)
instance Data.Functor.Contravariant.Generic.GDeciding1 q GHC.Generics.U1
instance Data.Functor.Contravariant.Generic.GDeciding1 q GHC.Generics.V1
instance (Data.Functor.Contravariant.Generic.GDeciding1 q f, Data.Functor.Contravariant.Generic.GDeciding1 q g) => Data.Functor.Contravariant.Generic.GDeciding1 q (f GHC.Generics.:*: g)
instance (Data.Functor.Contravariant.Generic.GDeciding1 q f, Data.Functor.Contravariant.Generic.GDeciding1 q g) => Data.Functor.Contravariant.Generic.GDeciding1 q (f GHC.Generics.:+: g)
instance q p => Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.K1 i p)
instance Data.Functor.Contravariant.Generic.GDeciding1 q f => Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.M1 i c f)
instance Data.Functor.Contravariant.Generic.GDeciding1 q GHC.Generics.Par1
instance Data.Functor.Contravariant.Generic.Deciding1 q f => Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.Rec1 f)

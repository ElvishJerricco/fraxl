<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Bifunctor.TH</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Bifunctor-TH.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">bifunctors-5.2: Bifunctors</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(C) 2008-2016 Edward Kmett, (C) 2015 Ryan Scott</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>Edward Kmett &lt;ekmett@gmail.com&gt;</td></tr><tr><th>Stability</th><td>provisional</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.Bifunctor.TH</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1"><code>derive</code>- functions</a></li><li><a href="#g:2"><code>Bifoldable</code></a></li><li><a href="#g:3"><code>Bitraversable</code></a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Functions to mechanically derive <code>Bifunctor</code>, <code>Bifoldable</code>,
 or <code>Bitraversable</code> instances, or to splice their functions directly into
 source code. You need to enable the <code>TemplateHaskell</code> language extension
 in order to use this module.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:deriveBifunctor">deriveBifunctor</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</li><li class="src short"><a href="#v:makeBimap">makeBimap</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:deriveBifoldable">deriveBifoldable</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</li><li class="src short"><a href="#v:makeBifold">makeBifold</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:makeBifoldMap">makeBifoldMap</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:makeBifoldr">makeBifoldr</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:makeBifoldl">makeBifoldl</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:deriveBitraversable">deriveBitraversable</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</li><li class="src short"><a href="#v:makeBitraverse">makeBitraverse</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:makeBisequenceA">makeBisequenceA</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:makeBimapM">makeBimapM</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:makeBisequence">makeBisequence</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></li></ul></div><div id="interface"><h1 id="g:1"><code>derive</code>- functions</h1><div class="doc"><p><code><a href="Data-Bifunctor-TH.html#v:deriveBifunctor">deriveBifunctor</a></code>, <code><a href="Data-Bifunctor-TH.html#v:deriveBifoldable">deriveBifoldable</a></code>, and <code><a href="Data-Bifunctor-TH.html#v:deriveBitraversable">deriveBitraversable</a></code> automatically
generate their respective class instances for a given data type, newtype, or data
family instance that has at least two type variable. Examples:</p><pre>{-# LANGUAGE TemplateHaskell #-}
import Data.Bifunctor.TH

data Pair a b = Pair a b
$(<code><a href="Data-Bifunctor-TH.html#v:deriveBifunctor">deriveBifunctor</a></code> ''Pair) -- instance Bifunctor Pair where ...

data WrapLeftPair f g a b = WrapLeftPair (f a) (g a b)
$(<code><a href="Data-Bifunctor-TH.html#v:deriveBifoldable">deriveBifoldable</a></code> ''WrapLeftPair)
-- instance (Foldable f, Bifoldable g) =&gt; Bifoldable (WrapLeftPair f g) where ...
</pre><p>If you are using <code>template-haskell-2.7.0.0</code> or later (i.e., GHC 7.4 or later),
the <code>derive</code> functions can be used data family instances (which requires the
<code>-XTypeFamilies</code> extension). To do so, pass the name of a data or newtype instance
constructor (NOT a data family name!) to a <code>derive</code> function.  Note that the
generated code may require the <code>-XFlexibleInstances</code> extension. Example:</p><pre>{-# LANGUAGE FlexibleInstances, TemplateHaskell, TypeFamilies #-}
import Data.Bifunctor.TH

class AssocClass a b c where
    data AssocData a b c
instance AssocClass Int b c where
    data AssocData Int b c = AssocDataInt1 Int | AssocDataInt2 b c
$(<code><a href="Data-Bifunctor-TH.html#v:deriveBitraversable">deriveBitraversable</a></code> 'AssocDataInt1) -- instance Bitraversable (AssocData Int) where ...
-- Alternatively, one could use $(deriveBitraversable 'AssocDataInt2)
</pre><p>Note that there are some limitations:</p><ul><li>The <code><a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a></code> argument to a <code>derive</code> function must not be a type synonym.</li><li>With a <code>derive</code> function, the last two type variables must both be of kind <code>*</code>.
  Other type variables of kind <code>* -&gt; *</code> are assumed to require a <code><a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a></code>,
  <code><a href="../base-4.8.2.0/Data-Foldable.html#t:Foldable">Foldable</a></code>, or <code><a href="../base-4.8.2.0/Data-Traversable.html#t:Traversable">Traversable</a></code> constraint (depending on which <code>derive</code> function is
  used), and other type variables of kind <code>* -&gt; * -&gt; *</code> are assumed to require an
  <code>Bifunctor</code>, <code>Bifoldable</code>, or <code>Bitraversable</code> constraint. If your data type
  doesn't meet these assumptions, use a <code>make</code> function.</li><li>If using the <code>-XDatatypeContexts</code>, <code>-XExistentialQuantification</code>, or <code>-XGADTs</code>
  extensions, a constraint cannot mention either of the last two type variables. For
  example, <code>data Illegal2 a b where I2 :: Ord a =&gt; a -&gt; b -&gt; Illegal2 a b</code> cannot
  have a derived <code>Bifunctor</code> instance.</li><li>If either of the last two type variables is used within a constructor argument's
  type, it must only be used in the last two type arguments. For example,
  <code>data Legal a b = Legal (Int, Int, a, b)</code> can have a derived <code>Bifunctor</code> instance,
  but <code>data Illegal a b = Illegal (a, b, a, b)</code> cannot.</li><li>Data family instances must be able to eta-reduce the last two type variables. In other
  words, if you have a instance of the form:</li></ul><pre> data family Family a1 ... an t1 t2
 data instance Family e1 ... e2 v1 v2 = ...
 </pre><p>Then the following conditions must hold:</p><ol><li><code>v1</code> and <code>v2</code> must be distinct type variables.</li><li>Neither <code>v1</code> not <code>v2</code> must be mentioned in any of <code>e1</code>, ..., <code>e2</code>.</li></ol><ul><li>In GHC 7.8, a bug exists that can cause problems when a data family declaration and
  one of its data instances use different type variables, e.g.,</li></ul><pre> data family Foo a b c
 data instance Foo Int y z = Foo Int y z
 $(deriveBifunctor 'Foo)
 </pre><p>To avoid this issue, it is recommened that you use the same type variables in the
  same positions in which they appeared in the data family declaration:</p><pre> data family Foo a b c
 data instance Foo Int b c = Foo Int b c
 $(deriveBifunctor 'Foo)
 </pre></div><div class="top"><p class="src"><a name="v:deriveBifunctor" class="def">deriveBifunctor</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</p><div class="doc"><p>Generates a <code>Bifunctor</code> instance declaration for the given data type or data
 family instance.</p></div></div><div class="top"><p class="src"><a name="v:makeBimap" class="def">makeBimap</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></p><div class="doc"><p>Generates a lambda expression which behaves like <code>bimap</code> (without requiring a
 <code>Bifunctor</code> instance).</p></div></div><h1 id="g:2"><code>Bifoldable</code></h1><div class="top"><p class="src"><a name="v:deriveBifoldable" class="def">deriveBifoldable</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</p><div class="doc"><p>Generates a <code>Bifoldable</code> instance declaration for the given data type or data
 family instance.</p></div></div><div class="top"><p class="src"><a name="v:makeBifold" class="def">makeBifold</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></p><div class="doc"><p>Generates a lambda expression which behaves like <code>bifold</code> (without requiring a
 <code>Bifoldable</code> instance).</p></div></div><div class="top"><p class="src"><a name="v:makeBifoldMap" class="def">makeBifoldMap</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></p><div class="doc"><p>Generates a lambda expression which behaves like <code>bifoldMap</code> (without requiring a
 <code>Bifoldable</code> instance).</p></div></div><div class="top"><p class="src"><a name="v:makeBifoldr" class="def">makeBifoldr</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></p><div class="doc"><p>Generates a lambda expression which behaves like <code>bifoldr</code> (without requiring a
 <code>Bifoldable</code> instance).</p></div></div><div class="top"><p class="src"><a name="v:makeBifoldl" class="def">makeBifoldl</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></p><div class="doc"><p>Generates a lambda expression which behaves like <code>bifoldl</code> (without requiring a
 <code>Bifoldable</code> instance).</p></div></div><h1 id="g:3"><code>Bitraversable</code></h1><div class="top"><p class="src"><a name="v:deriveBitraversable" class="def">deriveBitraversable</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</p><div class="doc"><p>Generates a <code>Bitraversable</code> instance declaration for the given data type or data
 family instance.</p></div></div><div class="top"><p class="src"><a name="v:makeBitraverse" class="def">makeBitraverse</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></p><div class="doc"><p>Generates a lambda expression which behaves like <code>bitraverse</code> (without requiring a
 <code>Bitraversable</code> instance).</p></div></div><div class="top"><p class="src"><a name="v:makeBisequenceA" class="def">makeBisequenceA</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></p><div class="doc"><p>Generates a lambda expression which behaves like <code>bisequenceA</code> (without requiring a
 <code>Bitraversable</code> instance).</p></div></div><div class="top"><p class="src"><a name="v:makeBimapM" class="def">makeBimapM</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></p><div class="doc"><p>Generates a lambda expression which behaves like <code>bimapM</code> (without requiring a
 <code>Bitraversable</code> instance).</p></div></div><div class="top"><p class="src"><a name="v:makeBisequence" class="def">makeBisequence</a> :: <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> <a href="../template-haskell-2.10.0.0/Language-Haskell-TH-Syntax.html#t:Exp">Exp</a></p><div class="doc"><p>Generates a lambda expression which behaves like <code>bisequence</code> (without requiring a
 <code>Bitraversable</code> instance).</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bifunctors
--   
--   Bifunctors
@package bifunctors
@version 5.2


-- | Functions to mechanically derive <a>Bifunctor</a>, <a>Bifoldable</a>,
--   or <a>Bitraversable</a> instances, or to splice their functions
--   directly into source code. You need to enable the
--   <tt>TemplateHaskell</tt> language extension in order to use this
--   module.
module Data.Bifunctor.TH

-- | Generates a <a>Bifunctor</a> instance declaration for the given data
--   type or data family instance.
deriveBifunctor :: Name -> Q [Dec]

-- | Generates a lambda expression which behaves like <tt>bimap</tt>
--   (without requiring a <a>Bifunctor</a> instance).
makeBimap :: Name -> Q Exp

-- | Generates a <a>Bifoldable</a> instance declaration for the given data
--   type or data family instance.
deriveBifoldable :: Name -> Q [Dec]

-- | Generates a lambda expression which behaves like <tt>bifold</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifold :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bifoldMap</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifoldMap :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bifoldr</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifoldr :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bifoldl</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifoldl :: Name -> Q Exp

-- | Generates a <a>Bitraversable</a> instance declaration for the given
--   data type or data family instance.
deriveBitraversable :: Name -> Q [Dec]

-- | Generates a lambda expression which behaves like <tt>bitraverse</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBitraverse :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bisequenceA</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBisequenceA :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bimapM</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBimapM :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bisequence</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBisequence :: Name -> Q Exp
instance GHC.Classes.Eq Data.Bifunctor.TH.BiFun

module Data.Bifunctor.Functor

-- | Using parametricity as an approximation of a natural transformation in
--   two arguments.
type (:->) p q = forall a b. p a b -> q a b
class BifunctorFunctor t
bifmap :: BifunctorFunctor t => (p :-> q) -> t p :-> t q
class BifunctorFunctor t => BifunctorMonad t where bibind f = bijoin . bifmap f bijoin = bibind id
bireturn :: BifunctorMonad t => p :-> t p
bibind :: BifunctorMonad t => (p :-> t q) -> t p :-> t q
bijoin :: BifunctorMonad t => t (t p) :-> t p
biliftM :: BifunctorMonad t => (p :-> q) -> t p :-> t q
class BifunctorFunctor t => BifunctorComonad t where biextend f = bifmap f . biduplicate biduplicate = biextend id
biextract :: BifunctorComonad t => t p :-> p
biextend :: BifunctorComonad t => (t p :-> q) -> t p :-> t q
biduplicate :: BifunctorComonad t => t p :-> t (t p)
biliftW :: BifunctorComonad t => (p :-> q) -> t p :-> t q


module Data.Bifoldable

-- | Minimal definition either <a>bifoldr</a> or <a>bifoldMap</a>
--   
--   <a>Bifoldable</a> identifies foldable structures with two different
--   varieties of elements. Common examples are <a>Either</a> and '(,)':
--   
--   <pre>
--   instance Bifoldable Either where
--     bifoldMap f _ (Left  a) = f a
--     bifoldMap _ g (Right b) = g b
--   
--   instance Bifoldable (,) where
--     bifoldr f g z (a, b) = f a (g b z)
--   </pre>
--   
--   When defining more than the minimal set of definitions, one should
--   ensure that the following identities hold:
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   <a>bifoldr</a> f g z t ≡ <a>appEndo</a> (<a>bifoldMap</a> (Endo . f) (Endo . g) t) z
--   </pre>
class Bifoldable p where bifold = bifoldMap id id bifoldMap f g = bifoldr (mappend . f) (mappend . g) mempty bifoldr f g z t = appEndo (bifoldMap (Endo . f) (Endo . g) t) z bifoldl f g z t = appEndo (getDual (bifoldMap (Dual . Endo . flip f) (Dual . Endo . flip g) t)) z

-- | Combines the elements of a structure using a monoid.
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   </pre>
bifold :: (Bifoldable p, Monoid m) => p m m -> m

-- | Combines the elements of a structure, given ways of mapping them to a
--   common monoid.
--   
--   <pre>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   </pre>
bifoldMap :: (Bifoldable p, Monoid m) => (a -> m) -> (b -> m) -> p a b -> m

-- | Combines the elements of a structure in a right associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldr</a> f g z ≡ <a>foldr</a> (<a>either</a> f g) z . toEitherList
--   </pre>
bifoldr :: Bifoldable p => (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c

-- | Combines the elments of a structure in a left associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldl</a> f g z ≡ <a>foldl</a> (acc -&gt; <a>either</a> (f acc) (g acc)) z .  toEitherList
--   </pre>
bifoldl :: Bifoldable p => (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c

-- | As <a>bifoldr</a>, but strict in the result of the reduction functions
--   at each step.
bifoldr' :: Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c

-- | Right associative monadic bifold over a structure.
bifoldrM :: (Bifoldable t, Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c

-- | As <a>bifoldl</a>, but strict in the result of the reductionf unctions
--   at each step.
bifoldl' :: Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a

-- | Left associative monadic bifold over a structure.
bifoldlM :: (Bifoldable t, Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a

-- | As <a>bitraverse</a>, but ignores the results of the functions, merely
--   performing the "actions".
bitraverse_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | As <a>bitraverse_</a>, but with the structure as the primary argument.
bifor_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | As <a>bimapM</a>, but ignores the results of the functions, merely
--   performing the "actions".
bimapM_ :: (Bifoldable t, Monad m) => (a -> m c) -> (b -> m d) -> t a b -> m ()

-- | As <a>bimapM_</a>, but with the structure as the primary argument.
biforM_ :: (Bifoldable t, Monad m) => t a b -> (a -> m c) -> (b -> m d) -> m ()

-- | As <a>bisequenceA</a>, but ignores the results of the actions.
bisequenceA_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | As <a>bisequence</a>, but ignores the results of the actions.
bisequence_ :: (Bifoldable t, Monad m) => t (m a) (m b) -> m ()

-- | Collects the list of elements of a structure in order.
biList :: Bifoldable t => t a a -> [a]

-- | Reduces a structure of lists to the concatenation of those lists.
biconcat :: Bifoldable t => t [a] [a] -> [a]

-- | Given a means of mapping the elements of a structure to lists,
--   computes the concatenation of all such lists in order.
biconcatMap :: Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]

-- | Determines whether any element of the structure satisfies the
--   appropriate predicate.
biany :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | Determines whether all elements of the structure satisfy the
--   appropriate predicate.
biall :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool
instance Data.Bifoldable.Bifoldable Data.Semigroup.Arg
instance Data.Bifoldable.Bifoldable (,)
instance Data.Bifoldable.Bifoldable Control.Applicative.Const
instance Data.Bifoldable.Bifoldable ((,,) x)
instance Data.Bifoldable.Bifoldable ((,,,) x y)
instance Data.Bifoldable.Bifoldable ((,,,,) x y z)
instance Data.Bifoldable.Bifoldable ((,,,,,) x y z w)
instance Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v)
instance Data.Bifoldable.Bifoldable Data.Tagged.Tagged
instance Data.Bifoldable.Bifoldable Data.Either.Either


module Data.Bitraversable

-- | <a>Bitraversable</a> identifies bifunctorial data structures whose
--   elements can be traversed in order, performing <a>Applicative</a> or
--   <a>Monad</a> actions at each element, and collecting a result
--   structure with the same shape.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt><a>bitraverse</a> (t . f) (t . g) ≡ t
--   . <a>bitraverse</a> f g</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>bitraverse</a> <tt>Identity</tt>
--   <tt>Identity</tt> ≡ <tt>Identity</tt></tt></li>
--   <li><i><i>composition</i></i> <tt><tt>Compose</tt> . <a>fmap</a>
--   (<a>bitraverse</a> g1 g2) . <a>bitraverse</a> f1 f2 ≡ <a>traverse</a>
--   (<tt>Compose</tt> . <a>fmap</a> g1 . f1) (<tt>Compose</tt> .
--   <a>fmap</a> g2 . f2)</tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (<a>Applicative</a> f, <a>Applicative</a> g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations:
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <tt>Identity</tt> and composition functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity { runIdentity :: a }
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Identity where
--     pure = Identity
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure = Compose . pure . pure
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   Some simple examples are <a>Either</a> and '(,)':
--   
--   <pre>
--   instance Bitraversable Either where
--     bitraverse f _ (Left x) = Left &lt;$&gt; f x
--     bitraverse _ g (Right y) = Right &lt;$&gt; g y
--   
--   instance Bitraversable (,) where
--     bitraverse f g (x, y) = (,) &lt;$&gt; f x &lt;*&gt; g y
--   </pre>
--   
--   <a>Bitraversable</a> relates to its superclasses in the following
--   ways:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <tt>runIdentity</tt> . <a>bitraverse</a> (<tt>Identity</tt> . f) (<tt>Identity</tt> . g)
--   <a>bifoldMap</a> f g = <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
--   
--   These are available as <a>bimapDefault</a> and <a>bifoldMapDefault</a>
--   respectively.
class (Bifunctor t, Bifoldable t) => Bitraversable t where bitraverse f g = bisequenceA . bimap f g

-- | Evaluates the relevant functions at each element in the structure,
--   running the action, and builds a new structure with the same shape,
--   using the elements produced from sequencing the actions.
--   
--   <pre>
--   <a>bitraverse</a> f g ≡ <a>bisequenceA</a> . <a>bimap</a> f g
--   </pre>
bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

-- | Sequences all the actions in a structure, building a new structure
--   with the same shape using the results of the actions.
--   
--   <pre>
--   <a>bisequenceA</a> ≡ <a>bitraverse</a> <a>id</a> <a>id</a>
--   </pre>
bisequenceA :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)

-- | As <a>bisequenceA</a>, but uses evidence that <tt>m</tt> is a
--   <a>Monad</a> rather than an <a>Applicative</a>.
--   
--   <pre>
--   <a>bisequence</a> ≡ <a>bimapM</a> <a>id</a> <a>id</a>
--   <a>bisequence</a> ≡ <a>unwrapMonad</a> . <a>bisequenceA</a> . <a>bimap</a> <a>WrapMonad</a> <a>WrapMonad</a>
--   </pre>
bisequence :: (Bitraversable t, Monad m) => t (m a) (m b) -> m (t a b)

-- | As <a>bitraverse</a>, but uses evidence that <tt>m</tt> is a
--   <a>Monad</a> rather than an <a>Applicative</a>.
--   
--   <pre>
--   <a>bimapM</a> f g ≡ <a>bisequence</a> . <a>bimap</a> f g
--   <a>bimapM</a> f g ≡ <a>unwrapMonad</a> . <a>bitraverse</a> (<a>WrapMonad</a> . f) (<a>WrapMonad</a> . g)
--   </pre>
bimapM :: (Bitraversable t, Monad m) => (a -> m c) -> (b -> m d) -> t a b -> m (t c d)

-- | <a>bifor</a> is <a>bitraverse</a> with the structure as the first
--   argument.
bifor :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | <a>biforM</a> is <a>bimapM</a> with the structure as the first
--   argument.
biforM :: (Bitraversable t, Monad m) => t a b -> (a -> m c) -> (b -> m d) -> m (t c d)

-- | Traverses a structure from left to right, threading a state of type
--   <tt>a</tt> and using the given actions to compute new elements for the
--   structure.
bimapAccumL :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | Traverses a structure from right to left, threading a state of type
--   <tt>a</tt> and using the given actions to compute new elements for the
--   structure.
bimapAccumR :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | A default definition of <a>bimap</a> in terms of the
--   <a>Bitraversable</a> operations.
bimapDefault :: Bitraversable t => (a -> b) -> (c -> d) -> t a c -> t b d

-- | A default definition of <a>bifoldMap</a> in terms of the
--   <a>Bitraversable</a> operations.
bifoldMapDefault :: (Bitraversable t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Bitraversable.Bitraversable Data.Semigroup.Arg
instance Data.Bitraversable.Bitraversable (,)
instance Data.Bitraversable.Bitraversable ((,,) x)
instance Data.Bitraversable.Bitraversable ((,,,) x y)
instance Data.Bitraversable.Bitraversable ((,,,,) x y z)
instance Data.Bitraversable.Bitraversable ((,,,,,) x y z w)
instance Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v)
instance Data.Bitraversable.Bitraversable Data.Either.Either
instance Data.Bitraversable.Bitraversable Control.Applicative.Const
instance Data.Bitraversable.Bitraversable Data.Tagged.Tagged
instance GHC.Base.Functor (Data.Bitraversable.StateL s)
instance GHC.Base.Applicative (Data.Bitraversable.StateL s)
instance GHC.Base.Functor (Data.Bitraversable.StateR s)
instance GHC.Base.Applicative (Data.Bitraversable.StateR s)
instance GHC.Base.Functor Data.Bitraversable.Id
instance GHC.Base.Applicative Data.Bitraversable.Id

module Data.Bifunctor.Sum
data Sum p q a b
L2 :: (p a b) -> Sum p q a b
R2 :: (q a b) -> Sum p q a b
instance GHC.Generics.Constructor Data.Bifunctor.Sum.C1_1Sum
instance GHC.Generics.Constructor Data.Bifunctor.Sum.C1_0Sum
instance GHC.Generics.Datatype Data.Bifunctor.Sum.D1Sum
instance forall (k :: BOX) (p :: k -> * -> *) (q :: k -> * -> *) (a :: k). GHC.Generics.Generic1 (Data.Bifunctor.Sum.Sum p q a)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (q :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Generics.Generic (Data.Bifunctor.Sum.Sum p q a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (q :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Read.Read (p a b), GHC.Read.Read (q a b)) => GHC.Read.Read (Data.Bifunctor.Sum.Sum p q a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (q :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Show.Show (p a b), GHC.Show.Show (q a b)) => GHC.Show.Show (Data.Bifunctor.Sum.Sum p q a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (q :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Classes.Ord (p a b), GHC.Classes.Ord (q a b)) => GHC.Classes.Ord (Data.Bifunctor.Sum.Sum p q a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (q :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Classes.Eq (p a b), GHC.Classes.Eq (q a b)) => GHC.Classes.Eq (Data.Bifunctor.Sum.Sum p q a b)
instance (Data.Bifunctor.Bifunctor p, Data.Bifunctor.Bifunctor q) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Sum.Sum p q)
instance (Data.Bifoldable.Bifoldable p, Data.Bifoldable.Bifoldable q) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Sum.Sum p q)
instance (Data.Bitraversable.Bitraversable p, Data.Bitraversable.Bitraversable q) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Sum.Sum p q)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *). Data.Bifunctor.Functor.BifunctorFunctor (Data.Bifunctor.Sum.Sum p)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *). Data.Bifunctor.Functor.BifunctorMonad (Data.Bifunctor.Sum.Sum p)


module Data.Biapplicative
class Bifunctor p => Biapplicative p where a *>> b = bimap (const id) (const id) <<$>> a <<*>> b a <<* b = bimap const const <<$>> a <<*>> b
bipure :: Biapplicative p => a -> b -> p a b
(<<*>>) :: Biapplicative p => p (a -> b) (c -> d) -> p a c -> p b d

-- | <pre>
--   a <a>*&gt;&gt;</a> b ≡ <a>bimap</a> (<a>const</a> <a>id</a>) (<a>const</a> <a>id</a>) <a>&lt;&lt;$&gt;&gt;</a> a <a>&lt;&lt;*&gt;&gt;</a> b
--   </pre>
(*>>) :: Biapplicative p => p a b -> p c d -> p c d

-- | <pre>
--   a <a>&lt;&lt;*</a> b ≡ <a>bimap</a> <a>const</a> <a>const</a> <a>&lt;&lt;$&gt;&gt;</a> a <a>&lt;&lt;*&gt;&gt;</a> b
--   </pre>
(<<*) :: Biapplicative p => p a b -> p c d -> p a b
(<<$>>) :: (a -> b) -> a -> b
(<<**>>) :: Biapplicative p => p a c -> p (a -> b) (c -> d) -> p b d

-- | Lift binary functions
biliftA2 :: Biapplicative w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f

-- | Lift ternary functions
biliftA3 :: Biapplicative w => (a -> b -> c -> d) -> (e -> f -> g -> h) -> w a e -> w b f -> w c g -> w d h
instance Data.Biapplicative.Biapplicative (,)
instance Data.Biapplicative.Biapplicative Data.Semigroup.Arg
instance GHC.Base.Monoid x => Data.Biapplicative.Biapplicative ((,,) x)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y) => Data.Biapplicative.Biapplicative ((,,,) x y)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y, GHC.Base.Monoid z) => Data.Biapplicative.Biapplicative ((,,,,) x y z)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y, GHC.Base.Monoid z, GHC.Base.Monoid w) => Data.Biapplicative.Biapplicative ((,,,,,) x y z w)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y, GHC.Base.Monoid z, GHC.Base.Monoid w, GHC.Base.Monoid v) => Data.Biapplicative.Biapplicative ((,,,,,,) x y z w v)
instance Data.Biapplicative.Biapplicative Data.Tagged.Tagged
instance Data.Biapplicative.Biapplicative Control.Applicative.Const


module Data.Bifunctor.Biff

-- | Compose two <a>Functor</a>s on the inside of a <a>Bifunctor</a>.
newtype Biff p f g a b
Biff :: p (f a) (g b) -> Biff p f g a b
[runBiff] :: Biff p f g a b -> p (f a) (g b)
instance GHC.Generics.Selector Data.Bifunctor.Biff.S1_0_0Biff
instance GHC.Generics.Constructor Data.Bifunctor.Biff.C1_0Biff
instance GHC.Generics.Datatype Data.Bifunctor.Biff.D1Biff
instance forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (k3 :: BOX) (p :: k -> k1 -> *) (f :: k2 -> k) (g :: k3 -> k1) (a :: k2) (b :: k3). GHC.Generics.Generic (Data.Bifunctor.Biff.Biff p f g a b)
instance forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (k3 :: BOX) (p :: k -> k1 -> *) (f :: k2 -> k) (g :: k3 -> k1) (a :: k2) (b :: k3). GHC.Read.Read (p (f a) (g b)) => GHC.Read.Read (Data.Bifunctor.Biff.Biff p f g a b)
instance forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (k3 :: BOX) (p :: k -> k1 -> *) (f :: k2 -> k) (g :: k3 -> k1) (a :: k2) (b :: k3). GHC.Show.Show (p (f a) (g b)) => GHC.Show.Show (Data.Bifunctor.Biff.Biff p f g a b)
instance forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (k3 :: BOX) (p :: k -> k1 -> *) (f :: k2 -> k) (g :: k3 -> k1) (a :: k2) (b :: k3). GHC.Classes.Ord (p (f a) (g b)) => GHC.Classes.Ord (Data.Bifunctor.Biff.Biff p f g a b)
instance forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (k3 :: BOX) (p :: k -> k1 -> *) (f :: k2 -> k) (g :: k3 -> k1) (a :: k2) (b :: k3). GHC.Classes.Eq (p (f a) (g b)) => GHC.Classes.Eq (Data.Bifunctor.Biff.Biff p f g a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> * -> *) (f :: k1 -> k) (g :: * -> *) (a :: k1). GHC.Base.Functor (p (f a)) => GHC.Generics.Generic1 (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Bifunctor.Bifunctor p, GHC.Base.Functor f, GHC.Base.Functor g) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Biff.Biff p f g)
instance forall (k :: BOX) (p :: * -> * -> *) (f :: k -> *) (g :: * -> *) (a :: k). (Data.Bifunctor.Bifunctor p, GHC.Base.Functor g) => GHC.Base.Functor (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Biapplicative.Biapplicative p, GHC.Base.Applicative f, GHC.Base.Applicative g) => Data.Biapplicative.Biapplicative (Data.Bifunctor.Biff.Biff p f g)
instance forall (k :: BOX) (p :: * -> * -> *) (f :: k -> *) (g :: * -> *) (a :: k). (Data.Bifoldable.Bifoldable p, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Bifoldable.Bifoldable p, Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Biff.Biff p f g)
instance forall (k :: BOX) (p :: * -> * -> *) (f :: k -> *) (g :: * -> *) (a :: k). (Data.Bitraversable.Bitraversable p, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Bitraversable.Bitraversable p, Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Biff.Biff p f g)


-- | From the Functional Pearl "Clowns to the Left of me, Jokers to the
--   Right: Dissecting Data Structures" by Conor McBride.
module Data.Bifunctor.Clown

-- | Make a <a>Functor</a> over the first argument of a <a>Bifunctor</a>.
--   
--   Mnemonic: C<b>l</b>owns to the <b>l</b>eft (parameter of the
--   Bifunctor), joke<b>r</b>s to the <b>r</b>ight.
newtype Clown f a b
Clown :: f a -> Clown f a b
[runClown] :: Clown f a b -> f a
instance GHC.Generics.Selector Data.Bifunctor.Clown.S1_0_0Clown
instance GHC.Generics.Constructor Data.Bifunctor.Clown.C1_0Clown
instance GHC.Generics.Datatype Data.Bifunctor.Clown.D1Clown
instance forall (k :: BOX) (f :: k -> *) (a :: k). GHC.Generics.Generic1 (Data.Bifunctor.Clown.Clown f a)
instance forall (k :: BOX) (k1 :: BOX) (f :: k1 -> *) (a :: k1) (b :: k). GHC.Generics.Generic (Data.Bifunctor.Clown.Clown f a b)
instance forall (k :: BOX) (k1 :: BOX) (f :: k1 -> *) (a :: k1) (b :: k). GHC.Read.Read (f a) => GHC.Read.Read (Data.Bifunctor.Clown.Clown f a b)
instance forall (k :: BOX) (k1 :: BOX) (f :: k1 -> *) (a :: k1) (b :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Bifunctor.Clown.Clown f a b)
instance forall (k :: BOX) (k1 :: BOX) (f :: k1 -> *) (a :: k1) (b :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Bifunctor.Clown.Clown f a b)
instance forall (k :: BOX) (k1 :: BOX) (f :: k1 -> *) (a :: k1) (b :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Bifunctor.Clown.Clown f a b)
instance GHC.Base.Functor f => Data.Bifunctor.Bifunctor (Data.Bifunctor.Clown.Clown f)
instance forall (k :: BOX) (f :: k -> *) (a :: k). GHC.Base.Functor (Data.Bifunctor.Clown.Clown f a)
instance GHC.Base.Applicative f => Data.Biapplicative.Biapplicative (Data.Bifunctor.Clown.Clown f)
instance Data.Foldable.Foldable f => Data.Bifoldable.Bifoldable (Data.Bifunctor.Clown.Clown f)
instance forall (k :: BOX) (f :: k -> *) (a :: k). Data.Foldable.Foldable (Data.Bifunctor.Clown.Clown f a)
instance Data.Traversable.Traversable f => Data.Bitraversable.Bitraversable (Data.Bifunctor.Clown.Clown f)
instance forall (k :: BOX) (f :: k -> *) (a :: k). Data.Traversable.Traversable (Data.Bifunctor.Clown.Clown f a)


module Data.Bifunctor.Fix

-- | Greatest fixpoint of a <a>Bifunctor</a> (a <a>Functor</a> over the
--   first argument with zipping).
newtype Fix p a
In :: p (Fix p a) a -> Fix p a
[out] :: Fix p a -> p (Fix p a) a
instance GHC.Generics.Selector Data.Bifunctor.Fix.S1_0_0Fix
instance GHC.Generics.Constructor Data.Bifunctor.Fix.C1_0Fix
instance GHC.Generics.Datatype Data.Bifunctor.Fix.D1Fix
instance forall (k :: BOX) (p :: * -> k -> *) (a :: k). GHC.Generics.Generic (Data.Bifunctor.Fix.Fix p a)
instance forall (k :: BOX) (p :: * -> k -> *) (a :: k). GHC.Classes.Eq (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Classes.Eq (Data.Bifunctor.Fix.Fix p a)
instance forall (k :: BOX) (p :: * -> k -> *) (a :: k). GHC.Classes.Ord (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Classes.Ord (Data.Bifunctor.Fix.Fix p a)
instance forall (k :: BOX) (p :: * -> k -> *) (a :: k). GHC.Show.Show (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Show.Show (Data.Bifunctor.Fix.Fix p a)
instance forall (k :: BOX) (p :: * -> k -> *) (a :: k). GHC.Read.Read (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Read.Read (Data.Bifunctor.Fix.Fix p a)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Fix.Fix p)
instance Data.Biapplicative.Biapplicative p => GHC.Base.Applicative (Data.Bifunctor.Fix.Fix p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Fix.Fix p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Fix.Fix p)


module Data.Bifunctor.Flip

-- | Make a <a>Bifunctor</a> flipping the arguments of a <a>Bifunctor</a>.
newtype Flip p a b
Flip :: p b a -> Flip p a b
[runFlip] :: Flip p a b -> p b a
instance GHC.Generics.Selector Data.Bifunctor.Flip.S1_0_0Flip
instance GHC.Generics.Constructor Data.Bifunctor.Flip.C1_0Flip
instance GHC.Generics.Datatype Data.Bifunctor.Flip.D1Flip
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (a :: k1) (b :: k). GHC.Generics.Generic (Data.Bifunctor.Flip.Flip p a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (a :: k1) (b :: k). GHC.Read.Read (p b a) => GHC.Read.Read (Data.Bifunctor.Flip.Flip p a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (a :: k1) (b :: k). GHC.Show.Show (p b a) => GHC.Show.Show (Data.Bifunctor.Flip.Flip p a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (a :: k1) (b :: k). GHC.Classes.Ord (p b a) => GHC.Classes.Ord (Data.Bifunctor.Flip.Flip p a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (a :: k1) (b :: k). GHC.Classes.Eq (p b a) => GHC.Classes.Eq (Data.Bifunctor.Flip.Flip p a b)
instance Data.Bifunctor.Bifunctor p => Data.Bifunctor.Bifunctor (Data.Bifunctor.Flip.Flip p)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Flip.Flip p a)
instance Data.Biapplicative.Biapplicative p => Data.Biapplicative.Biapplicative (Data.Bifunctor.Flip.Flip p)
instance Data.Bifoldable.Bifoldable p => Data.Bifoldable.Bifoldable (Data.Bifunctor.Flip.Flip p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Flip.Flip p a)
instance Data.Bitraversable.Bitraversable p => Data.Bitraversable.Bitraversable (Data.Bifunctor.Flip.Flip p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Flip.Flip p a)
instance Data.Bifunctor.Functor.BifunctorFunctor Data.Bifunctor.Flip.Flip


module Data.Bifunctor.Join

-- | Make a <a>Functor</a> over both arguments of a <a>Bifunctor</a>.
newtype Join p a
Join :: p a a -> Join p a
[runJoin] :: Join p a -> p a a
instance GHC.Generics.Selector Data.Bifunctor.Join.S1_0_0Join
instance GHC.Generics.Constructor Data.Bifunctor.Join.C1_0Join
instance GHC.Generics.Datatype Data.Bifunctor.Join.D1Join
instance forall (k :: BOX) (p :: k -> k -> *) (a :: k). GHC.Generics.Generic (Data.Bifunctor.Join.Join p a)
instance forall (k :: BOX) (p :: k -> k -> *) (a :: k). GHC.Classes.Eq (p a a) => GHC.Classes.Eq (Data.Bifunctor.Join.Join p a)
instance forall (k :: BOX) (p :: k -> k -> *) (a :: k). GHC.Classes.Ord (p a a) => GHC.Classes.Ord (Data.Bifunctor.Join.Join p a)
instance forall (k :: BOX) (p :: k -> k -> *) (a :: k). GHC.Show.Show (p a a) => GHC.Show.Show (Data.Bifunctor.Join.Join p a)
instance forall (k :: BOX) (p :: k -> k -> *) (a :: k). GHC.Read.Read (p a a) => GHC.Read.Read (Data.Bifunctor.Join.Join p a)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Join.Join p)
instance Data.Biapplicative.Biapplicative p => GHC.Base.Applicative (Data.Bifunctor.Join.Join p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Join.Join p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Join.Join p)


-- | From the Functional Pearl "Clowns to the Left of me, Jokers to the
--   Right: Dissecting Data Structures" by Conor McBride.
module Data.Bifunctor.Joker

-- | Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.
--   
--   Mnemonic: C<b>l</b>owns to the <b>l</b>eft (parameter of the
--   Bifunctor), joke<b>r</b>s to the <b>r</b>ight.
newtype Joker g a b
Joker :: g b -> Joker g a b
[runJoker] :: Joker g a b -> g b
instance GHC.Generics.Selector Data.Bifunctor.Joker.S1_0_0Joker
instance GHC.Generics.Constructor Data.Bifunctor.Joker.C1_0Joker
instance GHC.Generics.Datatype Data.Bifunctor.Joker.D1Joker
instance forall (k :: BOX) (g :: * -> *) (a :: k). GHC.Generics.Generic1 (Data.Bifunctor.Joker.Joker g a)
instance forall (k :: BOX) (k1 :: BOX) (g :: k1 -> *) (a :: k) (b :: k1). GHC.Generics.Generic (Data.Bifunctor.Joker.Joker g a b)
instance forall (k :: BOX) (k1 :: BOX) (g :: k1 -> *) (a :: k) (b :: k1). GHC.Read.Read (g b) => GHC.Read.Read (Data.Bifunctor.Joker.Joker g a b)
instance forall (k :: BOX) (k1 :: BOX) (g :: k1 -> *) (a :: k) (b :: k1). GHC.Show.Show (g b) => GHC.Show.Show (Data.Bifunctor.Joker.Joker g a b)
instance forall (k :: BOX) (k1 :: BOX) (g :: k1 -> *) (a :: k) (b :: k1). GHC.Classes.Ord (g b) => GHC.Classes.Ord (Data.Bifunctor.Joker.Joker g a b)
instance forall (k :: BOX) (k1 :: BOX) (g :: k1 -> *) (a :: k) (b :: k1). GHC.Classes.Eq (g b) => GHC.Classes.Eq (Data.Bifunctor.Joker.Joker g a b)
instance GHC.Base.Functor g => Data.Bifunctor.Bifunctor (Data.Bifunctor.Joker.Joker g)
instance forall (k :: BOX) (g :: * -> *) (a :: k). GHC.Base.Functor g => GHC.Base.Functor (Data.Bifunctor.Joker.Joker g a)
instance GHC.Base.Applicative g => Data.Biapplicative.Biapplicative (Data.Bifunctor.Joker.Joker g)
instance Data.Foldable.Foldable g => Data.Bifoldable.Bifoldable (Data.Bifunctor.Joker.Joker g)
instance forall (k :: BOX) (g :: * -> *) (a :: k). Data.Foldable.Foldable g => Data.Foldable.Foldable (Data.Bifunctor.Joker.Joker g a)
instance Data.Traversable.Traversable g => Data.Bitraversable.Bitraversable (Data.Bifunctor.Joker.Joker g)
instance forall (k :: BOX) (g :: * -> *) (a :: k). Data.Traversable.Traversable g => Data.Traversable.Traversable (Data.Bifunctor.Joker.Joker g a)


-- | The product of two bifunctors.
module Data.Bifunctor.Product

-- | Form the product of two bifunctors
data Product f g a b
Pair :: (f a b) -> (g a b) -> Product f g a b
instance GHC.Generics.Constructor Data.Bifunctor.Product.C1_0Product
instance GHC.Generics.Datatype Data.Bifunctor.Product.D1Product
instance forall (k :: BOX) (f :: k -> * -> *) (g :: k -> * -> *) (a :: k). GHC.Generics.Generic1 (Data.Bifunctor.Product.Product f g a)
instance forall (k :: BOX) (k1 :: BOX) (f :: k -> k1 -> *) (g :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Generics.Generic (Data.Bifunctor.Product.Product f g a b)
instance forall (k :: BOX) (k1 :: BOX) (f :: k -> k1 -> *) (g :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Read.Read (f a b), GHC.Read.Read (g a b)) => GHC.Read.Read (Data.Bifunctor.Product.Product f g a b)
instance forall (k :: BOX) (k1 :: BOX) (f :: k -> k1 -> *) (g :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Show.Show (f a b), GHC.Show.Show (g a b)) => GHC.Show.Show (Data.Bifunctor.Product.Product f g a b)
instance forall (k :: BOX) (k1 :: BOX) (f :: k -> k1 -> *) (g :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Classes.Ord (f a b), GHC.Classes.Ord (g a b)) => GHC.Classes.Ord (Data.Bifunctor.Product.Product f g a b)
instance forall (k :: BOX) (k1 :: BOX) (f :: k -> k1 -> *) (g :: k -> k1 -> *) (a :: k) (b :: k1). (GHC.Classes.Eq (f a b), GHC.Classes.Eq (g a b)) => GHC.Classes.Eq (Data.Bifunctor.Product.Product f g a b)
instance (Data.Bifunctor.Bifunctor f, Data.Bifunctor.Bifunctor g) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Product.Product f g)
instance (Data.Biapplicative.Biapplicative f, Data.Biapplicative.Biapplicative g) => Data.Biapplicative.Biapplicative (Data.Bifunctor.Product.Product f g)
instance (Data.Bifoldable.Bifoldable f, Data.Bifoldable.Bifoldable g) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Product.Product f g)
instance (Data.Bitraversable.Bitraversable f, Data.Bitraversable.Bitraversable g) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Product.Product f g)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *). Data.Bifunctor.Functor.BifunctorFunctor (Data.Bifunctor.Product.Product p)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *). Data.Bifunctor.Functor.BifunctorComonad (Data.Bifunctor.Product.Product p)


module Data.Bifunctor.Tannen

-- | Compose a <a>Functor</a> on the outside of a <a>Bifunctor</a>.
newtype Tannen f p a b
Tannen :: f (p a b) -> Tannen f p a b
[runTannen] :: Tannen f p a b -> f (p a b)
instance GHC.Generics.Selector Data.Bifunctor.Tannen.S1_0_0Tannen
instance GHC.Generics.Constructor Data.Bifunctor.Tannen.C1_0Tannen
instance GHC.Generics.Datatype Data.Bifunctor.Tannen.D1Tannen
instance forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (f :: k -> *) (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). GHC.Generics.Generic (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (f :: k -> *) (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). GHC.Read.Read (f (p a b)) => GHC.Read.Read (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (f :: k -> *) (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). GHC.Show.Show (f (p a b)) => GHC.Show.Show (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (f :: k -> *) (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). GHC.Classes.Ord (f (p a b)) => GHC.Classes.Ord (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (f :: k -> *) (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). GHC.Classes.Eq (f (p a b)) => GHC.Classes.Eq (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall (k :: BOX) (f :: * -> *) (p :: k -> * -> *) (a :: k). GHC.Base.Functor f => GHC.Generics.Generic1 (Data.Bifunctor.Tannen.Tannen f p a)
instance GHC.Base.Functor f => Data.Bifunctor.Functor.BifunctorFunctor (Data.Bifunctor.Tannen.Tannen f)
instance (GHC.Base.Functor f, GHC.Base.Monad f) => Data.Bifunctor.Functor.BifunctorMonad (Data.Bifunctor.Tannen.Tannen f)
instance Control.Comonad.Comonad f => Data.Bifunctor.Functor.BifunctorComonad (Data.Bifunctor.Tannen.Tannen f)
instance (GHC.Base.Functor f, Data.Bifunctor.Bifunctor p) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Functor f, Data.Bifunctor.Bifunctor p) => GHC.Base.Functor (Data.Bifunctor.Tannen.Tannen f p a)
instance (GHC.Base.Applicative f, Data.Biapplicative.Biapplicative p) => Data.Biapplicative.Biapplicative (Data.Bifunctor.Tannen.Tannen f p)
instance (Data.Foldable.Foldable f, Data.Bifoldable.Bifoldable p) => Data.Foldable.Foldable (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Foldable.Foldable f, Data.Bifoldable.Bifoldable p) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Tannen.Tannen f p)
instance (Data.Traversable.Traversable f, Data.Bitraversable.Bitraversable p) => Data.Traversable.Traversable (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Traversable.Traversable f, Data.Bitraversable.Bitraversable p) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Tannen.Tannen f p)
instance forall (k :: BOX) (f :: * -> *) (p :: k -> k -> *). (GHC.Base.Applicative f, Control.Category.Category p) => Control.Category.Category (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.Arrow p) => Control.Arrow.Arrow (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowChoice p) => Control.Arrow.ArrowChoice (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowLoop p) => Control.Arrow.ArrowLoop (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowZero p) => Control.Arrow.ArrowZero (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowPlus p) => Control.Arrow.ArrowPlus (Data.Bifunctor.Tannen.Tannen f p)


module Data.Bifunctor.Wrapped

-- | Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.
newtype WrappedBifunctor p a b
WrapBifunctor :: p a b -> WrappedBifunctor p a b
[unwrapBifunctor] :: WrappedBifunctor p a b -> p a b
instance GHC.Generics.Selector Data.Bifunctor.Wrapped.S1_0_0WrappedBifunctor
instance GHC.Generics.Constructor Data.Bifunctor.Wrapped.C1_0WrappedBifunctor
instance GHC.Generics.Datatype Data.Bifunctor.Wrapped.D1WrappedBifunctor
instance forall (k :: BOX) (p :: k -> * -> *) (a :: k). GHC.Generics.Generic1 (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Generics.Generic (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Read.Read (p a b) => GHC.Read.Read (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Show.Show (p a b) => GHC.Show.Show (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Classes.Ord (p a b) => GHC.Classes.Ord (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall (k :: BOX) (k1 :: BOX) (p :: k -> k1 -> *) (a :: k) (b :: k1). GHC.Classes.Eq (p a b) => GHC.Classes.Eq (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance Data.Bifunctor.Bifunctor p => Data.Bifunctor.Bifunctor (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Biapplicative.Biapplicative p => Data.Biapplicative.Biapplicative (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Bifoldable.Bifoldable p => Data.Bifoldable.Bifoldable (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Bitraversable.Bitraversable p => Data.Bitraversable.Bitraversable (Data.Bifunctor.Wrapped.WrappedBifunctor p)

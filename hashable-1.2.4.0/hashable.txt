-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A class for types that can be converted to a hash value
--   
--   This package defines a class, <a>Hashable</a>, for types that can be
--   converted to a hash value. This class exists for the benefit of
--   hashing-based data structures. The package provides instances for
--   basic types and a way to combine hash values.
@package hashable
@version 1.2.4.0


-- | This module defines a class, <a>Hashable</a>, for types that can be
--   converted to a hash value. This class exists for the benefit of
--   hashing-based data structures. The module provides instances for most
--   standard types. Efficient instances for other types can be generated
--   automatically and effortlessly using the generics support in GHC 7.2
--   and above.
--   
--   The easiest way to get started is to use the <a>hash</a> function.
--   Here is an example session with <tt>ghci</tt>.
--   
--   <pre>
--   ghci&gt; import Data.Hashable
--   ghci&gt; hash "foo"
--   60853164
--   </pre>
module Data.Hashable

-- | The class of types that can be converted to a hash value.
--   
--   Minimal implementation: <a>hashWithSalt</a>.
class Hashable a where hash = hashWithSalt defaultSalt hashWithSalt salt = ghashWithSalt salt . from

-- | Return a hash value for the argument, using the given salt.
--   
--   The general contract of <a>hashWithSalt</a> is:
--   
--   <ul>
--   <li>If two values are equal according to the <a>==</a> method, then
--   applying the <a>hashWithSalt</a> method on each of the two values
--   <i>must</i> produce the same integer result if the same salt is used
--   in each case.</li>
--   <li>It is <i>not</i> required that if two values are unequal according
--   to the <a>==</a> method, then applying the <a>hashWithSalt</a> method
--   on each of the two values must produce distinct integer results.
--   However, the programmer should be aware that producing distinct
--   integer results for unequal values may improve the performance of
--   hashing-based data structures.</li>
--   <li>This method can be used to compute different hash values for the
--   same input by providing a different salt in each application of the
--   method. This implies that any instance that defines
--   <a>hashWithSalt</a> <i>must</i> make use of the salt in its
--   implementation.</li>
--   </ul>
hashWithSalt :: Hashable a => Int -> a -> Int

-- | Like <a>hashWithSalt</a>, but no salt is used. The default
--   implementation uses <a>hashWithSalt</a> with some default salt.
--   Instances might want to implement this method to provide a more
--   efficient implementation than the default implementation.
hash :: Hashable a => a -> Int

-- | Transform a value into a <a>Hashable</a> value, then hash the
--   transformed value using the given salt.
--   
--   This is a useful shorthand in cases where a type can easily be mapped
--   to another type that is already an instance of <a>Hashable</a>.
--   Example:
--   
--   <pre>
--   data Foo = Foo | Bar
--            deriving (Enum)
--   
--   instance Hashable Foo where
--       hashWithSalt = hashUsing fromEnum
--   </pre>
hashUsing :: (Hashable b) => (a -> b) -> Int -> a -> Int

-- | Compute a hash value for the content of this pointer.
hashPtr :: Ptr a -> Int -> IO Int

-- | Compute a hash value for the content of this pointer, using an initial
--   salt.
--   
--   This function can for example be used to hash non-contiguous segments
--   of memory as if they were one contiguous segment, by using the output
--   of one hash as the salt for the next.
hashPtrWithSalt :: Ptr a -> Int -> Int -> IO Int

-- | Compute a hash value for the content of this <a>ByteArray#</a>,
--   beginning at the specified offset, using specified number of bytes.
hashByteArray :: ByteArray# -> Int -> Int -> Int

-- | Compute a hash value for the content of this <a>ByteArray#</a>, using
--   an initial salt.
--   
--   This function can for example be used to hash non-contiguous segments
--   of memory as if they were one contiguous segment, by using the output
--   of one hash as the salt for the next.
hashByteArrayWithSalt :: ByteArray# -> Int -> Int -> Int -> Int

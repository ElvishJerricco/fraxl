-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GHC primitives
--   
--   GHC primitives.
@package ghc-prim
@version 0.4.0.0


-- | The tuple data types
module GHC.Tuple

-- | The unit datatype <tt>()</tt> has one non-undefined member, the
--   nullary constructor <tt>()</tt>.
data ()
() :: ()
data (,) a b
(,) :: a -> b -> (,) a b
data (,,) a b c
(,,) :: a -> b -> c -> (,,) a b c
data (,,,) a b c d
(,,,) :: a -> b -> c -> d -> (,,,) a b c d
data (,,,,) a b c d e
(,,,,) :: a -> b -> c -> d -> e -> (,,,,) a b c d e
data (,,,,,) a b c d e f
(,,,,,) :: a -> b -> c -> d -> e -> f -> (,,,,,) a b c d e f
data (,,,,,,) a b c d e f g
(,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> (,,,,,,) a b c d e f g
data (,,,,,,,) a b c d e f g h
(,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> (,,,,,,,) a b c d e f g h
data (,,,,,,,,) a b c d e f g h i
(,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> (,,,,,,,,) a b c d e f g h i
data (,,,,,,,,,) a b c d e f g h i j
(,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (,,,,,,,,,) a b c d e f g h i j
data (,,,,,,,,,,) a b c d e f g h i j k
(,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (,,,,,,,,,,) a b c d e f g h i j k
data (,,,,,,,,,,,) a b c d e f g h i j k l
(,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (,,,,,,,,,,,) a b c d e f g h i j k l
data (,,,,,,,,,,,,) a b c d e f g h i j k l m
(,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (,,,,,,,,,,,,) a b c d e f g h i j k l m
data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
(,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
(,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
data (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
(,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
data (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
(,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
data (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
(,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
data (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
(,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
data (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
(,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
data (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
(,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
data (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
(,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
data (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
(,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
data (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
(,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
data (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
(,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
data (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
(,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
data (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_
(,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> f__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> f__ -> g__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> f__ -> g__ -> h__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> f__ -> g__ -> h__ -> i__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> f__ -> g__ -> h__ -> i__ -> j__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__

module GHC.PrimopWrappers
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
(+#) :: Int# -> Int# -> Int#
(-#) :: Int# -> Int# -> Int#
(*#) :: Int# -> Int# -> Int#
mulIntMayOflo# :: Int# -> Int# -> Int#
quotInt# :: Int# -> Int# -> Int#
remInt# :: Int# -> Int# -> Int#
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
andI# :: Int# -> Int# -> Int#
orI# :: Int# -> Int# -> Int#
xorI# :: Int# -> Int# -> Int#
notI# :: Int# -> Int#
negateInt# :: Int# -> Int#
addIntC# :: Int# -> Int# -> (# Int#, Int# #)
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
(>=#) :: Int# -> Int# -> Int#
(==#) :: Int# -> Int# -> Int#
(/=#) :: Int# -> Int# -> Int#
(<#) :: Int# -> Int# -> Int#
(<=#) :: Int# -> Int# -> Int#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
word2Float# :: Word# -> Float#
word2Double# :: Word# -> Double#
uncheckedIShiftL# :: Int# -> Int# -> Int#
uncheckedIShiftRA# :: Int# -> Int# -> Int#
uncheckedIShiftRL# :: Int# -> Int# -> Int#
plusWord# :: Word# -> Word# -> Word#
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#
uncheckedShiftL# :: Word# -> Int# -> Word#
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#
popCnt8# :: Word# -> Word#
popCnt16# :: Word# -> Word#
popCnt32# :: Word# -> Word#
popCnt64# :: Word# -> Word#
popCnt# :: Word# -> Word#
clz8# :: Word# -> Word#
clz16# :: Word# -> Word#
clz32# :: Word# -> Word#
clz64# :: Word# -> Word#
clz# :: Word# -> Word#
ctz8# :: Word# -> Word#
ctz16# :: Word# -> Word#
ctz32# :: Word# -> Word#
ctz64# :: Word# -> Word#
ctz# :: Word# -> Word#
byteSwap16# :: Word# -> Word#
byteSwap32# :: Word# -> Word#
byteSwap64# :: Word# -> Word#
byteSwap# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
(>##) :: Double# -> Double# -> Int#
(>=##) :: Double# -> Double# -> Int#
(==##) :: Double# -> Double# -> Int#
(/=##) :: Double# -> Double# -> Int#
(<##) :: Double# -> Double# -> Int#
(<=##) :: Double# -> Double# -> Int#
(+##) :: Double# -> Double# -> Double#
(-##) :: Double# -> Double# -> Double#
(*##) :: Double# -> Double# -> Double#
(/##) :: Double# -> Double# -> Double#
negateDouble# :: Double# -> Double#
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
logDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
(**##) :: Double# -> Double# -> Double#
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
decodeDouble_Int64# :: Double# -> (# Int#, Int# #)
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
logFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
newArray# :: Int# -> a -> State# s -> (# State# s, MutableArray# s a #)
sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#
readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s, a #)
writeArray# :: MutableArray# s a -> Int# -> a -> State# s -> State# s
sizeofArray# :: Array# a -> Int#
sizeofMutableArray# :: MutableArray# s a -> Int#
indexArray# :: Array# a -> Int# -> (# a #)
unsafeFreezeArray# :: MutableArray# s a -> State# s -> (# State# s, Array# a #)
unsafeThawArray# :: Array# a -> State# s -> (# State# s, MutableArray# s a #)
copyArray# :: Array# a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
copyMutableArray# :: MutableArray# s a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
cloneArray# :: Array# a -> Int# -> Int# -> Array# a
cloneMutableArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)
freezeArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, Array# a #)
thawArray# :: Array# a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)
casArray# :: MutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
newSmallArray# :: Int# -> a -> State# s -> (# State# s, SmallMutableArray# s a #)
sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#
readSmallArray# :: SmallMutableArray# s a -> Int# -> State# s -> (# State# s, a #)
writeSmallArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> State# s
sizeofSmallArray# :: SmallArray# a -> Int#
sizeofSmallMutableArray# :: SmallMutableArray# s a -> Int#
indexSmallArray# :: SmallArray# a -> Int# -> (# a #)
unsafeFreezeSmallArray# :: SmallMutableArray# s a -> State# s -> (# State# s, SmallArray# a #)
unsafeThawSmallArray# :: SmallArray# a -> State# s -> (# State# s, SmallMutableArray# s a #)
copySmallArray# :: SmallArray# a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s
copySmallMutableArray# :: SmallMutableArray# s a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s
cloneSmallArray# :: SmallArray# a -> Int# -> Int# -> SmallArray# a
cloneSmallMutableArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)
freezeSmallArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallArray# a #)
thawSmallArray# :: SmallArray# a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)
casSmallArray# :: SmallMutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
byteArrayContents# :: ByteArray# -> Addr#
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#
shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s
resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)
sizeofByteArray# :: ByteArray# -> Int#
sizeofMutableByteArray# :: MutableByteArray# s -> Int#
indexCharArray# :: ByteArray# -> Int# -> Char#
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
indexInt8Array# :: ByteArray# -> Int# -> Int#
indexInt16Array# :: ByteArray# -> Int# -> Int#
indexInt32Array# :: ByteArray# -> Int# -> Int#
indexInt64Array# :: ByteArray# -> Int# -> Int#
indexWord8Array# :: ByteArray# -> Int# -> Word#
indexWord16Array# :: ByteArray# -> Int# -> Word#
indexWord32Array# :: ByteArray# -> Int# -> Word#
indexWord64Array# :: ByteArray# -> Int# -> Word#
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt16Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt32Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt64Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord16Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord32Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord64Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s
copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s
copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s
atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)
sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#
unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)
sizeofArrayArray# :: ArrayArray# -> Int#
sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s
copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
plusAddr# :: Addr# -> Int# -> Addr#
minusAddr# :: Addr# -> Addr# -> Int#
remAddr# :: Addr# -> Int# -> Int#
addr2Int# :: Addr# -> Int#
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#
indexCharOffAddr# :: Addr# -> Int# -> Char#
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int#
indexInt16OffAddr# :: Addr# -> Int# -> Int#
indexInt32OffAddr# :: Addr# -> Int# -> Int#
indexInt64OffAddr# :: Addr# -> Int# -> Int#
indexWord8OffAddr# :: Addr# -> Int# -> Word#
indexWord16OffAddr# :: Addr# -> Int# -> Word#
indexWord32OffAddr# :: Addr# -> Int# -> Word#
indexWord64OffAddr# :: Addr# -> Int# -> Word#
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt16OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt32OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt64OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWord8OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord16OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord32OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord64OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
newMutVar# :: a -> State# s -> (# State# s, MutVar# s a #)
readMutVar# :: MutVar# s a -> State# s -> (# State# s, a #)
writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#
atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)
casMutVar# :: MutVar# s a -> a -> a -> State# s -> (# State# s, Int#, a #)
catch# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
raise# :: a -> b
raiseIO# :: a -> State# (RealWorld) -> (# State# (RealWorld), b #)
maskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
maskUninterruptible# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
unmaskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
getMaskingState# :: State# (RealWorld) -> (# State# (RealWorld), Int# #)
atomically# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
retry# :: State# (RealWorld) -> (# State# (RealWorld), a #)
catchRetry# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
catchSTM# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
check# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), () #)
newTVar# :: a -> State# s -> (# State# s, TVar# s a #)
readTVar# :: TVar# s a -> State# s -> (# State# s, a #)
readTVarIO# :: TVar# s a -> State# s -> (# State# s, a #)
writeTVar# :: TVar# s a -> a -> State# s -> State# s
sameTVar# :: TVar# s a -> TVar# s a -> Int#
newMVar# :: State# s -> (# State# s, MVar# s a #)
takeMVar# :: MVar# s a -> State# s -> (# State# s, a #)
tryTakeMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)
putMVar# :: MVar# s a -> a -> State# s -> State# s
tryPutMVar# :: MVar# s a -> a -> State# s -> (# State# s, Int# #)
readMVar# :: MVar# s a -> State# s -> (# State# s, a #)
tryReadMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)
sameMVar# :: MVar# s a -> MVar# s a -> Int#
isEmptyMVar# :: MVar# s a -> State# s -> (# State# s, Int# #)
delay# :: Int# -> State# s -> State# s
waitRead# :: Int# -> State# s -> State# s
waitWrite# :: Int# -> State# s -> State# s
fork# :: a -> State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
forkOn# :: Int# -> a -> State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
killThread# :: ThreadId# -> a -> State# (RealWorld) -> State# (RealWorld)
yield# :: State# (RealWorld) -> State# (RealWorld)
myThreadId# :: State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
labelThread# :: ThreadId# -> Addr# -> State# (RealWorld) -> State# (RealWorld)
isCurrentThreadBound# :: State# (RealWorld) -> (# State# (RealWorld), Int# #)
noDuplicate# :: State# (RealWorld) -> State# (RealWorld)
threadStatus# :: ThreadId# -> State# (RealWorld) -> (# State# (RealWorld), Int#, Int#, Int# #)
mkWeak# :: o -> b -> c -> State# (RealWorld) -> (# State# (RealWorld), Weak# b #)
mkWeakNoFinalizer# :: o -> b -> State# (RealWorld) -> (# State# (RealWorld), Weak# b #)
addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# (RealWorld) -> (# State# (RealWorld), Int# #)
deRefWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld), Int#, a #)
finalizeWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld), Int#, State# (RealWorld) -> (# State# (RealWorld), () #) #)
touch# :: o -> State# (RealWorld) -> State# (RealWorld)
makeStablePtr# :: a -> State# (RealWorld) -> (# State# (RealWorld), StablePtr# a #)
deRefStablePtr# :: StablePtr# a -> State# (RealWorld) -> (# State# (RealWorld), a #)
eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: a -> State# (RealWorld) -> (# State# (RealWorld), StableName# a #)
eqStableName# :: StableName# a -> StableName# b -> Int#
stableNameToInt# :: StableName# a -> Int#
reallyUnsafePtrEquality# :: a -> a -> Int#
spark# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)
numSparks# :: State# s -> (# State# s, Int# #)
dataToTag# :: a -> Int#
addrToAny# :: Addr# -> (# a #)
mkApUpd0# :: BCO# -> (# a #)
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO# #)
unpackClosure# :: a -> (# Addr#, Array# b, ByteArray# #)
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)
traceEvent# :: Addr# -> State# s -> State# s
traceMarker# :: Addr# -> State# s -> State# s
prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
prefetchValue3# :: a -> State# s -> State# s
prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
prefetchValue2# :: a -> State# s -> State# s
prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
prefetchValue1# :: a -> State# s -> State# s
prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
prefetchValue0# :: a -> State# s -> State# s


-- | GHC magic.
--   
--   Use GHC.Exts from the base package instead of importing this module
--   directly.
module GHC.Magic

-- | The call <tt>inline f</tt> arranges that <tt>f</tt> is inlined,
--   regardless of its size. More precisely, the call <tt>inline f</tt>
--   rewrites to the right-hand side of <tt>f</tt>'s definition. This
--   allows the programmer to control inlining from a particular call site
--   rather than the definition site of the function (c.f. <tt>INLINE</tt>
--   pragmas).
--   
--   This inlining occurs regardless of the argument to the call or the
--   size of <tt>f</tt>'s definition; it is unconditional. The main caveat
--   is that <tt>f</tt>'s definition must be visible to the compiler; it is
--   therefore recommended to mark the function with an <tt>INLINABLE</tt>
--   pragma at its definition so that GHC guarantees to record its
--   unfolding regardless of size.
--   
--   If no inlining takes place, the <a>inline</a> function expands to the
--   identity function in Phase zero, so its use imposes no overhead.
inline :: a -> a

-- | The <a>lazy</a> function restrains strictness analysis a little. The
--   call <tt>lazy e</tt> means the same as <tt>e</tt>, but <a>lazy</a> has
--   a magical property so far as strictness analysis is concerned: it is
--   lazy in its first argument, even though its semantics is strict. After
--   strictness analysis has run, calls to <a>lazy</a> are inlined to be
--   the identity function.
--   
--   This behaviour is occasionally useful when controlling evaluation
--   order. Notably, <a>lazy</a> is used in the library definition of
--   <a>par</a>:
--   
--   <pre>
--   par :: a -&gt; b -&gt; b
--   par x y = case (par# x) of _ -&gt; lazy y
--   </pre>
--   
--   If <a>lazy</a> were not lazy, <tt>par</tt> would look strict in
--   <tt>y</tt> which would defeat the whole purpose of <tt>par</tt>.
--   
--   Like <tt>seq</tt>, the argument of <a>lazy</a> can have an unboxed
--   type.
lazy :: a -> a

-- | The <a>oneShot</a> function can be used to give a hint to the compiler
--   that its argument will be called at most once, which may (or may not)
--   enable certain optimizations. It can be useful to improve the
--   performance of code in continuation passing style.
oneShot :: (a -> b) -> (a -> b)


-- | GHC type definitions. Use GHC.Exts from the base package instead of
--   importing this module directly.
module GHC.Types
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char
C# :: Char# -> Char

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int
I# :: Int# -> Int

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word
W# :: Word# -> Word

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float
F# :: Float# -> Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double
D# :: Double# -> Double
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
newtype IO a
IO :: (State# RealWorld -> (# State# RealWorld, a #)) -> IO a

-- | Alias for <a>tagToEnum#</a>. Returns True if its parameter is 1# and
--   False if it is 0#.
isTrue# :: Int# -> Bool

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized.
data SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | This two-parameter class has instances for types <tt>a</tt> and
--   <tt>b</tt> if the compiler can infer that they have the same
--   representation. This class does not have regular instances; instead
--   they are created on-the-fly during type-checking. Trying to manually
--   declare an instance of <tt>Coercible</tt> is an error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
data Coercible a b


-- | GHC's primitive types and operations. Use GHC.Exts from the base
--   package instead of importing this module directly.
module GHC.Prim
data Char#
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
data Int#
(+#) :: Int# -> Int# -> Int#
(-#) :: Int# -> Int# -> Int#

-- | Low word of signed integer multiply.
(*#) :: Int# -> Int# -> Int#

-- | Return non-zero if there is any possibility that the upper word of a
--   signed integer multiply might contain useful information. Return zero
--   only if you are completely sure that no overflow can occur. On a
--   32-bit platform, the recommmended implementation is to do a 32 x 32
--   -&gt; 64 signed multiply, and subtract result[63:32] from (result[31]
--   &gt;&gt;signed 31). If this is zero, meaning that the upper word is
--   merely a sign extension of the lower one, no overflow can occur.
--   
--   On a 64-bit platform it is not always possible to acquire the top 64
--   bits of the result. Therefore, a recommended implementation is to take
--   the absolute value of both operands, and return 0 iff bits[63:31] of
--   them are zero, since that means that their magnitudes fit within 31
--   bits, so the magnitude of the product must fit into 62 bits.
--   
--   If in doubt, return non-zero, but do make an effort to create the
--   correct answer for small args, since otherwise the performance of
--   <tt>(*) :: Integer -&gt; Integer -&gt; Integer</tt> will be poor.
mulIntMayOflo# :: Int# -> Int# -> Int#

-- | Rounds towards zero.
quotInt# :: Int# -> Int# -> Int#

-- | Satisfies <tt>(quotInt# x y) *# y +# (remInt# x y) == x</tt>.
remInt# :: Int# -> Int# -> Int#

-- | Rounds towards zero.
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
andI# :: Int# -> Int# -> Int#
orI# :: Int# -> Int# -> Int#
xorI# :: Int# -> Int# -> Int#
notI# :: Int# -> Int#
negateInt# :: Int# -> Int#

-- | Add signed integers reporting overflow. First member of result is the
--   sum truncated to an <tt>Int#</tt>; second member is zero if the true
--   sum fits in an <tt>Int#</tt>, nonzero if overflow occurred (the sum is
--   either too large or too small to fit in an <tt>Int#</tt>).
addIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Subtract signed integers reporting overflow. First member of result is
--   the difference truncated to an <tt>Int#</tt>; second member is zero if
--   the true difference fits in an <tt>Int#</tt>, nonzero if overflow
--   occurred (the difference is either too large or too small to fit in an
--   <tt>Int#</tt>).
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
(>=#) :: Int# -> Int# -> Int#
(==#) :: Int# -> Int# -> Int#
(/=#) :: Int# -> Int# -> Int#
(<#) :: Int# -> Int# -> Int#
(<=#) :: Int# -> Int# -> Int#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
word2Float# :: Word# -> Float#
word2Double# :: Word# -> Double#

-- | Shift left. Result undefined if shift amount is not in the range 0 to
--   word size - 1 inclusive.
uncheckedIShiftL# :: Int# -> Int# -> Int#

-- | Shift right arithmetic. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRA# :: Int# -> Int# -> Int#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRL# :: Int# -> Int# -> Int#
data Word#
plusWord# :: Word# -> Word# -> Word#
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#

-- | Shift left logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftL# :: Word# -> Int# -> Word#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#

-- | Count the number of set bits in the lower 8 bits of a word.
popCnt8# :: Word# -> Word#

-- | Count the number of set bits in the lower 16 bits of a word.
popCnt16# :: Word# -> Word#

-- | Count the number of set bits in the lower 32 bits of a word.
popCnt32# :: Word# -> Word#

-- | Count the number of set bits in a 64-bit word.
popCnt64# :: Word# -> Word#

-- | Count the number of set bits in a word.
popCnt# :: Word# -> Word#

-- | Count leading zeros in the lower 8 bits of a word.
clz8# :: Word# -> Word#

-- | Count leading zeros in the lower 16 bits of a word.
clz16# :: Word# -> Word#

-- | Count leading zeros in the lower 32 bits of a word.
clz32# :: Word# -> Word#

-- | Count leading zeros in a 64-bit word.
clz64# :: Word# -> Word#

-- | Count leading zeros in a word.
clz# :: Word# -> Word#

-- | Count trailing zeros in the lower 8 bits of a word.
ctz8# :: Word# -> Word#

-- | Count trailing zeros in the lower 16 bits of a word.
ctz16# :: Word# -> Word#

-- | Count trailing zeros in the lower 32 bits of a word.
ctz32# :: Word# -> Word#

-- | Count trailing zeros in a 64-bit word.
ctz64# :: Word# -> Word#

-- | Count trailing zeros in a word.
ctz# :: Word# -> Word#

-- | Swap bytes in the lower 16 bits of a word. The higher bytes are
--   undefined.
byteSwap16# :: Word# -> Word#

-- | Swap bytes in the lower 32 bits of a word. The higher bytes are
--   undefined.
byteSwap32# :: Word# -> Word#

-- | Swap bytes in a 64 bits of a word.
byteSwap64# :: Word# -> Word#

-- | Swap bytes in a word.
byteSwap# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
data Double#
(>##) :: Double# -> Double# -> Int#
(>=##) :: Double# -> Double# -> Int#
(==##) :: Double# -> Double# -> Int#
(/=##) :: Double# -> Double# -> Int#
(<##) :: Double# -> Double# -> Int#
(<=##) :: Double# -> Double# -> Int#
(+##) :: Double# -> Double# -> Double#
(-##) :: Double# -> Double# -> Double#
(*##) :: Double# -> Double# -> Double#
(/##) :: Double# -> Double# -> Double#
negateDouble# :: Double# -> Double#

-- | Truncates a <tt>Double#</tt> value to the nearest <tt>Int#</tt>.
--   Results are undefined if the truncation if truncation yields a value
--   outside the range of <tt>Int#</tt>.
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
logDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#

-- | Exponentiation.
(**##) :: Double# -> Double# -> Double#

-- | Convert to integer. First component of the result is -1 or 1,
--   indicating the sign of the mantissa. The next two are the high and low
--   32 bits of the mantissa respectively, and the last is the exponent.
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)

-- | Decode <tt>Double#</tt> into mantissa and base-2 exponent.
decodeDouble_Int64# :: Double# -> (# Int#, Int# #)
data Float#
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#

-- | Truncates a <tt>Float#</tt> value to the nearest <tt>Int#</tt>.
--   Results are undefined if the truncation if truncation yields a value
--   outside the range of <tt>Int#</tt>.
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
logFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#

-- | Convert to integers. First <tt>Int#</tt> in result is the mantissa;
--   second is the exponent.
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
data Array# a
data MutableArray# s a

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newArray# :: Int# -> a -> State# s -> (# State# s, MutableArray# s a #)
sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s, a #)

-- | Write to specified index of mutable array.
writeArray# :: MutableArray# s a -> Int# -> a -> State# s -> State# s

-- | Return the number of elements in the array.
sizeofArray# :: Array# a -> Int#

-- | Return the number of elements in the array.
sizeofMutableArray# :: MutableArray# s a -> Int#

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
indexArray# :: Array# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeArray# :: MutableArray# s a -> State# s -> (# State# s, Array# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawArray# :: Array# a -> State# s -> (# State# s, MutableArray# s a #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
copyArray# :: Array# a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. The source and destination arrays can refer to the same array.
--   Both arrays must fully contain the specified ranges, but this is not
--   checked.
copyMutableArray# :: MutableArray# s a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneArray# :: Array# a -> Int# -> Int# -> Array# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneMutableArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
freezeArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, Array# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
thawArray# :: Array# a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   Array.
casArray# :: MutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
data SmallArray# a
data SmallMutableArray# s a

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newSmallArray# :: Int# -> a -> State# s -> (# State# s, SmallMutableArray# s a #)
sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
readSmallArray# :: SmallMutableArray# s a -> Int# -> State# s -> (# State# s, a #)

-- | Write to specified index of mutable array.
writeSmallArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> State# s

-- | Return the number of elements in the array.
sizeofSmallArray# :: SmallArray# a -> Int#

-- | Return the number of elements in the array.
sizeofSmallMutableArray# :: SmallMutableArray# s a -> Int#

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
indexSmallArray# :: SmallArray# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeSmallArray# :: SmallMutableArray# s a -> State# s -> (# State# s, SmallArray# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawSmallArray# :: SmallArray# a -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
copySmallArray# :: SmallArray# a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. The source and destination arrays can refer to the same array.
--   Both arrays must fully contain the specified ranges, but this is not
--   checked.
copySmallMutableArray# :: SmallMutableArray# s a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneSmallArray# :: SmallArray# a -> Int# -> Int# -> SmallArray# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneSmallMutableArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
freezeSmallArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallArray# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
thawSmallArray# :: SmallArray# a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   array.
casSmallArray# :: SmallMutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
data ByteArray#
data MutableByteArray# s

-- | Create a new mutable byte array of specified size (in bytes), in the
--   specified state thread.
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Create a mutable byte array that the GC guarantees not to move.
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Create a mutable byte array, aligned by the specified amount, that the
--   GC guarantees not to move.
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Intended for use with pinned arrays; otherwise very unsafe!
byteArrayContents# :: ByteArray# -> Addr#
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#

-- | Shrink mutable byte array to new specified size (in bytes), in the
--   specified state thread. The new size argument must be less than or
--   equal to the current size as reported by <tt>sizeofMutableArray#</tt>.
shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s

-- | Resize (unpinned) mutable byte array to new specified size (in bytes).
--   The returned <tt>MutableByteArray#</tt> is either the original
--   <tt>MutableByteArray#</tt> resized in-place or, if not possible, a
--   newly allocated (unpinned) <tt>MutableByteArray#</tt> (with the
--   original content copied over).
--   
--   To avoid undefined behaviour, the original <tt>MutableByteArray#</tt>
--   shall not be accessed anymore after a <tt>resizeMutableByteArray#</tt>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <tt>MutableByteArray#</tt> in case a new <tt>MutableByteArray#</tt>
--   had to be allocated.
resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Make a mutable byte array immutable, without copying.
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)

-- | Return the size of the array in bytes.
sizeofByteArray# :: ByteArray# -> Int#

-- | Return the size of the array in bytes.
sizeofMutableByteArray# :: MutableByteArray# s -> Int#

-- | Read 8-bit character; offset in bytes.
indexCharArray# :: ByteArray# -> Int# -> Char#

-- | Read 31-bit character; offset in 4-byte words.
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a

-- | Read 8-bit integer; offset in bytes.
indexInt8Array# :: ByteArray# -> Int# -> Int#

-- | Read 16-bit integer; offset in 16-bit words.
indexInt16Array# :: ByteArray# -> Int# -> Int#

-- | Read 32-bit integer; offset in 32-bit words.
indexInt32Array# :: ByteArray# -> Int# -> Int#

-- | Read 64-bit integer; offset in 64-bit words.
indexInt64Array# :: ByteArray# -> Int# -> Int#

-- | Read 8-bit word; offset in bytes.
indexWord8Array# :: ByteArray# -> Int# -> Word#

-- | Read 16-bit word; offset in 16-bit words.
indexWord16Array# :: ByteArray# -> Int# -> Word#

-- | Read 32-bit word; offset in 32-bit words.
indexWord32Array# :: ByteArray# -> Int# -> Word#

-- | Read 64-bit word; offset in 64-bit words.
indexWord64Array# :: ByteArray# -> Int# -> Word#

-- | Read 8-bit character; offset in bytes.
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read 31-bit character; offset in 4-byte words.
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read intger; offset in words.
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | Read word; offset in words.
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | Write 8-bit character; offset in bytes.
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | Write 31-bit character; offset in 4-byte words.
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt16Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt32Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt64Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord16Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord32Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord64Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | Copy a range of the ByteArray. Both arrays must fully contain the
--   specified ranges, but this is not checked. The two arrays must not be
--   the same array in different states, but this is not checked either.
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableByteArray. Both arrays must fully
--   contain the specified ranges, but this is not checked.
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the ByteArray. The ByteArray must fully contain the
--   specified ranges, but this is not checked. The Addr# must not point
--   into the ByteArray were pinned), but this is not checked either.
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s

-- | Copy a range of the MutableByteArray# to the memory range starting at
--   the Addr and the memory region at Addr# must fully contain the
--   specified ranges, but this is not checked. The Addr# must not point
--   into the MutableByteArray were pinned), but this is not checked
--   either.
copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s

-- | Copy a memory range starting at the Addr# to the specified range in
--   the MutableByteArray and the ByteArray# must fully contain the
--   specified ranges, but this is not checked. The Addr# must not point
--   into the MutableByteArray were pinned), but this is not checked
--   either.
copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Set the range of the MutableByteArray# to the specified character.
setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s

-- | Given an array and an offset in Int units, read an element. The index
--   is assumed to be in bounds. Implies a full memory barrier.
atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array and an offset in Int units, write an element. The index
--   is assumed to be in bounds. Implies a full memory barrier.
atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Given an array, an offset in Int units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to add,
--   atomically add the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to subtract,
--   atomically substract the value to the element. Returns the value of
--   the element before the operation. Implies a full memory barrier.
fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to AND,
--   atomically AND the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to NAND,
--   atomically NAND the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to OR, atomically
--   OR the value to the element. Returns the value of the element before
--   the operation. Implies a full memory barrier.
fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to XOR,
--   atomically XOR the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
data ArrayArray#
data MutableArrayArray# s

-- | Create a new mutable array of arrays with the specified number of
--   elements, in the specified state thread, with each element recursively
--   referring to the newly created array.
newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)
sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#

-- | Make a mutable array of arrays immutable, without copying.
unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)

-- | Return the number of elements in the array.
sizeofArrayArray# :: ArrayArray# -> Int#

-- | Return the number of elements in the array.
sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s

-- | Copy a range of the ArrayArray. Both arrays must fully contain the
--   specified ranges, but this is not checked. The two arrays must not be
--   the same array in different states, but this is not checked either.
copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableArrayArray# to the specified region
--   in the second MutableArrayArray#. Both arrays must fully contain the
--   specified ranges, but this is not checked.
copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | An arbitrary machine address assumed to point outside the
--   garbage-collected heap.
data Addr#

-- | The null address.
nullAddr# :: Addr#
plusAddr# :: Addr# -> Int# -> Addr#

-- | Result is meaningless if two <tt>Addr#</tt>s are so far apart that
--   their difference doesn't fit in an <tt>Int#</tt>.
minusAddr# :: Addr# -> Addr# -> Int#

-- | Return the remainder when the <tt>Addr#</tt> arg, treated like an
--   <tt>Int#</tt>, is divided by the <tt>Int#</tt> arg.
remAddr# :: Addr# -> Int# -> Int#

-- | Coerce directly from address to int. Strongly deprecated.
addr2Int# :: Addr# -> Int#

-- | Coerce directly from int to address. Strongly deprecated.
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#

-- | Reads 8-bit character; offset in bytes.
indexCharOffAddr# :: Addr# -> Int# -> Char#

-- | Reads 31-bit character; offset in 4-byte words.
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int#
indexInt16OffAddr# :: Addr# -> Int# -> Int#
indexInt32OffAddr# :: Addr# -> Int# -> Int#
indexInt64OffAddr# :: Addr# -> Int# -> Int#
indexWord8OffAddr# :: Addr# -> Int# -> Word#
indexWord16OffAddr# :: Addr# -> Int# -> Word#
indexWord32OffAddr# :: Addr# -> Int# -> Word#
indexWord64OffAddr# :: Addr# -> Int# -> Word#

-- | Reads 8-bit character; offset in bytes.
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)

-- | Reads 31-bit character; offset in 4-byte words.
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt16OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt32OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt64OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWord8OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord16OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord32OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord64OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s

-- | A <tt>MutVar#</tt> behaves like a single-element mutable array.
data MutVar# s a

-- | Create <tt>MutVar#</tt> with specified initial value in specified
--   state thread.
newMutVar# :: a -> State# s -> (# State# s, MutVar# s a #)

-- | Read contents of <tt>MutVar#</tt>. Result is not yet evaluated.
readMutVar# :: MutVar# s a -> State# s -> (# State# s, a #)

-- | Write contents of <tt>MutVar#</tt>.
writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#
atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)
casMutVar# :: MutVar# s a -> a -> a -> State# s -> (# State# s, Int#, a #)
catch# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
raise# :: a -> b
raiseIO# :: a -> State# (RealWorld) -> (# State# (RealWorld), b #)
maskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
maskUninterruptible# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
unmaskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
getMaskingState# :: State# (RealWorld) -> (# State# (RealWorld), Int# #)
data TVar# s a
atomically# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
retry# :: State# (RealWorld) -> (# State# (RealWorld), a #)
catchRetry# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
catchSTM# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
check# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), () #)

-- | Create a new <tt>TVar#</tt> holding a specified initial value.
newTVar# :: a -> State# s -> (# State# s, TVar# s a #)

-- | Read contents of <tt>TVar#</tt>. Result is not yet evaluated.
readTVar# :: TVar# s a -> State# s -> (# State# s, a #)

-- | Read contents of <tt>TVar#</tt> outside an STM transaction
readTVarIO# :: TVar# s a -> State# s -> (# State# s, a #)

-- | Write contents of <tt>TVar#</tt>.
writeTVar# :: TVar# s a -> a -> State# s -> State# s
sameTVar# :: TVar# s a -> TVar# s a -> Int#

-- | A shared mutable variable (<i>not</i> the same as a
--   <tt>MutVar#</tt>!). (Note: in a non-concurrent implementation,
--   <tt>(MVar# a)</tt> can be represented by <tt>(MutVar# (Maybe
--   a))</tt>.)
data MVar# s a

-- | Create new <tt>MVar#</tt>; initially empty.
newMVar# :: State# s -> (# State# s, MVar# s a #)

-- | If <tt>MVar#</tt> is empty, block until it becomes full. Then remove
--   and return its contents, and set it empty.
takeMVar# :: MVar# s a -> State# s -> (# State# s, a #)

-- | If <tt>MVar#</tt> is empty, immediately return with integer 0 and
--   value undefined. Otherwise, return with integer 1 and contents of
--   <tt>MVar#</tt>, and set <tt>MVar#</tt> empty.
tryTakeMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)

-- | If <tt>MVar#</tt> is full, block until it becomes empty. Then store
--   value arg as its new contents.
putMVar# :: MVar# s a -> a -> State# s -> State# s

-- | If <tt>MVar#</tt> is full, immediately return with integer 0.
--   Otherwise, store value arg as <tt>MVar#</tt>'s new contents, and
--   return with integer 1.
tryPutMVar# :: MVar# s a -> a -> State# s -> (# State# s, Int# #)

-- | If <tt>MVar#</tt> is empty, block until it becomes full. Then read its
--   contents without modifying the MVar, without possibility of
--   intervention from other threads.
readMVar# :: MVar# s a -> State# s -> (# State# s, a #)

-- | If <tt>MVar#</tt> is empty, immediately return with integer 0 and
--   value undefined. Otherwise, return with integer 1 and contents of
--   <tt>MVar#</tt>.
tryReadMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)
sameMVar# :: MVar# s a -> MVar# s a -> Int#

-- | Return 1 if <tt>MVar#</tt> is empty; 0 otherwise.
isEmptyMVar# :: MVar# s a -> State# s -> (# State# s, Int# #)

-- | Sleep specified number of microseconds.
delay# :: Int# -> State# s -> State# s

-- | Block until input is available on specified file descriptor.
waitRead# :: Int# -> State# s -> State# s

-- | Block until output is possible on specified file descriptor.
waitWrite# :: Int# -> State# s -> State# s

-- | <tt>State#</tt> is the primitive, unlifted type of states. It has one
--   type parameter, thus <tt>State# RealWorld</tt>, or <tt>State# s</tt>,
--   where s is a type variable. The only purpose of the type parameter is
--   to keep different state threads separate. It is represented by nothing
--   at all.
data State# s

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld

-- | (In a non-concurrent implementation, this can be a singleton type,
--   whose (unique) value is returned by <tt>myThreadId#</tt>. The other
--   operations can be omitted.)
data ThreadId#
fork# :: a -> State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
forkOn# :: Int# -> a -> State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
killThread# :: ThreadId# -> a -> State# (RealWorld) -> State# (RealWorld)
yield# :: State# (RealWorld) -> State# (RealWorld)
myThreadId# :: State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
labelThread# :: ThreadId# -> Addr# -> State# (RealWorld) -> State# (RealWorld)
isCurrentThreadBound# :: State# (RealWorld) -> (# State# (RealWorld), Int# #)
noDuplicate# :: State# (RealWorld) -> State# (RealWorld)
threadStatus# :: ThreadId# -> State# (RealWorld) -> (# State# (RealWorld), Int#, Int#, Int# #)
data Weak# b
mkWeak# :: o -> b -> c -> State# (RealWorld) -> (# State# (RealWorld), Weak# b #)
mkWeakNoFinalizer# :: o -> b -> State# (RealWorld) -> (# State# (RealWorld), Weak# b #)

-- | <tt>addCFinalizerToWeak# fptr ptr flag eptr w</tt> attaches a C
--   function pointer <tt>fptr</tt> to a weak pointer <tt>w</tt> as a
--   finalizer. If <tt>flag</tt> is zero, <tt>fptr</tt> will be called with
--   one argument, <tt>ptr</tt>. Otherwise, it will be called with two
--   arguments, <tt>eptr</tt> and <tt>ptr</tt>.
--   <tt>addCFinalizerToWeak#</tt> returns 1 on success, or 0 if <tt>w</tt>
--   is already dead.
addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# (RealWorld) -> (# State# (RealWorld), Int# #)
deRefWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld), Int#, a #)
finalizeWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld), Int#, State# (RealWorld) -> (# State# (RealWorld), () #) #)
touch# :: o -> State# (RealWorld) -> State# (RealWorld)
data StablePtr# a
data StableName# a
makeStablePtr# :: a -> State# (RealWorld) -> (# State# (RealWorld), StablePtr# a #)
deRefStablePtr# :: StablePtr# a -> State# (RealWorld) -> (# State# (RealWorld), a #)
eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: a -> State# (RealWorld) -> (# State# (RealWorld), StableName# a #)
eqStableName# :: StableName# a -> StableName# b -> Int#
stableNameToInt# :: StableName# a -> Int#
reallyUnsafePtrEquality# :: a -> a -> Int#
par# :: a -> Int#
spark# :: a -> State# s -> (# State# s, a #)
seq# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)

-- | Returns the number of sparks in the local spark pool.
numSparks# :: State# s -> (# State# s, Int# #)
parGlobal# :: a -> Int# -> Int# -> Int# -> Int# -> b -> Int#
parLocal# :: a -> Int# -> Int# -> Int# -> Int# -> b -> Int#
parAt# :: b -> a -> Int# -> Int# -> Int# -> Int# -> c -> Int#
parAtAbs# :: a -> Int# -> Int# -> Int# -> Int# -> Int# -> b -> Int#
parAtRel# :: a -> Int# -> Int# -> Int# -> Int# -> Int# -> b -> Int#
parAtForNow# :: b -> a -> Int# -> Int# -> Int# -> Int# -> c -> Int#
dataToTag# :: a -> Int#
tagToEnum# :: Int# -> a

-- | Primitive bytecode type.
data BCO#

-- | Convert an <tt>Addr#</tt> to a followable Any type.
addrToAny# :: Addr# -> (# a #)
mkApUpd0# :: BCO# -> (# a #)
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO# #)
unpackClosure# :: a -> (# Addr#, Array# b, ByteArray# #)
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)

-- | Returns the current <tt>CostCentreStack</tt> (value is <tt>NULL</tt>
--   if not profiling). Takes a dummy argument which can be used to avoid
--   the call to <tt>getCCCS#</tt> being floated out by the simplifier,
--   which would result in an uninformative stack ("CAF").
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)

-- | The type constructor <tt>Proxy#</tt> is used to bear witness to some
--   type variable. It's used when you want to pass around proxy values for
--   doing things like modelling type applications. A <tt>Proxy#</tt> is
--   not only unboxed, it also has a polymorphic kind, and has no runtime
--   representation, being totally free.
data Proxy# a

-- | Witness for an unboxed <tt>Proxy#</tt> value, which has no runtime
--   representation.
proxy# :: Proxy# a

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. <tt>seq</tt> is usually introduced to
--   improve performance by avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: a -> b -> b

-- | The type constructor <tt>Any</tt> is type to which you can unsafely
--   coerce any lifted type, and back.
--   
--   <ul>
--   <li>It is lifted, and hence represented by a pointer</li>
--   <li>It does not claim to be a <i>data</i> type, and that's important
--   for the code generator, because the code gen may <i>enter</i> a data
--   value but never enters a function value.</li>
--   </ul>
--   
--   It's also used to instantiate un-constrained type variables after type
--   checking. For example, <tt>length</tt> has type
--   
--   <pre>
--   length :: forall a. [a] -&gt; Int
--   </pre>
--   
--   and the list datacon for the empty list has type
--   
--   <pre>
--   [] :: forall a. [a]
--   </pre>
--   
--   In order to compose these two terms as <tt>length []</tt> a type
--   application is required, but there is no constraint on the choice. In
--   this situation GHC uses <tt>Any</tt>:
--   
--   <pre>
--   length (Any *) ([] (Any *))
--   </pre>
--   
--   Above, we print kinds explicitly, as if with
--   <tt>-fprint-explicit-kinds</tt>.
--   
--   Note that <tt>Any</tt> is kind polymorphic; its kind is thus
--   <tt>forall k. k</tt>.
data Any

-- | The kind <tt>AnyK</tt> is the kind level counterpart to <tt>Any</tt>.
--   In a kind polymorphic setting, a similar example to the length of the
--   empty list can be given at the type level:
--   
--   <tt>type family Length (l :: [k]) :: Nat</tt> <tt>type instance Length
--   [] = Zero</tt>
--   
--   When <tt>Length</tt> is applied to the empty (promoted) list it will
--   have the kind <tt>Length AnyK []</tt>.
--   
--   <tt>AnyK</tt> is currently not exported and cannot be used directly,
--   but you might see it in debug output from the compiler.
data AnyK

-- | The function <tt>unsafeCoerce#</tt> allows you to side-step the
--   typechecker entirely. That is, it allows you to coerce any type into
--   any other type. If you use this function, you had better get it right,
--   otherwise segmentation faults await. It is generally used when you
--   want to write a program that you know is well-typed, but where
--   Haskell's type system is not expressive enough to prove that it is
--   well typed.
--   
--   The following uses of <tt>unsafeCoerce#</tt> are supposed to work
--   (i.e. not lead to spurious compile-time or run-time crashes):
--   
--   <ul>
--   <li>Casting any lifted type to <tt>Any</tt></li>
--   <li>Casting <tt>Any</tt> back to the real type</li>
--   <li>Casting an unboxed type to another unboxed type of the same size
--   (but not coercions between floating-point and integral types)</li>
--   <li>Casting between two types that have the same runtime
--   representation. One case is when the two types differ only in
--   "phantom" type parameters, for example <tt>Ptr Int</tt> to <tt>Ptr
--   Float</tt>, or <tt>[Int]</tt> to <tt>[Float]</tt> when the list is
--   known to be empty. Also, a <tt>newtype</tt> of a type <tt>T</tt> has
--   the same representation at runtime as <tt>T</tt>.</li>
--   </ul>
--   
--   Other uses of <tt>unsafeCoerce#</tt> are undefined. In particular, you
--   should not use <tt>unsafeCoerce#</tt> to cast a T to an algebraic data
--   type D, unless T is also an algebraic data type. For example, do not
--   cast <tt>Int-&gt;Int</tt> to <tt>Bool</tt>, even if you later cast
--   that <tt>Bool</tt> back to <tt>Int-&gt;Int</tt> before applying it.
--   The reasons have to do with GHC's internal representation details (for
--   the congnoscenti, data values can be entered but function closures
--   cannot). If you want a safe type to cast things to, use <tt>Any</tt>,
--   which is not an algebraic data type.
unsafeCoerce# :: a -> b

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the zero-terminated byte string passed as the first argument.
--   The event will be emitted either to the .eventlog file, or to stderr,
--   depending on the runtime RTS flags.
traceEvent# :: Addr# -> State# s -> State# s

-- | Emits a marker event via the RTS tracing framework. The contents of
--   the event is the zero-terminated byte string passed as the first
--   argument. The event will be emitted either to the .eventlog file, or
--   to stderr, depending on the runtime RTS flags.
traceMarker# :: Addr# -> State# s -> State# s

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible a b => a -> b
data Int8X16#
data Int16X8#
data Int32X4#
data Int64X2#
data Int8X32#
data Int16X16#
data Int32X8#
data Int64X4#
data Int8X64#
data Int16X32#
data Int32X16#
data Int64X8#
data Word8X16#
data Word16X8#
data Word32X4#
data Word64X2#
data Word8X32#
data Word16X16#
data Word32X8#
data Word64X4#
data Word8X64#
data Word16X32#
data Word32X16#
data Word64X8#
data FloatX4#
data DoubleX2#
data FloatX8#
data DoubleX4#
data FloatX16#
data DoubleX8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X16# :: Int# -> Int8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X8# :: Int# -> Int16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X4# :: Int# -> Int32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X2# :: Int# -> Int64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X32# :: Int# -> Int8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X16# :: Int# -> Int16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X8# :: Int# -> Int32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X4# :: Int# -> Int64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X64# :: Int# -> Int8X64#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X32# :: Int# -> Int16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X16# :: Int# -> Int32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X8# :: Int# -> Int64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X16# :: Word# -> Word8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X8# :: Word# -> Word16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X4# :: Word# -> Word32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X2# :: Word# -> Word64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X32# :: Word# -> Word8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X16# :: Word# -> Word16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X8# :: Word# -> Word32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X4# :: Word# -> Word64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X64# :: Word# -> Word8X64#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X32# :: Word# -> Word16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X16# :: Word# -> Word32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X8# :: Word# -> Word64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX4# :: Float# -> FloatX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX2# :: Double# -> DoubleX2#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX8# :: Float# -> FloatX8#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX4# :: Double# -> DoubleX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX16# :: Float# -> FloatX16#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX8# :: Double# -> DoubleX8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X4# :: (# Int#, Int#, Int#, Int# #) -> Int32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X2# :: (# Int#, Int# #) -> Int64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X32# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X4# :: (# Int#, Int#, Int#, Int# #) -> Int64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X64# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X64#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X32# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X4# :: (# Word#, Word#, Word#, Word# #) -> Word32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X2# :: (# Word#, Word# #) -> Word64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X32# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X4# :: (# Word#, Word#, Word#, Word# #) -> Word64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X64# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X64#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X32# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X16# :: Int8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X8# :: Int16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X4# :: Int32X4# -> (# Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X2# :: Int64X2# -> (# Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X32# :: Int8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X16# :: Int16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X8# :: Int32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X4# :: Int64X4# -> (# Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X64# :: Int8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X32# :: Int16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X16# :: Int32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X8# :: Int64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X16# :: Word8X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X8# :: Word16X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X4# :: Word32X4# -> (# Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X2# :: Word64X2# -> (# Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X32# :: Word8X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X16# :: Word16X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X8# :: Word32X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X4# :: Word64X4# -> (# Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X64# :: Word8X64# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X32# :: Word16X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X16# :: Word32X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X8# :: Word64X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)

-- | Insert a scalar at the given position in a vector.
insertInt8X16# :: Int8X16# -> Int# -> Int# -> Int8X16#

-- | Insert a scalar at the given position in a vector.
insertInt16X8# :: Int16X8# -> Int# -> Int# -> Int16X8#

-- | Insert a scalar at the given position in a vector.
insertInt32X4# :: Int32X4# -> Int# -> Int# -> Int32X4#

-- | Insert a scalar at the given position in a vector.
insertInt64X2# :: Int64X2# -> Int# -> Int# -> Int64X2#

-- | Insert a scalar at the given position in a vector.
insertInt8X32# :: Int8X32# -> Int# -> Int# -> Int8X32#

-- | Insert a scalar at the given position in a vector.
insertInt16X16# :: Int16X16# -> Int# -> Int# -> Int16X16#

-- | Insert a scalar at the given position in a vector.
insertInt32X8# :: Int32X8# -> Int# -> Int# -> Int32X8#

-- | Insert a scalar at the given position in a vector.
insertInt64X4# :: Int64X4# -> Int# -> Int# -> Int64X4#

-- | Insert a scalar at the given position in a vector.
insertInt8X64# :: Int8X64# -> Int# -> Int# -> Int8X64#

-- | Insert a scalar at the given position in a vector.
insertInt16X32# :: Int16X32# -> Int# -> Int# -> Int16X32#

-- | Insert a scalar at the given position in a vector.
insertInt32X16# :: Int32X16# -> Int# -> Int# -> Int32X16#

-- | Insert a scalar at the given position in a vector.
insertInt64X8# :: Int64X8# -> Int# -> Int# -> Int64X8#

-- | Insert a scalar at the given position in a vector.
insertWord8X16# :: Word8X16# -> Word# -> Int# -> Word8X16#

-- | Insert a scalar at the given position in a vector.
insertWord16X8# :: Word16X8# -> Word# -> Int# -> Word16X8#

-- | Insert a scalar at the given position in a vector.
insertWord32X4# :: Word32X4# -> Word# -> Int# -> Word32X4#

-- | Insert a scalar at the given position in a vector.
insertWord64X2# :: Word64X2# -> Word# -> Int# -> Word64X2#

-- | Insert a scalar at the given position in a vector.
insertWord8X32# :: Word8X32# -> Word# -> Int# -> Word8X32#

-- | Insert a scalar at the given position in a vector.
insertWord16X16# :: Word16X16# -> Word# -> Int# -> Word16X16#

-- | Insert a scalar at the given position in a vector.
insertWord32X8# :: Word32X8# -> Word# -> Int# -> Word32X8#

-- | Insert a scalar at the given position in a vector.
insertWord64X4# :: Word64X4# -> Word# -> Int# -> Word64X4#

-- | Insert a scalar at the given position in a vector.
insertWord8X64# :: Word8X64# -> Word# -> Int# -> Word8X64#

-- | Insert a scalar at the given position in a vector.
insertWord16X32# :: Word16X32# -> Word# -> Int# -> Word16X32#

-- | Insert a scalar at the given position in a vector.
insertWord32X16# :: Word32X16# -> Word# -> Int# -> Word32X16#

-- | Insert a scalar at the given position in a vector.
insertWord64X8# :: Word64X8# -> Word# -> Int# -> Word64X8#

-- | Insert a scalar at the given position in a vector.
insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#

-- | Insert a scalar at the given position in a vector.
insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#

-- | Insert a scalar at the given position in a vector.
insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#

-- | Insert a scalar at the given position in a vector.
insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#

-- | Insert a scalar at the given position in a vector.
insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#

-- | Insert a scalar at the given position in a vector.
insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#

-- | Add two vectors element-wise.
plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Add two vectors element-wise.
plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Add two vectors element-wise.
plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Add two vectors element-wise.
plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Add two vectors element-wise.
plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Add two vectors element-wise.
plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Add two vectors element-wise.
plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Add two vectors element-wise.
plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Add two vectors element-wise.
plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Add two vectors element-wise.
plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Add two vectors element-wise.
plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Add two vectors element-wise.
plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Add two vectors element-wise.
plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Add two vectors element-wise.
plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Add two vectors element-wise.
plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Add two vectors element-wise.
plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Add two vectors element-wise.
plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Add two vectors element-wise.
plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Add two vectors element-wise.
plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Add two vectors element-wise.
plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Add two vectors element-wise.
plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Add two vectors element-wise.
plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Add two vectors element-wise.
plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Add two vectors element-wise.
plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Add two vectors element-wise.
plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Add two vectors element-wise.
plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Add two vectors element-wise.
plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Add two vectors element-wise.
plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Add two vectors element-wise.
plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Add two vectors element-wise.
plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Subtract two vectors element-wise.
minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Subtract two vectors element-wise.
minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Subtract two vectors element-wise.
minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Subtract two vectors element-wise.
minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Subtract two vectors element-wise.
minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Subtract two vectors element-wise.
minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Subtract two vectors element-wise.
minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Subtract two vectors element-wise.
minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Subtract two vectors element-wise.
minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Subtract two vectors element-wise.
minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Subtract two vectors element-wise.
minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Subtract two vectors element-wise.
minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Subtract two vectors element-wise.
minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Subtract two vectors element-wise.
minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Subtract two vectors element-wise.
minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Subtract two vectors element-wise.
minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Subtract two vectors element-wise.
minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Subtract two vectors element-wise.
minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Subtract two vectors element-wise.
minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Subtract two vectors element-wise.
minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Subtract two vectors element-wise.
minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Subtract two vectors element-wise.
minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Subtract two vectors element-wise.
minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Subtract two vectors element-wise.
minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Subtract two vectors element-wise.
minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Subtract two vectors element-wise.
minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Subtract two vectors element-wise.
minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Subtract two vectors element-wise.
minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Subtract two vectors element-wise.
minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Subtract two vectors element-wise.
minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Multiply two vectors element-wise.
timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Multiply two vectors element-wise.
timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Multiply two vectors element-wise.
timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Multiply two vectors element-wise.
timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Multiply two vectors element-wise.
timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Multiply two vectors element-wise.
timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Multiply two vectors element-wise.
timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Multiply two vectors element-wise.
timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Multiply two vectors element-wise.
timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Multiply two vectors element-wise.
timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Multiply two vectors element-wise.
timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Multiply two vectors element-wise.
timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Multiply two vectors element-wise.
timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Multiply two vectors element-wise.
timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Multiply two vectors element-wise.
timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Multiply two vectors element-wise.
timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Multiply two vectors element-wise.
timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Multiply two vectors element-wise.
timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Multiply two vectors element-wise.
timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Multiply two vectors element-wise.
timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Multiply two vectors element-wise.
timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Multiply two vectors element-wise.
timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Multiply two vectors element-wise.
timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Multiply two vectors element-wise.
timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Multiply two vectors element-wise.
timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Multiply two vectors element-wise.
timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Multiply two vectors element-wise.
timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Multiply two vectors element-wise.
timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Multiply two vectors element-wise.
timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Multiply two vectors element-wise.
timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Divide two vectors element-wise.
divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Divide two vectors element-wise.
divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Divide two vectors element-wise.
divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Divide two vectors element-wise.
divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Divide two vectors element-wise.
divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Divide two vectors element-wise.
divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Rounds towards zero element-wise.
quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Rounds towards zero element-wise.
quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Rounds towards zero element-wise.
quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Rounds towards zero element-wise.
quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Rounds towards zero element-wise.
quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Rounds towards zero element-wise.
quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Rounds towards zero element-wise.
quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Rounds towards zero element-wise.
quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Rounds towards zero element-wise.
quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Rounds towards zero element-wise.
quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Rounds towards zero element-wise.
quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Rounds towards zero element-wise.
quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Rounds towards zero element-wise.
quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Rounds towards zero element-wise.
quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Rounds towards zero element-wise.
quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Rounds towards zero element-wise.
quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Rounds towards zero element-wise.
quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Rounds towards zero element-wise.
quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Rounds towards zero element-wise.
quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Rounds towards zero element-wise.
quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Rounds towards zero element-wise.
quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Rounds towards zero element-wise.
quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Rounds towards zero element-wise.
quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Rounds towards zero element-wise.
quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Negate element-wise.
negateInt8X16# :: Int8X16# -> Int8X16#

-- | Negate element-wise.
negateInt16X8# :: Int16X8# -> Int16X8#

-- | Negate element-wise.
negateInt32X4# :: Int32X4# -> Int32X4#

-- | Negate element-wise.
negateInt64X2# :: Int64X2# -> Int64X2#

-- | Negate element-wise.
negateInt8X32# :: Int8X32# -> Int8X32#

-- | Negate element-wise.
negateInt16X16# :: Int16X16# -> Int16X16#

-- | Negate element-wise.
negateInt32X8# :: Int32X8# -> Int32X8#

-- | Negate element-wise.
negateInt64X4# :: Int64X4# -> Int64X4#

-- | Negate element-wise.
negateInt8X64# :: Int8X64# -> Int8X64#

-- | Negate element-wise.
negateInt16X32# :: Int16X32# -> Int16X32#

-- | Negate element-wise.
negateInt32X16# :: Int32X16# -> Int32X16#

-- | Negate element-wise.
negateInt64X8# :: Int64X8# -> Int64X8#

-- | Negate element-wise.
negateFloatX4# :: FloatX4# -> FloatX4#

-- | Negate element-wise.
negateDoubleX2# :: DoubleX2# -> DoubleX2#

-- | Negate element-wise.
negateFloatX8# :: FloatX8# -> FloatX8#

-- | Negate element-wise.
negateDoubleX4# :: DoubleX4# -> DoubleX4#

-- | Negate element-wise.
negateFloatX16# :: FloatX16# -> FloatX16#

-- | Negate element-wise.
negateDoubleX8# :: DoubleX8# -> DoubleX8#

-- | Read a vector from specified index of immutable array.
indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array.
indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array.
indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array.
indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array.
indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array.
indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array.
indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array.
indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array.
indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array.
indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array.
indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array.
indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array.
indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array.
indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array.
indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array.
indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array.
indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array.
indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array.
indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array.
indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array.
indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array.
indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array.
indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array.
indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array.
indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array.
indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array.
indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array.
indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array.
indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array.
indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array.
readInt8X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Read a vector from specified index of mutable array.
readInt16X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Read a vector from specified index of mutable array.
readInt32X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Read a vector from specified index of mutable array.
readInt64X2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Read a vector from specified index of mutable array.
readInt8X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Read a vector from specified index of mutable array.
readInt16X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Read a vector from specified index of mutable array.
readInt32X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Read a vector from specified index of mutable array.
readInt64X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Read a vector from specified index of mutable array.
readInt8X64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Read a vector from specified index of mutable array.
readInt16X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Read a vector from specified index of mutable array.
readInt32X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Read a vector from specified index of mutable array.
readInt64X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Read a vector from specified index of mutable array.
readWord8X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Read a vector from specified index of mutable array.
readWord16X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Read a vector from specified index of mutable array.
readWord32X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Read a vector from specified index of mutable array.
readWord64X2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Read a vector from specified index of mutable array.
readWord8X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Read a vector from specified index of mutable array.
readWord16X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Read a vector from specified index of mutable array.
readWord32X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Read a vector from specified index of mutable array.
readWord64X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Read a vector from specified index of mutable array.
readWord8X64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Read a vector from specified index of mutable array.
readWord16X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Read a vector from specified index of mutable array.
readWord32X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Read a vector from specified index of mutable array.
readWord64X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Read a vector from specified index of mutable array.
readFloatX4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Read a vector from specified index of mutable array.
readDoubleX2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Read a vector from specified index of mutable array.
readFloatX8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Read a vector from specified index of mutable array.
readDoubleX4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Read a vector from specified index of mutable array.
readFloatX16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Read a vector from specified index of mutable array.
readDoubleX8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write a vector to specified index of mutable array.
writeInt8X16Array# :: MutableByteArray# s -> Int# -> Int8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt16X8Array# :: MutableByteArray# s -> Int# -> Int16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt32X4Array# :: MutableByteArray# s -> Int# -> Int32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt64X2Array# :: MutableByteArray# s -> Int# -> Int64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt8X32Array# :: MutableByteArray# s -> Int# -> Int8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt16X16Array# :: MutableByteArray# s -> Int# -> Int16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt32X8Array# :: MutableByteArray# s -> Int# -> Int32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt64X4Array# :: MutableByteArray# s -> Int# -> Int64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt8X64Array# :: MutableByteArray# s -> Int# -> Int8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt16X32Array# :: MutableByteArray# s -> Int# -> Int16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt32X16Array# :: MutableByteArray# s -> Int# -> Int32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt64X8Array# :: MutableByteArray# s -> Int# -> Int64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord8X16Array# :: MutableByteArray# s -> Int# -> Word8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord16X8Array# :: MutableByteArray# s -> Int# -> Word16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord32X4Array# :: MutableByteArray# s -> Int# -> Word32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord64X2Array# :: MutableByteArray# s -> Int# -> Word64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord8X32Array# :: MutableByteArray# s -> Int# -> Word8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord16X16Array# :: MutableByteArray# s -> Int# -> Word16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord32X8Array# :: MutableByteArray# s -> Int# -> Word32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord64X4Array# :: MutableByteArray# s -> Int# -> Word64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord8X64Array# :: MutableByteArray# s -> Int# -> Word8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord16X32Array# :: MutableByteArray# s -> Int# -> Word16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord32X16Array# :: MutableByteArray# s -> Int# -> Word32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord64X8Array# :: MutableByteArray# s -> Int# -> Word64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeFloatX4Array# :: MutableByteArray# s -> Int# -> FloatX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeDoubleX2Array# :: MutableByteArray# s -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeFloatX8Array# :: MutableByteArray# s -> Int# -> FloatX8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeDoubleX4Array# :: MutableByteArray# s -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeFloatX16Array# :: MutableByteArray# s -> Int# -> FloatX16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeDoubleX8Array# :: MutableByteArray# s -> Int# -> DoubleX8# -> State# s -> State# s

-- | Reads vector; offset in bytes.
indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in bytes.
indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in bytes.
indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in bytes.
indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in bytes.
indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in bytes.
indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in bytes.
indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in bytes.
indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in bytes.
indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in bytes.
indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in bytes.
indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in bytes.
indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in bytes.
indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in bytes.
indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in bytes.
indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in bytes.
indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in bytes.
indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in bytes.
indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in bytes.
indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in bytes.
indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in bytes.
indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in bytes.
indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in bytes.
indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in bytes.
indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in bytes.
indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in bytes.
indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in bytes.
indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in bytes.
indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in bytes.
indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in bytes.
indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in bytes.
readInt8X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Reads vector; offset in bytes.
readInt16X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Reads vector; offset in bytes.
readInt32X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Reads vector; offset in bytes.
readInt64X2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Reads vector; offset in bytes.
readInt8X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Reads vector; offset in bytes.
readInt16X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Reads vector; offset in bytes.
readInt32X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Reads vector; offset in bytes.
readInt64X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Reads vector; offset in bytes.
readInt8X64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Reads vector; offset in bytes.
readInt16X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Reads vector; offset in bytes.
readInt32X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Reads vector; offset in bytes.
readInt64X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Reads vector; offset in bytes.
readWord8X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Reads vector; offset in bytes.
readWord16X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Reads vector; offset in bytes.
readWord32X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Reads vector; offset in bytes.
readWord64X2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Reads vector; offset in bytes.
readWord8X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Reads vector; offset in bytes.
readWord16X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Reads vector; offset in bytes.
readWord32X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Reads vector; offset in bytes.
readWord64X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Reads vector; offset in bytes.
readWord8X64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Reads vector; offset in bytes.
readWord16X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Reads vector; offset in bytes.
readWord32X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Reads vector; offset in bytes.
readWord64X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Reads vector; offset in bytes.
readFloatX4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Reads vector; offset in bytes.
readDoubleX2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Reads vector; offset in bytes.
readFloatX8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Reads vector; offset in bytes.
readDoubleX4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Reads vector; offset in bytes.
readFloatX16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Reads vector; offset in bytes.
readDoubleX8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write vector; offset in bytes.
writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# s -> State# s

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt8ArrayAsInt8X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt16ArrayAsInt16X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt32ArrayAsInt32X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt64ArrayAsInt64X2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt8ArrayAsInt8X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt16ArrayAsInt16X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt32ArrayAsInt32X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt64ArrayAsInt64X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt8ArrayAsInt8X64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt16ArrayAsInt16X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt32ArrayAsInt32X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt64ArrayAsInt64X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord8ArrayAsWord8X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord16ArrayAsWord16X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord32ArrayAsWord32X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord64ArrayAsWord64X2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord8ArrayAsWord8X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord16ArrayAsWord16X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord32ArrayAsWord32X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord64ArrayAsWord64X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord8ArrayAsWord8X64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord16ArrayAsWord16X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord32ArrayAsWord32X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord64ArrayAsWord64X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readFloatArrayAsFloatX4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readDoubleArrayAsDoubleX2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readFloatArrayAsFloatX8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readDoubleArrayAsDoubleX4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readFloatArrayAsFloatX16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readDoubleArrayAsDoubleX8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt8ArrayAsInt8X16# :: MutableByteArray# s -> Int# -> Int8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt16ArrayAsInt16X8# :: MutableByteArray# s -> Int# -> Int16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt32ArrayAsInt32X4# :: MutableByteArray# s -> Int# -> Int32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt64ArrayAsInt64X2# :: MutableByteArray# s -> Int# -> Int64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt8ArrayAsInt8X32# :: MutableByteArray# s -> Int# -> Int8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt16ArrayAsInt16X16# :: MutableByteArray# s -> Int# -> Int16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt32ArrayAsInt32X8# :: MutableByteArray# s -> Int# -> Int32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt64ArrayAsInt64X4# :: MutableByteArray# s -> Int# -> Int64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt8ArrayAsInt8X64# :: MutableByteArray# s -> Int# -> Int8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt16ArrayAsInt16X32# :: MutableByteArray# s -> Int# -> Int16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt32ArrayAsInt32X16# :: MutableByteArray# s -> Int# -> Int32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt64ArrayAsInt64X8# :: MutableByteArray# s -> Int# -> Int64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord8ArrayAsWord8X16# :: MutableByteArray# s -> Int# -> Word8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord16ArrayAsWord16X8# :: MutableByteArray# s -> Int# -> Word16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord32ArrayAsWord32X4# :: MutableByteArray# s -> Int# -> Word32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord64ArrayAsWord64X2# :: MutableByteArray# s -> Int# -> Word64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord8ArrayAsWord8X32# :: MutableByteArray# s -> Int# -> Word8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord16ArrayAsWord16X16# :: MutableByteArray# s -> Int# -> Word16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord32ArrayAsWord32X8# :: MutableByteArray# s -> Int# -> Word32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord64ArrayAsWord64X4# :: MutableByteArray# s -> Int# -> Word64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord8ArrayAsWord8X64# :: MutableByteArray# s -> Int# -> Word8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord16ArrayAsWord16X32# :: MutableByteArray# s -> Int# -> Word16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord32ArrayAsWord32X16# :: MutableByteArray# s -> Int# -> Word32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord64ArrayAsWord64X8# :: MutableByteArray# s -> Int# -> Word64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeFloatArrayAsFloatX4# :: MutableByteArray# s -> Int# -> FloatX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeDoubleArrayAsDoubleX2# :: MutableByteArray# s -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeFloatArrayAsFloatX8# :: MutableByteArray# s -> Int# -> FloatX8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeDoubleArrayAsDoubleX4# :: MutableByteArray# s -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeFloatArrayAsFloatX16# :: MutableByteArray# s -> Int# -> FloatX16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeDoubleArrayAsDoubleX8# :: MutableByteArray# s -> Int# -> DoubleX8# -> State# s -> State# s

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in scalar elements.
readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Reads vector; offset in scalar elements.
readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Reads vector; offset in scalar elements.
readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Reads vector; offset in scalar elements.
readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Reads vector; offset in scalar elements.
readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Reads vector; offset in scalar elements.
readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Reads vector; offset in scalar elements.
readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Reads vector; offset in scalar elements.
readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Reads vector; offset in scalar elements.
readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Reads vector; offset in scalar elements.
readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Reads vector; offset in scalar elements.
readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Reads vector; offset in scalar elements.
readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Reads vector; offset in scalar elements.
readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Reads vector; offset in scalar elements.
readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Reads vector; offset in scalar elements.
readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Reads vector; offset in scalar elements.
readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Reads vector; offset in scalar elements.
readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Reads vector; offset in scalar elements.
readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Reads vector; offset in scalar elements.
readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Reads vector; offset in scalar elements.
readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Reads vector; offset in scalar elements.
readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Reads vector; offset in scalar elements.
readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Reads vector; offset in scalar elements.
readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Reads vector; offset in scalar elements.
readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Reads vector; offset in scalar elements.
readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Reads vector; offset in scalar elements.
readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Reads vector; offset in scalar elements.
readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Reads vector; offset in scalar elements.
readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Reads vector; offset in scalar elements.
readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Reads vector; offset in scalar elements.
readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write vector; offset in scalar elements.
writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# s -> State# s
prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
prefetchValue3# :: a -> State# s -> State# s
prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
prefetchValue2# :: a -> State# s -> State# s
prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
prefetchValue1# :: a -> State# s -> State# s
prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
prefetchValue0# :: a -> State# s -> State# s

module GHC.Debug
debugLn :: [Char] -> IO ()
debugErrLn :: [Char] -> IO ()


-- | GHC C strings definitions (previously in GHC.Base). Use GHC.Exts from
--   the base package instead of importing this module directly.
module GHC.CString
unpackCString# :: Addr# -> [Char]
unpackAppendCString# :: Addr# -> [Char] -> [Char]
unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a
unpackCStringUtf8# :: Addr# -> [Char]
unpackNBytes# :: Addr# -> Int# -> [Char]

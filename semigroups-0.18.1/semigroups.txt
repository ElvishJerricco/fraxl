-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Anything that associates
--   
--   In mathematics, a semigroup is an algebraic structure consisting of a
--   set together with an associative binary operation. A semigroup
--   generalizes a monoid in that there might not exist an identity
--   element. It also (originally) generalized a group (a monoid with all
--   inverses) to a type where every element did not have to have an
--   inverse, thus the name semigroup.
@package semigroups
@version 0.18.1


-- | A NonEmpty list forms a monad as per list, but always contains at
--   least one element.
module Data.List.NonEmpty
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a

-- | Map a function over a <a>NonEmpty</a> stream.
map :: (a -> b) -> NonEmpty a -> NonEmpty b

-- | 'intersperse x xs' alternates elements of the list with copies of
--   <tt>x</tt>.
--   
--   <pre>
--   intersperse 0 (1 :| [2,3]) == 1 :| [0,2,0,3]
--   </pre>
intersperse :: a -> NonEmpty a -> NonEmpty a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a stream of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == z :| [z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == x1 :| [x1 `f` x2, x1 `f` (x2 `f` x3), ...]
--   </pre>
scanl1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>transpose</a> for <a>NonEmpty</a>, behaves the same as
--   <a>transpose</a> The rows/columns need not be the same length, in
--   which case &gt; transpose . transpose /= id
transpose :: NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)

-- | <a>sortBy</a> for <a>NonEmpty</a>, behaves the same as <a>sortBy</a>
sortBy :: (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a

-- | <a>sortWith</a> for <a>NonEmpty</a>, behaves the same as:
--   
--   <pre>
--   sortBy . comparing
--   </pre>
sortWith :: Ord o => (a -> o) -> NonEmpty a -> NonEmpty a
length :: NonEmpty a -> Int

-- | Extract the first element of the stream.
head :: NonEmpty a -> a

-- | Extract the possibly-empty tail of the stream.
tail :: NonEmpty a -> [a]

-- | Extract the last element of the stream.
last :: NonEmpty a -> a

-- | Extract everything except the last element of the stream.
init :: NonEmpty a -> [a]

-- | Prepend an element to the stream.
(<|) :: a -> NonEmpty a -> NonEmpty a

-- | Synonym for <a>&lt;|</a>.
cons :: a -> NonEmpty a -> NonEmpty a

-- | <a>uncons</a> produces the first element of the stream, and a stream
--   of the remaining elements, if any.
uncons :: NonEmpty a -> (a, Maybe (NonEmpty a))
unfoldr :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | Sort a stream.
sort :: Ord a => NonEmpty a -> NonEmpty a

-- | <a>reverse</a> a finite NonEmpty stream.
reverse :: NonEmpty a -> NonEmpty a

-- | The <a>inits</a> function takes a stream <tt>xs</tt> and returns all
--   the finite prefixes of <tt>xs</tt>.
inits :: Foldable f => f a -> NonEmpty [a]

-- | The <a>tails</a> function takes a stream <tt>xs</tt> and returns all
--   the suffixes of <tt>xs</tt>.
tails :: Foldable f => f a -> NonEmpty [a]

-- | <tt><a>iterate</a> f x</tt> produces the infinite sequence of repeated
--   applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   iterate f x = x :| [f x, f (f x), ..]
--   </pre>
iterate :: (a -> a) -> a -> NonEmpty a

-- | <tt><a>repeat</a> x</tt> returns a constant stream, where all elements
--   are equal to <tt>x</tt>.
repeat :: a -> NonEmpty a

-- | <tt><a>cycle</a> xs</tt> returns the infinite repetition of
--   <tt>xs</tt>:
--   
--   <pre>
--   cycle [1,2,3] = 1 :| [2,3,1,2,3,...]
--   </pre>
cycle :: NonEmpty a -> NonEmpty a

-- | <a>unfold</a> produces a new stream by repeatedly applying the
--   unfolding function to the seed value to produce an element of type
--   <tt>b</tt> and a new seed value. When the unfolding function returns
--   <a>Nothing</a> instead of a new seed value, the stream ends.
unfold :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | <tt><a>insert</a> x xs</tt> inserts <tt>x</tt> into the last position
--   in <tt>xs</tt> where it is still less than or equal to the next
--   element. In particular, if the list is sorted beforehand, the result
--   will also be sorted.
insert :: (Foldable f, Ord a) => a -> f a -> NonEmpty a

-- | <tt><a>some1</a> x</tt> sequences <tt>x</tt> one or more times.
some1 :: Alternative f => f a -> f (NonEmpty a)

-- | <tt><a>take</a> n xs</tt> returns the first <tt>n</tt> elements of
--   <tt>xs</tt>.
take :: Int -> NonEmpty a -> [a]

-- | <tt><a>drop</a> n xs</tt> drops the first <tt>n</tt> elements off the
--   front of the sequence <tt>xs</tt>.
drop :: Int -> NonEmpty a -> [a]

-- | <tt><a>splitAt</a> n xs</tt> returns a pair consisting of the prefix
--   of <tt>xs</tt> of length <tt>n</tt> and the remaining stream
--   immediately following this prefix.
--   
--   <pre>
--   'splitAt' n xs == ('take' n xs, 'drop' n xs)
--   xs == ys ++ zs where (ys, zs) = 'splitAt' n xs
--   </pre>
splitAt :: Int -> NonEmpty a -> ([a], [a])

-- | <tt><a>takeWhile</a> p xs</tt> returns the longest prefix of the
--   stream <tt>xs</tt> for which the predicate <tt>p</tt> holds.
takeWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>dropWhile</a> p xs</tt> returns the suffix remaining after
--   <tt><a>takeWhile</a> p xs</tt>.
dropWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>span</a> p xs</tt> returns the longest prefix of <tt>xs</tt>
--   that satisfies <tt>p</tt>, together with the remainder of the stream.
--   
--   <pre>
--   'span' p xs == ('takeWhile' p xs, 'dropWhile' p xs)
--   xs == ys ++ zs where (ys, zs) = 'span' p xs
--   </pre>
span :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <tt><a>break</a> p</tt> function is equivalent to <tt><a>span</a>
--   (not . p)</tt>.
break :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | <tt><a>filter</a> p xs</tt> removes any elements from <tt>xs</tt> that
--   do not satisfy <tt>p</tt>.
filter :: (a -> Bool) -> NonEmpty a -> [a]

-- | The <a>partition</a> function takes a predicate <tt>p</tt> and a
--   stream <tt>xs</tt>, and returns a pair of lists. The first list
--   corresponds to the elements of <tt>xs</tt> for which <tt>p</tt> holds;
--   the second corresponds to the elements of <tt>xs</tt> for which
--   <tt>p</tt> does not hold.
--   
--   <pre>
--   'partition' p xs = ('filter' p xs, 'filter' (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <a>group</a> function takes a stream and returns a list of streams
--   such that flattening the resulting list is equal to the argument.
--   Moreover, each stream in the resulting list contains only equal
--   elements. For example, in list notation:
--   
--   <pre>
--   'group' $ 'cycle' "Mississippi" = "M" : "i" : "ss" : "i" : "ss" : "i" : "pp" : "i" : "M" : "i" : ...
--   </pre>
group :: (Foldable f, Eq a) => f a -> [NonEmpty a]

-- | <a>groupBy</a> operates like <a>group</a>, but uses the provided
--   equality predicate instead of <a>==</a>.
groupBy :: Foldable f => (a -> a -> Bool) -> f a -> [NonEmpty a]

-- | <a>groupWith</a> operates like <a>group</a>, but uses the provided
--   projection when comparing for equality
groupWith :: (Foldable f, Eq b) => (a -> b) -> f a -> [NonEmpty a]

-- | <a>groupAllWith</a> operates like <a>groupWith</a>, but sorts the list
--   first so that each equivalence class has, at most, one list in the
--   output
groupAllWith :: (Ord b) => (a -> b) -> [a] -> [NonEmpty a]

-- | <a>group1</a> operates like <a>group</a>, but uses the knowledge that
--   its input is non-empty to produce guaranteed non-empty output.
group1 :: Eq a => NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupBy1</a> is to <a>group1</a> as <a>groupBy</a> is to
--   <a>group</a>.
groupBy1 :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupWith1</a> is to <a>group1</a> as <a>groupWith</a> is to
--   <a>group</a>
groupWith1 :: (Eq b) => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupAllWith1</a> is to <a>groupWith1</a> as <a>groupAllWith</a> is
--   to <a>groupWith</a>
groupAllWith1 :: (Ord b) => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | The <tt>isPrefix</tt> function returns <tt>True</tt> if the first
--   argument is a prefix of the second.
isPrefixOf :: Eq a => [a] -> NonEmpty a -> Bool

-- | The <a>nub</a> function removes duplicate elements from a list. In
--   particular, it keeps only the first occurence of each element. (The
--   name <a>nub</a> means 'essence'.) It is a special case of
--   <a>nubBy</a>, which allows the programmer to supply their own
--   inequality test.
nub :: Eq a => NonEmpty a -> NonEmpty a

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty a

-- | <tt>xs !! n</tt> returns the element of the stream <tt>xs</tt> at
--   index <tt>n</tt>. Note that the head of the stream has index 0.
--   
--   <i>Beware</i>: a negative or out-of-bounds index will cause an error.
(!!) :: NonEmpty a -> Int -> a

-- | The <a>zip</a> function takes two streams and returns a stream of
--   corresponding pairs.
zip :: NonEmpty a -> NonEmpty b -> NonEmpty (a, b)

-- | The <a>zipWith</a> function generalizes <a>zip</a>. Rather than
--   tupling the elements, the elements are combined using the function
--   passed as the first argument.
zipWith :: (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c

-- | The <a>unzip</a> function is the inverse of the <a>zip</a> function.
unzip :: Functor f => f (a, b) -> (f a, f b)

-- | Converts a normal list to a <a>NonEmpty</a> stream.
--   
--   Raises an error if given an empty list.
fromList :: [a] -> NonEmpty a

-- | Convert a stream to a normal list efficiently.
toList :: NonEmpty a -> [a]

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: [a] -> Maybe (NonEmpty a)
xor :: NonEmpty Bool -> Bool
instance GHC.Generics.Constructor Data.List.NonEmpty.C1_0NonEmpty
instance GHC.Generics.Datatype Data.List.NonEmpty.D1NonEmpty
instance GHC.Generics.Generic1 Data.List.NonEmpty.NonEmpty
instance GHC.Generics.Generic (Data.List.NonEmpty.NonEmpty a)
instance Data.Data.Data a => Data.Data.Data (Data.List.NonEmpty.NonEmpty a)
instance GHC.Read.Read a => GHC.Read.Read (Data.List.NonEmpty.NonEmpty a)
instance GHC.Show.Show a => GHC.Show.Show (Data.List.NonEmpty.NonEmpty a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.List.NonEmpty.NonEmpty a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.List.NonEmpty.NonEmpty a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.List.NonEmpty.NonEmpty a)
instance GHC.Exts.IsList (Data.List.NonEmpty.NonEmpty a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.List.NonEmpty.NonEmpty a)
instance Control.Monad.Fix.MonadFix Data.List.NonEmpty.NonEmpty
instance Control.Monad.Zip.MonadZip Data.List.NonEmpty.NonEmpty
instance GHC.Base.Functor Data.List.NonEmpty.NonEmpty
instance GHC.Base.Applicative Data.List.NonEmpty.NonEmpty
instance GHC.Base.Monad Data.List.NonEmpty.NonEmpty
instance Data.Traversable.Traversable Data.List.NonEmpty.NonEmpty
instance Data.Foldable.Foldable Data.List.NonEmpty.NonEmpty


-- | In mathematics, a semigroup is an algebraic structure consisting of a
--   set together with an associative binary operation. A semigroup
--   generalizes a monoid in that there might not exist an identity
--   element. It also (originally) generalized a group (a monoid with all
--   inverses) to a type where every element did not have to have an
--   inverse, thus the name semigroup.
--   
--   The use of <tt>(&lt;&gt;)</tt> in this module conflicts with an
--   operator with the same name that is being exported by Data.Monoid.
--   However, this package re-exports (most of) the contents of
--   Data.Monoid, so to use semigroups and monoids in the same package just
--   
--   <pre>
--   import Data.Semigroup
--   </pre>
module Data.Semigroup
class Semigroup a where (<>) = mappend sconcat (a :| as) = go a as where go b (c : cs) = b <> go c cs go b [] = b stimes y0 x0 | y0 <= 0 = error "stimes: positive multiplier expected" | otherwise = f x0 y0 where f x y | even y = f (x <> x) (y `quot` 2) | y == 1 = x | otherwise = g (x <> x) (pred y `quot` 2) x g x y z | even y = g (x <> x) (y `quot` 2) z | y == 1 = x <> z | otherwise = g (x <> x) (pred y `quot` 2) (x <> z)

-- | An associative operation.
--   
--   <pre>
--   (a <a>&lt;&gt;</a> b) <a>&lt;&gt;</a> c = a <a>&lt;&gt;</a> (b <a>&lt;&gt;</a> c)
--   </pre>
--   
--   If <tt>a</tt> is also a <a>Monoid</a> we further require
--   
--   <pre>
--   (<a>&lt;&gt;</a>) = <a>mappend</a>
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <tt>&lt;&gt;</tt>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = stimesIdempotent</tt> or <tt>stimes =
--   stimesIdempotentMonoid</tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>.
stimesIdempotent :: Integral b => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>mappend x x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   Implemented using <a>stimes</a> and <a>mempty</a>.
--   
--   This is a suitable definition for an <tt>mtimes</tt> member of
--   <a>Monoid</a>.
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a

-- | Use <tt><a>Option</a> (<a>First</a> a)</tt> to get the behavior of
--   <a>First</a> from <tt>Data.Monoid</tt>.
newtype First a
First :: a -> First a
[getFirst] :: First a -> a

-- | Use <tt><a>Option</a> (<a>Last</a> a)</tt> to get the behavior of
--   <a>Last</a> from <tt>Data.Monoid</tt>
newtype Last a
Last :: a -> Last a
[getLast] :: Last a -> a

-- | Provide a Semigroup for an arbitrary Monoid.
newtype WrappedMonoid m
WrapMonoid :: m -> WrappedMonoid m
[unwrapMonoid] :: WrappedMonoid m -> m

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
class Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid. For most types, the default definition
--   for <a>mconcat</a> will be used, but the function is included in the
--   class definition so that an optimized version can be provided for
--   specific types.
mconcat :: Monoid a => [a] -> a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
newtype Dual a :: * -> *
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
newtype Endo a :: * -> *
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
newtype All :: *
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction (<a>||</a>).
newtype Any :: *
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
newtype Sum a :: * -> *
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
newtype Product a :: * -> *
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | <a>Option</a> is effectively <a>Maybe</a> with a better instance of
--   <a>Monoid</a>, built off of an underlying <a>Semigroup</a> instead of
--   an underlying <a>Monoid</a>.
--   
--   Ideally, this type would not exist at all and we would just fix the
--   <a>Monoid</a> instance of <a>Maybe</a>
newtype Option a
Option :: Maybe a -> Option a
[getOption] :: Option a -> Maybe a

-- | Fold an <a>Option</a> case-wise, just like <a>maybe</a>.
option :: b -> (a -> b) -> Option a -> b

-- | This lets you use a difference list of a <a>Semigroup</a> as a
--   <a>Monoid</a>.
diff :: Semigroup m => m -> Endo m

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
cycle1 :: Semigroup m => m -> m

-- | <a>Arg</a> isn't itself a <a>Semigroup</a> in its own right, but it
--   can be placed inside <a>Min</a> and <a>Max</a> to compute an arg min
--   or arg max.
data Arg a b
Arg :: a -> b -> Arg a b
type ArgMin a b = Min (Arg a b)
type ArgMax a b = Max (Arg a b)
instance GHC.Generics.Selector Data.Semigroup.S1_0_0Option
instance GHC.Generics.Constructor Data.Semigroup.C1_0Option
instance GHC.Generics.Datatype Data.Semigroup.D1Option
instance GHC.Generics.Selector Data.Semigroup.S1_0_0WrappedMonoid
instance GHC.Generics.Constructor Data.Semigroup.C1_0WrappedMonoid
instance GHC.Generics.Datatype Data.Semigroup.D1WrappedMonoid
instance GHC.Generics.Selector Data.Semigroup.S1_0_0Last
instance GHC.Generics.Constructor Data.Semigroup.C1_0Last
instance GHC.Generics.Datatype Data.Semigroup.D1Last
instance GHC.Generics.Selector Data.Semigroup.S1_0_0First
instance GHC.Generics.Constructor Data.Semigroup.C1_0First
instance GHC.Generics.Datatype Data.Semigroup.D1First
instance GHC.Generics.Constructor Data.Semigroup.C1_0Arg
instance GHC.Generics.Datatype Data.Semigroup.D1Arg
instance GHC.Generics.Selector Data.Semigroup.S1_0_0Max
instance GHC.Generics.Constructor Data.Semigroup.C1_0Max
instance GHC.Generics.Datatype Data.Semigroup.D1Max
instance GHC.Generics.Selector Data.Semigroup.S1_0_0Min
instance GHC.Generics.Constructor Data.Semigroup.C1_0Min
instance GHC.Generics.Datatype Data.Semigroup.D1Min
instance GHC.Generics.Generic1 Data.Semigroup.Option
instance GHC.Generics.Generic (Data.Semigroup.Option a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Option a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Option a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Option a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Option a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Option a)
instance GHC.Generics.Generic1 Data.Semigroup.WrappedMonoid
instance GHC.Generics.Generic (Data.Semigroup.WrappedMonoid m)
instance Data.Data.Data m => Data.Data.Data (Data.Semigroup.WrappedMonoid m)
instance GHC.Read.Read m => GHC.Read.Read (Data.Semigroup.WrappedMonoid m)
instance GHC.Show.Show m => GHC.Show.Show (Data.Semigroup.WrappedMonoid m)
instance GHC.Classes.Ord m => GHC.Classes.Ord (Data.Semigroup.WrappedMonoid m)
instance GHC.Classes.Eq m => GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
instance GHC.Generics.Generic1 Data.Semigroup.Last
instance GHC.Generics.Generic (Data.Semigroup.Last a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Last a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Last a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Last a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Last a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Last a)
instance GHC.Generics.Generic1 Data.Semigroup.First
instance GHC.Generics.Generic (Data.Semigroup.First a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.First a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.First a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.First a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.First a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.First a)
instance GHC.Generics.Generic1 (Data.Semigroup.Arg a)
instance GHC.Generics.Generic (Data.Semigroup.Arg a b)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Semigroup.Arg a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Semigroup.Arg a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Semigroup.Arg a b)
instance GHC.Generics.Generic1 Data.Semigroup.Max
instance GHC.Generics.Generic (Data.Semigroup.Max a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Max a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Max a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Max a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Max a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Max a)
instance GHC.Generics.Generic1 Data.Semigroup.Min
instance GHC.Generics.Generic (Data.Semigroup.Min a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Min a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Min a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Min a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Min a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Min a)
instance Data.Semigroup.Semigroup ()
instance Data.Semigroup.Semigroup b => Data.Semigroup.Semigroup (a -> b)
instance Data.Semigroup.Semigroup [a]
instance Data.Semigroup.Semigroup a => Data.Semigroup.Semigroup (GHC.Base.Maybe a)
instance Data.Semigroup.Semigroup (Data.Either.Either a b)
instance (Data.Semigroup.Semigroup a, Data.Semigroup.Semigroup b) => Data.Semigroup.Semigroup (a, b)
instance (Data.Semigroup.Semigroup a, Data.Semigroup.Semigroup b, Data.Semigroup.Semigroup c) => Data.Semigroup.Semigroup (a, b, c)
instance (Data.Semigroup.Semigroup a, Data.Semigroup.Semigroup b, Data.Semigroup.Semigroup c, Data.Semigroup.Semigroup d) => Data.Semigroup.Semigroup (a, b, c, d)
instance (Data.Semigroup.Semigroup a, Data.Semigroup.Semigroup b, Data.Semigroup.Semigroup c, Data.Semigroup.Semigroup d, Data.Semigroup.Semigroup e) => Data.Semigroup.Semigroup (a, b, c, d, e)
instance Data.Semigroup.Semigroup GHC.Types.Ordering
instance Data.Semigroup.Semigroup a => Data.Semigroup.Semigroup (Data.Monoid.Dual a)
instance Data.Semigroup.Semigroup (Data.Monoid.Endo a)
instance Data.Semigroup.Semigroup Data.Monoid.All
instance Data.Semigroup.Semigroup Data.Monoid.Any
instance GHC.Num.Num a => Data.Semigroup.Semigroup (Data.Monoid.Sum a)
instance GHC.Num.Num a => Data.Semigroup.Semigroup (Data.Monoid.Product a)
instance Data.Semigroup.Semigroup a => Data.Semigroup.Semigroup (Control.Applicative.Const a b)
instance Data.Semigroup.Semigroup (Data.Monoid.First a)
instance Data.Semigroup.Semigroup (Data.Monoid.Last a)
instance GHC.Base.Alternative f => Data.Semigroup.Semigroup (Data.Monoid.Alt f a)
instance Data.Semigroup.Semigroup Data.Void.Void
instance Data.Semigroup.Semigroup (Data.List.NonEmpty.NonEmpty a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Min a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Min a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Semigroup.Min a)
instance GHC.Classes.Ord a => Data.Semigroup.Semigroup (Data.Semigroup.Min a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Min a)
instance GHC.Base.Functor Data.Semigroup.Min
instance Data.Foldable.Foldable Data.Semigroup.Min
instance Data.Traversable.Traversable Data.Semigroup.Min
instance GHC.Base.Applicative Data.Semigroup.Min
instance GHC.Base.Monad Data.Semigroup.Min
instance Control.Monad.Fix.MonadFix Data.Semigroup.Min
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Min a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Min a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Max a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Max a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Semigroup.Max a)
instance GHC.Classes.Ord a => Data.Semigroup.Semigroup (Data.Semigroup.Max a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Max a)
instance GHC.Base.Functor Data.Semigroup.Max
instance Data.Foldable.Foldable Data.Semigroup.Max
instance Data.Traversable.Traversable Data.Semigroup.Max
instance GHC.Base.Applicative Data.Semigroup.Max
instance GHC.Base.Monad Data.Semigroup.Max
instance Control.Monad.Fix.MonadFix Data.Semigroup.Max
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Max a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Max a)
instance GHC.Base.Functor (Data.Semigroup.Arg a)
instance Data.Foldable.Foldable (Data.Semigroup.Arg a)
instance Data.Traversable.Traversable (Data.Semigroup.Arg a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Arg a b)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Arg a b)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Data.Semigroup.Arg a b)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (Data.Semigroup.Arg a b)
instance Data.Bifunctor.Bifunctor Data.Semigroup.Arg
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.First a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.First a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Semigroup.First a)
instance Data.Semigroup.Semigroup (Data.Semigroup.First a)
instance GHC.Base.Functor Data.Semigroup.First
instance Data.Foldable.Foldable Data.Semigroup.First
instance Data.Traversable.Traversable Data.Semigroup.First
instance GHC.Base.Applicative Data.Semigroup.First
instance GHC.Base.Monad Data.Semigroup.First
instance Control.Monad.Fix.MonadFix Data.Semigroup.First
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.First a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Last a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Last a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Semigroup.Last a)
instance Data.Semigroup.Semigroup (Data.Semigroup.Last a)
instance GHC.Base.Functor Data.Semigroup.Last
instance Data.Foldable.Foldable Data.Semigroup.Last
instance Data.Traversable.Traversable Data.Semigroup.Last
instance GHC.Base.Applicative Data.Semigroup.Last
instance GHC.Base.Monad Data.Semigroup.Last
instance Control.Monad.Fix.MonadFix Data.Semigroup.Last
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Last a)
instance Data.Semigroup.Semigroup Data.Binary.Builder.Base.Builder
instance Data.Semigroup.Semigroup Data.ByteString.Internal.ByteString
instance Data.Semigroup.Semigroup Data.ByteString.Lazy.Internal.ByteString
instance Data.Semigroup.Semigroup Data.ByteString.Builder.Internal.Builder
instance Data.Semigroup.Semigroup Data.ByteString.Short.Internal.ShortByteString
instance Data.Semigroup.Semigroup Data.Text.Internal.Text
instance Data.Semigroup.Semigroup Data.Text.Internal.Lazy.Text
instance Data.Semigroup.Semigroup Data.Text.Internal.Builder.Builder
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Semigroup.Semigroup (Data.HashMap.Base.HashMap k a)
instance (Data.Hashable.Class.Hashable a, GHC.Classes.Eq a) => Data.Semigroup.Semigroup (Data.HashSet.HashSet a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Semigroup.WrappedMonoid a)
instance GHC.Base.Monoid m => Data.Semigroup.Semigroup (Data.Semigroup.WrappedMonoid m)
instance GHC.Base.Monoid m => GHC.Base.Monoid (Data.Semigroup.WrappedMonoid m)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.WrappedMonoid a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.WrappedMonoid a)
instance Control.DeepSeq.NFData m => Control.DeepSeq.NFData (Data.Semigroup.WrappedMonoid m)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Semigroup.Option a)
instance GHC.Base.Functor Data.Semigroup.Option
instance GHC.Base.Applicative Data.Semigroup.Option
instance GHC.Base.Monad Data.Semigroup.Option
instance GHC.Base.Alternative Data.Semigroup.Option
instance GHC.Base.MonadPlus Data.Semigroup.Option
instance Control.Monad.Fix.MonadFix Data.Semigroup.Option
instance Data.Foldable.Foldable Data.Semigroup.Option
instance Data.Traversable.Traversable Data.Semigroup.Option
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Option a)
instance Data.Semigroup.Semigroup a => Data.Semigroup.Semigroup (Data.Semigroup.Option a)
instance Data.Semigroup.Semigroup a => GHC.Base.Monoid (Data.Semigroup.Option a)
instance Data.Semigroup.Semigroup (Data.Sequence.Seq a)
instance Data.Semigroup.Semigroup Data.IntSet.Base.IntSet
instance GHC.Classes.Ord a => Data.Semigroup.Semigroup (Data.Set.Base.Set a)
instance Data.Semigroup.Semigroup (Data.IntMap.Base.IntMap v)
instance GHC.Classes.Ord k => Data.Semigroup.Semigroup (Data.Map.Base.Map k v)
instance Data.Semigroup.Semigroup a => Data.Semigroup.Semigroup (Data.Functor.Identity.Identity a)
instance forall (k :: BOX) (s :: k). Data.Semigroup.Semigroup (Data.Proxy.Proxy s)
instance forall (k :: BOX) (s :: k) a. Data.Semigroup.Semigroup a => Data.Semigroup.Semigroup (Data.Tagged.Tagged s a)


-- | This module provides generic deriving tools for monoids and semigroups
--   for product-like structures.
module Data.Semigroup.Generic
class GSemigroup f

-- | Generically generate a <a>Semigroup</a> (<a>&lt;&gt;</a>) operation
--   for any type implementing <a>Generic</a>. This operation will append
--   two values by point-wise appending their component fields. It is only
--   defined for product types.
--   
--   <pre>
--   <a>gmappend</a> a (<a>gmappend</a> b c) = <a>gmappend</a> (<a>gmappend</a> a b) c
--   </pre>
gmappend :: (Generic a, GSemigroup (Rep a)) => a -> a -> a
class GSemigroup f => GMonoid f

-- | Generically generate a <a>Monoid</a> <a>mempty</a> for any
--   product-like type implementing <a>Generic</a>.
--   
--   It is only defined for product types.
--   
--   <pre>
--   <a>gmappend</a> <a>gmempty</a> a = a = <a>gmappend</a> a <a>gmempty</a>
--   </pre>
gmempty :: (Generic a, GMonoid (Rep a)) => a
instance Data.Semigroup.Generic.GSemigroup GHC.Generics.U1
instance Data.Semigroup.Generic.GSemigroup GHC.Generics.V1
instance Data.Semigroup.Semigroup a => Data.Semigroup.Generic.GSemigroup (GHC.Generics.K1 i a)
instance Data.Semigroup.Generic.GSemigroup f => Data.Semigroup.Generic.GSemigroup (GHC.Generics.M1 i c f)
instance (Data.Semigroup.Generic.GSemigroup f, Data.Semigroup.Generic.GSemigroup g) => Data.Semigroup.Generic.GSemigroup (f GHC.Generics.:*: g)
instance Data.Semigroup.Generic.GMonoid GHC.Generics.U1
instance (Data.Semigroup.Semigroup a, GHC.Base.Monoid a) => Data.Semigroup.Generic.GMonoid (GHC.Generics.K1 i a)
instance Data.Semigroup.Generic.GMonoid f => Data.Semigroup.Generic.GMonoid (GHC.Generics.M1 i c f)
instance (Data.Semigroup.Generic.GMonoid f, Data.Semigroup.Generic.GMonoid g) => Data.Semigroup.Generic.GMonoid (f GHC.Generics.:*: g)

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extensible, type-safe, dependent unions.
--   
--   Unions over types of kind 'k -&gt; *'
@package dependent-open-union
@version 0.1.0.0


-- | This implementation relies on _closed_ type families added to GHC 7.8.
--   It has NO overlapping instances and NO Typeable. Alas, the absence of
--   Typeable means the projections and injections generally take linear
--   time. The code illustrate how to use closed type families to
--   disambiguate otherwise overlapping instances.
--   
--   The data constructors of Union are not exported. Essentially, the
--   nested Either data type.
--   
--   Using <a>http://okmij.org/ftp/Haskell/extensible/OpenUnion41.hs</a> as
--   a starting point.
module Data.Dependent.OpenUnion
data Union r v
class (Member' t r (FindElem t r)) => Member (t :: k -> *) (r :: [k -> *]) where type family Remove t r :: [k -> *]
weaken :: Member t r => Proxy t -> Union (Remove t r) v -> Union r v
inj :: Member t r => t v -> Union r v
prj :: Member t r => Union r v -> Either (Union (Remove t r) v) (t v)
hoistU :: (Member t r, Member f r', Remove t r ~ Remove f r') => (t a -> f a) -> Union r a -> Union r' a
instance forall (k :: BOX) (t :: k -> *) (r :: [k -> *]). Data.Dependent.OpenUnion.Member' t r (Data.Dependent.OpenUnion.FindElem t r) => Data.Dependent.OpenUnion.Member t r
instance GHC.Base.Functor (Data.Dependent.OpenUnion.Union '[])
instance (GHC.Base.Functor t, GHC.Base.Functor (Data.Dependent.OpenUnion.Union r)) => GHC.Base.Functor (Data.Dependent.OpenUnion.Union (t : r))
instance Data.GADT.Compare.GEq (Data.Dependent.OpenUnion.Union '[])
instance forall (k :: BOX) (f :: k -> *) (r :: [k -> *]). (Data.GADT.Compare.GEq f, Data.GADT.Compare.GEq (Data.Dependent.OpenUnion.Union r)) => Data.GADT.Compare.GEq (Data.Dependent.OpenUnion.Union (f : r))
instance Data.GADT.Compare.GCompare (Data.Dependent.OpenUnion.Union '[])
instance forall (k :: BOX) (f :: k -> *) (r :: [k -> *]). (Data.GADT.Compare.GCompare f, Data.GADT.Compare.GCompare (Data.Dependent.OpenUnion.Union r)) => Data.GADT.Compare.GCompare (Data.Dependent.OpenUnion.Union (f : r))
instance forall (k :: BOX) (t :: k -> *) (r' :: [k -> *]). Data.Dependent.OpenUnion.Member' t (t : r') 'Data.Dependent.OpenUnion.Z
instance forall (k :: BOX) (t :: k -> *) (t' :: k -> *) (r' :: [k -> *]) (n :: Data.Dependent.OpenUnion.Nat). Data.Dependent.OpenUnion.Member' t r' n => Data.Dependent.OpenUnion.Member' t (t' : r') ('Data.Dependent.OpenUnion.S n)

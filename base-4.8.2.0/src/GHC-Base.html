<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Base.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>The overall structure of the GHC Prelude is a bit tricky.
<a name="line-3"></a>
<a name="line-4"></a>  a) We want to avoid "orphan modules", i.e. ones with instance
<a name="line-5"></a>        decls that don't belong either to a tycon or a class
<a name="line-6"></a>        defined in the same module
<a name="line-7"></a>
<a name="line-8"></a>  b) We want to avoid giant modules
<a name="line-9"></a>
<a name="line-10"></a>So the rough structure is as follows, in (linearised) dependency order
<a name="line-11"></a>
<a name="line-12"></a>
<a name="line-13"></a>GHC.Prim        Has no implementation.  It defines built-in things, and
<a name="line-14"></a>                by importing it you bring them into scope.
<a name="line-15"></a>                The source file is GHC.Prim.hi-boot, which is just
<a name="line-16"></a>                copied to make GHC.Prim.hi
<a name="line-17"></a>
<a name="line-18"></a>GHC.Base        Classes: Eq, Ord, Functor, Monad
<a name="line-19"></a>                Types:   list, (), Int, Bool, Ordering, Char, String
<a name="line-20"></a>
<a name="line-21"></a>Data.Tuple      Types: tuples, plus instances for GHC.Base classes
<a name="line-22"></a>
<a name="line-23"></a>GHC.Show        Class: Show, plus instances for GHC.Base/GHC.Tup types
<a name="line-24"></a>
<a name="line-25"></a>GHC.Enum        Class: Enum,  plus instances for GHC.Base/GHC.Tup types
<a name="line-26"></a>
<a name="line-27"></a>Data.Maybe      Type: Maybe, plus instances for GHC.Base classes
<a name="line-28"></a>
<a name="line-29"></a>GHC.List        List functions
<a name="line-30"></a>
<a name="line-31"></a>GHC.Num         Class: Num, plus instances for Int
<a name="line-32"></a>                Type:  Integer, plus instances for all classes so far (Eq, Ord, Num, Show)
<a name="line-33"></a>
<a name="line-34"></a>                Integer is needed here because it is mentioned in the signature
<a name="line-35"></a>                of 'fromInteger' in class Num
<a name="line-36"></a>
<a name="line-37"></a>GHC.Real        Classes: Real, Integral, Fractional, RealFrac
<a name="line-38"></a>                         plus instances for Int, Integer
<a name="line-39"></a>                Types:  Ratio, Rational
<a name="line-40"></a>                        plus intances for classes so far
<a name="line-41"></a>
<a name="line-42"></a>                Rational is needed here because it is mentioned in the signature
<a name="line-43"></a>                of 'toRational' in class Real
<a name="line-44"></a>
<a name="line-45"></a>GHC.ST  The ST monad, instances and a few helper functions
<a name="line-46"></a>
<a name="line-47"></a>Ix              Classes: Ix, plus instances for Int, Bool, Char, Integer, Ordering, tuples
<a name="line-48"></a>
<a name="line-49"></a>GHC.Arr         Types: Array, MutableArray, MutableVar
<a name="line-50"></a>
<a name="line-51"></a>                Arrays are used by a function in GHC.Float
<a name="line-52"></a>
<a name="line-53"></a>GHC.Float       Classes: Floating, RealFloat
<a name="line-54"></a>                Types:   Float, Double, plus instances of all classes so far
<a name="line-55"></a>
<a name="line-56"></a>                This module contains everything to do with floating point.
<a name="line-57"></a>                It is a big module (900 lines)
<a name="line-58"></a>                With a bit of luck, many modules can be compiled without ever reading GHC.Float.hi
<a name="line-59"></a>
<a name="line-60"></a>
<a name="line-61"></a>Other Prelude modules are much easier with fewer complex dependencies.
<a name="line-62"></a>-}</span>
<a name="line-63"></a>
<a name="line-64"></a><span class='hs-comment'>{-# LANGUAGE Unsafe #-}</span>
<a name="line-65"></a><span class='hs-comment'>{-# LANGUAGE CPP
<a name="line-66"></a>           , NoImplicitPrelude
<a name="line-67"></a>           , BangPatterns
<a name="line-68"></a>           , ExplicitForAll
<a name="line-69"></a>           , MagicHash
<a name="line-70"></a>           , UnboxedTuples
<a name="line-71"></a>           , ExistentialQuantification
<a name="line-72"></a>           , RankNTypes
<a name="line-73"></a>  #-}</span>
<a name="line-74"></a><span class='hs-comment'>-- -fno-warn-orphans is needed for things like:</span>
<a name="line-75"></a><span class='hs-comment'>-- Orphan rule: "x# -# x#" ALWAYS forall x# :: Int# -# x# x# = 0</span>
<a name="line-76"></a><span class='hs-comment'>{-# OPTIONS_GHC -fno-warn-orphans #-}</span>
<a name="line-77"></a><span class='hs-comment'>{-# OPTIONS_HADDOCK hide #-}</span>
<a name="line-78"></a>
<a name="line-79"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-80"></a><span class='hs-comment'>-- |</span>
<a name="line-81"></a><span class='hs-comment'>-- Module      :  GHC.Base</span>
<a name="line-82"></a><span class='hs-comment'>-- Copyright   :  (c) The University of Glasgow, 1992-2002</span>
<a name="line-83"></a><span class='hs-comment'>-- License     :  see libraries/base/LICENSE</span>
<a name="line-84"></a><span class='hs-comment'>--</span>
<a name="line-85"></a><span class='hs-comment'>-- Maintainer  :  cvs-ghc@haskell.org</span>
<a name="line-86"></a><span class='hs-comment'>-- Stability   :  internal</span>
<a name="line-87"></a><span class='hs-comment'>-- Portability :  non-portable (GHC extensions)</span>
<a name="line-88"></a><span class='hs-comment'>--</span>
<a name="line-89"></a><span class='hs-comment'>-- Basic data types and classes.</span>
<a name="line-90"></a><span class='hs-comment'>--</span>
<a name="line-91"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-92"></a>
<a name="line-93"></a><span class='hs-cpp'>#include "MachDeps.h"</span>
<a name="line-94"></a>
<a name="line-95"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Base</span>
<a name="line-96"></a>        <span class='hs-layout'>(</span>
<a name="line-97"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Base</span><span class='hs-layout'>,</span>
<a name="line-98"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Classes</span><span class='hs-layout'>,</span>
<a name="line-99"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>CString</span><span class='hs-layout'>,</span>
<a name="line-100"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Magic</span><span class='hs-layout'>,</span>
<a name="line-101"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Types</span><span class='hs-layout'>,</span>
<a name="line-102"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Prim</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Re-export GHC.Prim and [boot] GHC.Err,</span>
<a name="line-103"></a>                                <span class='hs-comment'>-- to avoid lots of people having to</span>
<a name="line-104"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Err</span>          <span class='hs-comment'>-- import it explicitly</span>
<a name="line-105"></a>  <span class='hs-layout'>)</span>
<a name="line-106"></a>        <span class='hs-keyword'>where</span>
<a name="line-107"></a>
<a name="line-108"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Types</span>
<a name="line-109"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Classes</span>
<a name="line-110"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>CString</span>
<a name="line-111"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Magic</span>
<a name="line-112"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Prim</span>
<a name="line-113"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Err</span>
<a name="line-114"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-varid'>failIO</span><span class='hs-layout'>)</span>
<a name="line-115"></a>
<a name="line-116"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Tuple</span> <span class='hs-conid'>()</span>     <span class='hs-comment'>-- Note [Depend on GHC.Tuple]</span>
<a name="line-117"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Integer</span> <span class='hs-conid'>()</span>   <span class='hs-comment'>-- Note [Depend on GHC.Integer]</span>
<a name="line-118"></a>
<a name="line-119"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>9</span>  <span class='hs-varop'>.</span>
<a name="line-120"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>5</span>  <span class='hs-varop'>++</span>
<a name="line-121"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span>  <span class='hs-varop'>&lt;$</span>
<a name="line-122"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>1</span>  <span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>,</span> <span class='hs-varop'>&gt;&gt;=</span>
<a name="line-123"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>1</span>  <span class='hs-varop'>=&lt;&lt;</span>
<a name="line-124"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>0</span>  <span class='hs-varop'>$</span><span class='hs-layout'>,</span> <span class='hs-varop'>$!</span>
<a name="line-125"></a>
<a name="line-126"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span> <span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>,</span> <span class='hs-varop'>&lt;*</span><span class='hs-layout'>,</span> <span class='hs-varop'>*&gt;</span><span class='hs-layout'>,</span> <span class='hs-varop'>&lt;**&gt;</span>
<a name="line-127"></a>
<a name="line-128"></a><span class='hs-keyword'>default</span> <span class='hs-conid'>()</span>              <span class='hs-comment'>-- Double isn't available yet</span>
<a name="line-129"></a>
<a name="line-130"></a><span class='hs-comment'>{-
<a name="line-131"></a>Note [Depend on GHC.Integer]
<a name="line-132"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-133"></a>The Integer type is special because TidyPgm uses
<a name="line-134"></a>GHC.Integer.Type.mkInteger to construct Integer literal values
<a name="line-135"></a>Currently it reads the interface file whether or not the current
<a name="line-136"></a>module *has* any Integer literals, so it's important that
<a name="line-137"></a>GHC.Integer.Type (in patckage integer-gmp or integer-simple) is
<a name="line-138"></a>compiled before any other module.  (There's a hack in GHC to disable
<a name="line-139"></a>this for packages ghc-prim, integer-gmp, integer-simple, which aren't
<a name="line-140"></a>allowed to contain any Integer literals.)
<a name="line-141"></a>
<a name="line-142"></a>Likewise we implicitly need Integer when deriving things like Eq
<a name="line-143"></a>instances.
<a name="line-144"></a>
<a name="line-145"></a>The danger is that if the build system doesn't know about the dependency
<a name="line-146"></a>on Integer, it'll compile some base module before GHC.Integer.Type,
<a name="line-147"></a>resulting in:
<a name="line-148"></a>  Failed to load interface for ‘GHC.Integer.Type’
<a name="line-149"></a>    There are files missing in the ‘integer-gmp’ package,
<a name="line-150"></a>
<a name="line-151"></a>Bottom line: we make GHC.Base depend on GHC.Integer; and everything
<a name="line-152"></a>else either depends on GHC.Base, or does not have NoImplicitPrelude
<a name="line-153"></a>(and hence depends on Prelude).
<a name="line-154"></a>
<a name="line-155"></a>Note [Depend on GHC.Tuple]
<a name="line-156"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-157"></a>Similarly, tuple syntax (or ()) creates an implicit dependency on
<a name="line-158"></a>GHC.Tuple, so we use the same rule as for Integer --- see Note [Depend on
<a name="line-159"></a>GHC.Integer] --- to explain this to the build system.  We make GHC.Base
<a name="line-160"></a>depend on GHC.Tuple, and everything else depends on GHC.Base or Prelude.
<a name="line-161"></a>-}</span>
<a name="line-162"></a>
<a name="line-163"></a><span class='hs-cpp'>#if 0</span>
<a name="line-164"></a><a name="Bool"></a><span class='hs-comment'>-- for use when compiling GHC.Base itself doesn't work</span>
<a name="line-165"></a><a name="Bool"></a><span class='hs-keyword'>data</span>  <span class='hs-conid'>Bool</span>  <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>False</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span>
<a name="line-166"></a><a name="Ordering"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Ordering</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EQ</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GT</span>
<a name="line-167"></a><a name="Char"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Char</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-conid'>Char</span><span class='hs-cpp'>#</span>
<a name="line-168"></a><a name="String"></a><span class='hs-keyword'>type</span>  <span class='hs-conid'>String</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-169"></a><a name="Int"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-170"></a><a name="()"></a><span class='hs-keyword'>data</span>  <span class='hs-conid'>()</span>  <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>()</span>
<a name="line-171"></a><a name="%5b%5d"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MkNil</span>
<a name="line-172"></a>
<a name="line-173"></a><a name="not"></a><span class='hs-definition'>not</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-174"></a><a name="&&"></a><span class='hs-layout'>(</span><span class='hs-varop'>&amp;&amp;</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-175"></a><a name="otherwise"></a><span class='hs-definition'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-176"></a>
<a name="line-177"></a><a name="build"></a><span class='hs-definition'>build</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"urk"</span>
<a name="line-178"></a><a name="foldr"></a><span class='hs-definition'>foldr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"urk"</span>
<a name="line-179"></a><span class='hs-cpp'>#endif</span>
<a name="line-180"></a>
<a name="line-181"></a><a name="Maybe"></a><span class='hs-comment'>-- | The 'Maybe' type encapsulates an optional value.  A value of type</span>
<a name="line-182"></a><a name="Maybe"></a><span class='hs-comment'>-- @'Maybe' a@ either contains a value of type @a@ (represented as @'Just' a@),</span>
<a name="line-183"></a><a name="Maybe"></a><span class='hs-comment'>-- or it is empty (represented as 'Nothing').  Using 'Maybe' is a good way to</span>
<a name="line-184"></a><a name="Maybe"></a><span class='hs-comment'>-- deal with errors or exceptional cases without resorting to drastic</span>
<a name="line-185"></a><a name="Maybe"></a><span class='hs-comment'>-- measures such as 'error'.</span>
<a name="line-186"></a><a name="Maybe"></a><span class='hs-comment'>--</span>
<a name="line-187"></a><a name="Maybe"></a><span class='hs-comment'>-- The 'Maybe' type is also a monad.  It is a simple kind of error</span>
<a name="line-188"></a><a name="Maybe"></a><span class='hs-comment'>-- monad, where all errors are represented by 'Nothing'.  A richer</span>
<a name="line-189"></a><a name="Maybe"></a><span class='hs-comment'>-- error monad can be built using the 'Data.Either.Either' type.</span>
<a name="line-190"></a><a name="Maybe"></a><span class='hs-comment'>--</span>
<a name="line-191"></a><a name="Maybe"></a><span class='hs-keyword'>data</span>  <span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span>  <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>a</span>
<a name="line-192"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span><span class='hs-layout'>)</span>
<a name="line-193"></a>
<a name="line-194"></a><span class='hs-comment'>-- | The class of monoids (types with an associative binary operation that</span>
<a name="line-195"></a><span class='hs-comment'>-- has an identity).  Instances should satisfy the following laws:</span>
<a name="line-196"></a><span class='hs-comment'>--</span>
<a name="line-197"></a><span class='hs-comment'>--  * @mappend mempty x = x@</span>
<a name="line-198"></a><span class='hs-comment'>--</span>
<a name="line-199"></a><span class='hs-comment'>--  * @mappend x mempty = x@</span>
<a name="line-200"></a><span class='hs-comment'>--</span>
<a name="line-201"></a><span class='hs-comment'>--  * @mappend x (mappend y z) = mappend (mappend x y) z@</span>
<a name="line-202"></a><span class='hs-comment'>--</span>
<a name="line-203"></a><span class='hs-comment'>--  * @mconcat = 'foldr' mappend mempty@</span>
<a name="line-204"></a><span class='hs-comment'>--</span>
<a name="line-205"></a><span class='hs-comment'>-- The method names refer to the monoid of lists under concatenation,</span>
<a name="line-206"></a><span class='hs-comment'>-- but there are many other instances.</span>
<a name="line-207"></a><span class='hs-comment'>--</span>
<a name="line-208"></a><span class='hs-comment'>-- Some types can be viewed as a monoid in more than one way,</span>
<a name="line-209"></a><span class='hs-comment'>-- e.g. both addition and multiplication on numbers.</span>
<a name="line-210"></a><span class='hs-comment'>-- In such cases we often define @newtype@s and make those instances</span>
<a name="line-211"></a><span class='hs-comment'>-- of 'Monoid', e.g. 'Sum' and 'Product'.</span>
<a name="line-212"></a>
<a name="line-213"></a><a name="Monoid"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<a name="line-214"></a>        <span class='hs-varid'>mempty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span>
<a name="line-215"></a>        <span class='hs-comment'>-- ^ Identity of 'mappend'</span>
<a name="line-216"></a>        <span class='hs-varid'>mappend</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-217"></a>        <span class='hs-comment'>-- ^ An associative operation</span>
<a name="line-218"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-219"></a>
<a name="line-220"></a>        <span class='hs-comment'>-- ^ Fold a list using the monoid.</span>
<a name="line-221"></a>        <span class='hs-comment'>-- For most types, the default definition for 'mconcat' will be</span>
<a name="line-222"></a>        <span class='hs-comment'>-- used, but the function is included in the class definition so</span>
<a name="line-223"></a>        <span class='hs-comment'>-- that an optimized version can be provided for specific types.</span>
<a name="line-224"></a>
<a name="line-225"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mappend</span> <span class='hs-varid'>mempty</span>
<a name="line-226"></a>
<a name="line-227"></a><a name="instance%20Monoid%20%5ba%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>where</span>
<a name="line-228"></a>        <span class='hs-comment'>{-# INLINE mempty #-}</span>
<a name="line-229"></a>        <span class='hs-varid'>mempty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-230"></a>        <span class='hs-comment'>{-# INLINE mappend #-}</span>
<a name="line-231"></a>        <span class='hs-varid'>mappend</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span>
<a name="line-232"></a>        <span class='hs-comment'>{-# INLINE mconcat #-}</span>
<a name="line-233"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-varid'>xss</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xss</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>]</span>
<a name="line-234"></a><span class='hs-comment'>-- See Note: [List comprehensions and inlining]</span>
<a name="line-235"></a>
<a name="line-236"></a><span class='hs-comment'>{-
<a name="line-237"></a>Note: [List comprehensions and inlining]
<a name="line-238"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-239"></a>The list monad operations are traditionally described in terms of concatMap:
<a name="line-240"></a>
<a name="line-241"></a>xs &gt;&gt;= f = concatMap f xs
<a name="line-242"></a>
<a name="line-243"></a>Similarly, mconcat for lists is just concat. Here in Base, however, we don't
<a name="line-244"></a>have concatMap, and we'll refrain from adding it here so it won't have to be
<a name="line-245"></a>hidden in imports. Instead, we use GHC's list comprehension desugaring
<a name="line-246"></a>mechanism to define mconcat and the Applicative and Monad instances for lists.
<a name="line-247"></a>We mark them INLINE because the inliner is not generally too keen to inline
<a name="line-248"></a>build forms such as the ones these desugar to without our insistence.  Defining
<a name="line-249"></a>these using list comprehensions instead of foldr has an additional potential
<a name="line-250"></a>benefit, as described in compiler/deSugar/DsListComp.lhs: if optimizations
<a name="line-251"></a>needed to make foldr/build forms efficient are turned off, we'll get reasonably
<a name="line-252"></a>efficient translations anyway.
<a name="line-253"></a>-}</span>
<a name="line-254"></a>
<a name="line-255"></a><a name="instance%20Monoid%20(a%20-%3e%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-256"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-257"></a>        <span class='hs-varid'>mappend</span> <span class='hs-varid'>f</span> <span class='hs-varid'>g</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>g</span> <span class='hs-varid'>x</span>
<a name="line-258"></a>
<a name="line-259"></a><a name="instance%20Monoid%20()"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>where</span>
<a name="line-260"></a>        <span class='hs-comment'>-- Should it be strict?</span>
<a name="line-261"></a>        <span class='hs-varid'>mempty</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-262"></a>        <span class='hs-keyword'>_</span> <span class='hs-varop'>`mappend`</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-263"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-264"></a>
<a name="line-265"></a><a name="instance%20Monoid%20(a,b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-266"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-267"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a1</span><span class='hs-layout'>,</span><span class='hs-varid'>b1</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mappend`</span> <span class='hs-layout'>(</span><span class='hs-varid'>a2</span><span class='hs-layout'>,</span><span class='hs-varid'>b2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-268"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>a2</span><span class='hs-layout'>,</span> <span class='hs-varid'>b1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>b2</span><span class='hs-layout'>)</span>
<a name="line-269"></a>
<a name="line-270"></a><a name="instance%20Monoid%20(a,b,c)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-271"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-272"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a1</span><span class='hs-layout'>,</span><span class='hs-varid'>b1</span><span class='hs-layout'>,</span><span class='hs-varid'>c1</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mappend`</span> <span class='hs-layout'>(</span><span class='hs-varid'>a2</span><span class='hs-layout'>,</span><span class='hs-varid'>b2</span><span class='hs-layout'>,</span><span class='hs-varid'>c2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-273"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>a2</span><span class='hs-layout'>,</span> <span class='hs-varid'>b1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>b2</span><span class='hs-layout'>,</span> <span class='hs-varid'>c1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>c2</span><span class='hs-layout'>)</span>
<a name="line-274"></a>
<a name="line-275"></a><a name="instance%20Monoid%20(a,b,c,d)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-276"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-277"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a1</span><span class='hs-layout'>,</span><span class='hs-varid'>b1</span><span class='hs-layout'>,</span><span class='hs-varid'>c1</span><span class='hs-layout'>,</span><span class='hs-varid'>d1</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mappend`</span> <span class='hs-layout'>(</span><span class='hs-varid'>a2</span><span class='hs-layout'>,</span><span class='hs-varid'>b2</span><span class='hs-layout'>,</span><span class='hs-varid'>c2</span><span class='hs-layout'>,</span><span class='hs-varid'>d2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-278"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>a2</span><span class='hs-layout'>,</span> <span class='hs-varid'>b1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>b2</span><span class='hs-layout'>,</span>
<a name="line-279"></a>                 <span class='hs-varid'>c1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>c2</span><span class='hs-layout'>,</span> <span class='hs-varid'>d1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>d2</span><span class='hs-layout'>)</span>
<a name="line-280"></a>
<a name="line-281"></a><a name="instance%20Monoid%20(a,b,c,d,e)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<a name="line-282"></a>                <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-283"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-284"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a1</span><span class='hs-layout'>,</span><span class='hs-varid'>b1</span><span class='hs-layout'>,</span><span class='hs-varid'>c1</span><span class='hs-layout'>,</span><span class='hs-varid'>d1</span><span class='hs-layout'>,</span><span class='hs-varid'>e1</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mappend`</span> <span class='hs-layout'>(</span><span class='hs-varid'>a2</span><span class='hs-layout'>,</span><span class='hs-varid'>b2</span><span class='hs-layout'>,</span><span class='hs-varid'>c2</span><span class='hs-layout'>,</span><span class='hs-varid'>d2</span><span class='hs-layout'>,</span><span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-285"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>a2</span><span class='hs-layout'>,</span> <span class='hs-varid'>b1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>b2</span><span class='hs-layout'>,</span> <span class='hs-varid'>c1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>c2</span><span class='hs-layout'>,</span>
<a name="line-286"></a>                 <span class='hs-varid'>d1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>d2</span><span class='hs-layout'>,</span> <span class='hs-varid'>e1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>
<a name="line-287"></a>
<a name="line-288"></a><a name="instance%20Monoid%20Ordering"></a><span class='hs-comment'>-- lexicographical ordering</span>
<a name="line-289"></a><a name="instance%20Monoid%20Ordering"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-conid'>Ordering</span> <span class='hs-keyword'>where</span>
<a name="line-290"></a>        <span class='hs-varid'>mempty</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EQ</span>
<a name="line-291"></a>        <span class='hs-conid'>LT</span> <span class='hs-varop'>`mappend`</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-292"></a>        <span class='hs-conid'>EQ</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>y</span>
<a name="line-293"></a>        <span class='hs-conid'>GT</span> <span class='hs-varop'>`mappend`</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-294"></a>
<a name="line-295"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- | Lift a semigroup into 'Maybe' forming a 'Monoid' according to</span>
<a name="line-296"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- &lt;<a href="http://en.wikipedia.org/wiki/Monoid">http://en.wikipedia.org/wiki/Monoid</a>&gt;: \"Any semigroup @S@ may be</span>
<a name="line-297"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- turned into a monoid simply by adjoining an element @e@ not in @S@</span>
<a name="line-298"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- and defining @e*e = e@ and @e*s = s = s*e@ for all @s ∈ S@.\" Since</span>
<a name="line-299"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- there is no \"Semigroup\" typeclass providing just 'mappend', we</span>
<a name="line-300"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- use 'Monoid' instead.</span>
<a name="line-301"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-302"></a>  <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-303"></a>  <span class='hs-conid'>Nothing</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span>
<a name="line-304"></a>  <span class='hs-varid'>m</span> <span class='hs-varop'>`mappend`</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span>
<a name="line-305"></a>  <span class='hs-conid'>Just</span> <span class='hs-varid'>m1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>m2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>m1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>m2</span><span class='hs-layout'>)</span>
<a name="line-306"></a>
<a name="line-307"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-308"></a>    <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-309"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-310"></a>
<a name="line-311"></a>
<a name="line-312"></a><span class='hs-comment'>{- | The 'Functor' class is used for types that can be mapped over.
<a name="line-313"></a>Instances of 'Functor' should satisfy the following laws:
<a name="line-314"></a>
<a name="line-315"></a>&gt; fmap id  ==  id
<a name="line-316"></a>&gt; fmap (f . g)  ==  fmap f . fmap g
<a name="line-317"></a>
<a name="line-318"></a>The instances of 'Functor' for lists, 'Data.Maybe.Maybe' and 'System.IO.IO'
<a name="line-319"></a>satisfy these laws.
<a name="line-320"></a>-}</span>
<a name="line-321"></a>
<a name="line-322"></a><a name="Functor"></a><span class='hs-keyword'>class</span>  <span class='hs-conid'>Functor</span> <span class='hs-varid'>f</span>  <span class='hs-keyword'>where</span>
<a name="line-323"></a>    <span class='hs-varid'>fmap</span>        <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-324"></a>
<a name="line-325"></a>    <span class='hs-comment'>-- | Replace all locations in the input with the same value.</span>
<a name="line-326"></a>    <span class='hs-comment'>-- The default definition is @'fmap' . 'const'@, but this may be</span>
<a name="line-327"></a>    <span class='hs-comment'>-- overridden with a more efficient version.</span>
<a name="line-328"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;$</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-329"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;$</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>fmap</span> <span class='hs-varop'>.</span> <span class='hs-varid'>const</span>
<a name="line-330"></a>
<a name="line-331"></a><span class='hs-comment'>-- | A functor with application, providing operations to</span>
<a name="line-332"></a><span class='hs-comment'>--</span>
<a name="line-333"></a><span class='hs-comment'>-- * embed pure expressions ('pure'), and</span>
<a name="line-334"></a><span class='hs-comment'>--</span>
<a name="line-335"></a><span class='hs-comment'>-- * sequence computations and combine their results ('&lt;*&gt;').</span>
<a name="line-336"></a><span class='hs-comment'>--</span>
<a name="line-337"></a><span class='hs-comment'>-- A minimal complete definition must include implementations of these</span>
<a name="line-338"></a><span class='hs-comment'>-- functions satisfying the following laws:</span>
<a name="line-339"></a><span class='hs-comment'>--</span>
<a name="line-340"></a><span class='hs-comment'>-- [/identity/]</span>
<a name="line-341"></a><span class='hs-comment'>--</span>
<a name="line-342"></a><span class='hs-comment'>--      @'pure' 'id' '&lt;*&gt;' v = v@</span>
<a name="line-343"></a><span class='hs-comment'>--</span>
<a name="line-344"></a><span class='hs-comment'>-- [/composition/]</span>
<a name="line-345"></a><span class='hs-comment'>--</span>
<a name="line-346"></a><span class='hs-comment'>--      @'pure' (.) '&lt;*&gt;' u '&lt;*&gt;' v '&lt;*&gt;' w = u '&lt;*&gt;' (v '&lt;*&gt;' w)@</span>
<a name="line-347"></a><span class='hs-comment'>--</span>
<a name="line-348"></a><span class='hs-comment'>-- [/homomorphism/]</span>
<a name="line-349"></a><span class='hs-comment'>--</span>
<a name="line-350"></a><span class='hs-comment'>--      @'pure' f '&lt;*&gt;' 'pure' x = 'pure' (f x)@</span>
<a name="line-351"></a><span class='hs-comment'>--</span>
<a name="line-352"></a><span class='hs-comment'>-- [/interchange/]</span>
<a name="line-353"></a><span class='hs-comment'>--</span>
<a name="line-354"></a><span class='hs-comment'>--      @u '&lt;*&gt;' 'pure' y = 'pure' ('$' y) '&lt;*&gt;' u@</span>
<a name="line-355"></a><span class='hs-comment'>--</span>
<a name="line-356"></a><span class='hs-comment'>-- The other methods have the following default definitions, which may</span>
<a name="line-357"></a><span class='hs-comment'>-- be overridden with equivalent specialized implementations:</span>
<a name="line-358"></a><span class='hs-comment'>--</span>
<a name="line-359"></a><span class='hs-comment'>--   * @u '*&gt;' v = 'pure' ('const' 'id') '&lt;*&gt;' u '&lt;*&gt;' v@</span>
<a name="line-360"></a><span class='hs-comment'>--</span>
<a name="line-361"></a><span class='hs-comment'>--   * @u '&lt;*' v = 'pure' 'const' '&lt;*&gt;' u '&lt;*&gt;' v@</span>
<a name="line-362"></a><span class='hs-comment'>--</span>
<a name="line-363"></a><span class='hs-comment'>-- As a consequence of these laws, the 'Functor' instance for @f@ will satisfy</span>
<a name="line-364"></a><span class='hs-comment'>--</span>
<a name="line-365"></a><span class='hs-comment'>--   * @'fmap' f x = 'pure' f '&lt;*&gt;' x@</span>
<a name="line-366"></a><span class='hs-comment'>--</span>
<a name="line-367"></a><span class='hs-comment'>-- If @f@ is also a 'Monad', it should satisfy</span>
<a name="line-368"></a><span class='hs-comment'>--</span>
<a name="line-369"></a><span class='hs-comment'>--   * @'pure' = 'return'@</span>
<a name="line-370"></a><span class='hs-comment'>--</span>
<a name="line-371"></a><span class='hs-comment'>--   * @('&lt;*&gt;') = 'ap'@</span>
<a name="line-372"></a><span class='hs-comment'>--</span>
<a name="line-373"></a><span class='hs-comment'>-- (which implies that 'pure' and '&lt;*&gt;' satisfy the applicative functor laws).</span>
<a name="line-374"></a>
<a name="line-375"></a><a name="Applicative"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<a name="line-376"></a>    <span class='hs-comment'>-- | Lift a value.</span>
<a name="line-377"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-378"></a>
<a name="line-379"></a>    <span class='hs-comment'>-- | Sequential application.</span>
<a name="line-380"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-381"></a>
<a name="line-382"></a>    <span class='hs-comment'>-- | Sequence actions, discarding the value of the first argument.</span>
<a name="line-383"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-384"></a>    <span class='hs-varid'>a1</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span> <span class='hs-varop'>&lt;$</span> <span class='hs-varid'>a1</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>a2</span>
<a name="line-385"></a>    <span class='hs-comment'>-- This is essentially the same as liftA2 (const id), but if the</span>
<a name="line-386"></a>    <span class='hs-comment'>-- Functor instance has an optimized (&lt;$), we want to use that instead.</span>
<a name="line-387"></a>
<a name="line-388"></a>    <span class='hs-comment'>-- | Sequence actions, discarding the value of the second argument.</span>
<a name="line-389"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-390"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-varid'>const</span>
<a name="line-391"></a>
<a name="line-392"></a><a name="%3c**%3e"></a><span class='hs-comment'>-- | A variant of '&lt;*&gt;' with the arguments reversed.</span>
<a name="line-393"></a><span class='hs-layout'>(</span><span class='hs-varop'>&lt;**&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-394"></a><span class='hs-layout'>(</span><span class='hs-varop'>&lt;**&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-layout'>(</span><span class='hs-varid'>flip</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-395"></a>
<a name="line-396"></a><a name="liftA"></a><span class='hs-comment'>-- | Lift a function to actions.</span>
<a name="line-397"></a><span class='hs-comment'>-- This function may be used as a value for `fmap` in a `Functor` instance.</span>
<a name="line-398"></a><span class='hs-definition'>liftA</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-399"></a><span class='hs-definition'>liftA</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>f</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>a</span>
<a name="line-400"></a><span class='hs-comment'>-- Caution: since this may be used for `fmap`, we can't use the obvious</span>
<a name="line-401"></a><span class='hs-comment'>-- definition of liftA = fmap.</span>
<a name="line-402"></a>
<a name="line-403"></a><a name="liftA2"></a><span class='hs-comment'>-- | Lift a binary function to actions.</span>
<a name="line-404"></a><span class='hs-definition'>liftA2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>c</span>
<a name="line-405"></a><span class='hs-definition'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>b</span>
<a name="line-406"></a>
<a name="line-407"></a><a name="liftA3"></a><span class='hs-comment'>-- | Lift a ternary function to actions.</span>
<a name="line-408"></a><span class='hs-definition'>liftA3</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>d</span>
<a name="line-409"></a><span class='hs-definition'>liftA3</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>c</span>
<a name="line-410"></a>
<a name="line-411"></a>
<a name="line-412"></a><span class='hs-comment'>{-# INLINEABLE liftA #-}</span>
<a name="line-413"></a><span class='hs-comment'>{-# SPECIALISE liftA :: (a1-&gt;r) -&gt; IO a1 -&gt; IO r #-}</span>
<a name="line-414"></a><span class='hs-comment'>{-# SPECIALISE liftA :: (a1-&gt;r) -&gt; Maybe a1 -&gt; Maybe r #-}</span>
<a name="line-415"></a><span class='hs-comment'>{-# INLINEABLE liftA2 #-}</span>
<a name="line-416"></a><span class='hs-comment'>{-# SPECIALISE liftA2 :: (a1-&gt;a2-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO r #-}</span>
<a name="line-417"></a><span class='hs-comment'>{-# SPECIALISE liftA2 :: (a1-&gt;a2-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe r #-}</span>
<a name="line-418"></a><span class='hs-comment'>{-# INLINEABLE liftA3 #-}</span>
<a name="line-419"></a><span class='hs-comment'>{-# SPECIALISE liftA3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO r #-}</span>
<a name="line-420"></a><span class='hs-comment'>{-# SPECIALISE liftA3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt;
<a name="line-421"></a>                                Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe r #-}</span>
<a name="line-422"></a>
<a name="line-423"></a><a name="join"></a><span class='hs-comment'>-- | The 'join' function is the conventional monad join operator. It</span>
<a name="line-424"></a><span class='hs-comment'>-- is used to remove one level of monadic structure, projecting its</span>
<a name="line-425"></a><span class='hs-comment'>-- bound argument into the outer level.</span>
<a name="line-426"></a><span class='hs-definition'>join</span>              <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-427"></a><span class='hs-definition'>join</span> <span class='hs-varid'>x</span>            <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>id</span>
<a name="line-428"></a>
<a name="line-429"></a><a name="Monad"></a><span class='hs-comment'>{- | The 'Monad' class defines the basic operations over a /monad/,
<a name="line-430"></a>a concept from a branch of mathematics known as /category theory/.
<a name="line-431"></a>From the perspective of a Haskell programmer, however, it is best to
<a name="line-432"></a>think of a monad as an /abstract datatype/ of actions.
<a name="line-433"></a>Haskell's @do@ expressions provide a convenient syntax for writing
<a name="line-434"></a>monadic expressions.
<a name="line-435"></a>
<a name="line-436"></a>Instances of 'Monad' should satisfy the following laws:
<a name="line-437"></a>
<a name="line-438"></a>* @'return' a '&gt;&gt;=' k  =  k a@
<a name="line-439"></a>* @m '&gt;&gt;=' 'return'  =  m@
<a name="line-440"></a>* @m '&gt;&gt;=' (\x -&gt; k x '&gt;&gt;=' h)  =  (m '&gt;&gt;=' k) '&gt;&gt;=' h@
<a name="line-441"></a>
<a name="line-442"></a>Furthermore, the 'Monad' and 'Applicative' operations should relate as follows:
<a name="line-443"></a>
<a name="line-444"></a>* @'pure' = 'return'@
<a name="line-445"></a>* @('&lt;*&gt;') = 'ap'@
<a name="line-446"></a>
<a name="line-447"></a>The above laws imply:
<a name="line-448"></a>
<a name="line-449"></a>* @'fmap' f xs  =  xs '&gt;&gt;=' 'return' . f@
<a name="line-450"></a>* @('&gt;&gt;') = ('*&gt;')@
<a name="line-451"></a>
<a name="line-452"></a>and that 'pure' and ('&lt;*&gt;') satisfy the applicative functor laws.
<a name="line-453"></a>
<a name="line-454"></a>The instances of 'Monad' for lists, 'Data.Maybe.Maybe' and 'System.IO.IO'
<a name="line-455"></a>defined in the "Prelude" satisfy these laws.
<a name="line-456"></a>-}</span>
<a name="line-457"></a><a name="Monad"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>where</span>
<a name="line-458"></a>    <span class='hs-comment'>-- | Sequentially compose two actions, passing any value produced</span>
<a name="line-459"></a>    <span class='hs-comment'>-- by the first as an argument to the second.</span>
<a name="line-460"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;=</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-461"></a>
<a name="line-462"></a>    <span class='hs-comment'>-- | Sequentially compose two actions, discarding any value produced</span>
<a name="line-463"></a>    <span class='hs-comment'>-- by the first, like sequencing operators (such as the semicolon)</span>
<a name="line-464"></a>    <span class='hs-comment'>-- in imperative languages.</span>
<a name="line-465"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-466"></a>    <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span> <span class='hs-comment'>-- See Note [Recursive bindings for Applicative/Monad]</span>
<a name="line-467"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;) #-}</span>
<a name="line-468"></a>
<a name="line-469"></a>    <span class='hs-comment'>-- | Inject a value into the monadic type.</span>
<a name="line-470"></a>    <span class='hs-varid'>return</span>      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-471"></a>    <span class='hs-varid'>return</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span>
<a name="line-472"></a>
<a name="line-473"></a>    <span class='hs-comment'>-- | Fail with a message.  This operation is not part of the</span>
<a name="line-474"></a>    <span class='hs-comment'>-- mathematical definition of a monad, but is invoked on pattern-match</span>
<a name="line-475"></a>    <span class='hs-comment'>-- failure in a @do@ expression.</span>
<a name="line-476"></a>    <span class='hs-varid'>fail</span>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-477"></a>    <span class='hs-varid'>fail</span> <span class='hs-varid'>s</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-varid'>s</span>
<a name="line-478"></a>
<a name="line-479"></a><span class='hs-comment'>{- Note [Recursive bindings for Applicative/Monad]
<a name="line-480"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-481"></a>
<a name="line-482"></a>The original Applicative/Monad proposal stated that after
<a name="line-483"></a>implementation, the designated implementation of (&gt;&gt;) would become
<a name="line-484"></a>
<a name="line-485"></a>  (&gt;&gt;) :: forall a b. m a -&gt; m b -&gt; m b
<a name="line-486"></a>  (&gt;&gt;) = (*&gt;)
<a name="line-487"></a>
<a name="line-488"></a>by default. You might be inclined to change this to reflect the stated
<a name="line-489"></a>proposal, but you really shouldn't! Why? Because people tend to define
<a name="line-490"></a>such instances the /other/ way around: in particular, it is perfectly
<a name="line-491"></a>legitimate to define an instance of Applicative (*&gt;) in terms of (&gt;&gt;),
<a name="line-492"></a>which would lead to an infinite loop for the default implementation of
<a name="line-493"></a>Monad! And people do this in the wild.
<a name="line-494"></a>
<a name="line-495"></a>This turned into a nasty bug that was tricky to track down, and rather
<a name="line-496"></a>than eliminate it everywhere upstream, it's easier to just retain the
<a name="line-497"></a>original default.
<a name="line-498"></a>
<a name="line-499"></a>-}</span>
<a name="line-500"></a>
<a name="line-501"></a><a name="=%3c%3c"></a><span class='hs-comment'>-- | Same as '&gt;&gt;=', but with the arguments interchanged.</span>
<a name="line-502"></a><span class='hs-comment'>{-# SPECIALISE (=&lt;&lt;) :: (a -&gt; [b]) -&gt; [a] -&gt; [b] #-}</span>
<a name="line-503"></a><span class='hs-layout'>(</span><span class='hs-varop'>=&lt;&lt;</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-504"></a><a name="f"></a><span class='hs-definition'>f</span> <span class='hs-varop'>=&lt;&lt;</span> <span class='hs-varid'>x</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>f</span>
<a name="line-505"></a>
<a name="line-506"></a><a name="when"></a><span class='hs-comment'>-- | Conditional execution of 'Applicative' expressions. For example,</span>
<a name="line-507"></a><span class='hs-comment'>--</span>
<a name="line-508"></a><span class='hs-comment'>-- &gt; when debug (putStrLn "Debugging")</span>
<a name="line-509"></a><span class='hs-comment'>--</span>
<a name="line-510"></a><span class='hs-comment'>-- will output the string @Debugging@ if the Boolean value @debug@</span>
<a name="line-511"></a><span class='hs-comment'>-- is 'True', and otherwise do nothing.</span>
<a name="line-512"></a><span class='hs-definition'>when</span>      <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-conid'>()</span>
<a name="line-513"></a><span class='hs-comment'>{-# INLINEABLE when #-}</span>
<a name="line-514"></a><span class='hs-comment'>{-# SPECIALISE when :: Bool -&gt; IO () -&gt; IO () #-}</span>
<a name="line-515"></a><span class='hs-comment'>{-# SPECIALISE when :: Bool -&gt; Maybe () -&gt; Maybe () #-}</span>
<a name="line-516"></a><span class='hs-definition'>when</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>p</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>()</span>
<a name="line-517"></a>
<a name="line-518"></a><a name="sequence"></a><span class='hs-comment'>-- | Evaluate each action in the sequence from left to right,</span>
<a name="line-519"></a><span class='hs-comment'>-- and collect the results.</span>
<a name="line-520"></a><span class='hs-definition'>sequence</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>m</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-521"></a><span class='hs-comment'>{-# INLINE sequence #-}</span>
<a name="line-522"></a><span class='hs-definition'>sequence</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>id</span>
<a name="line-523"></a><span class='hs-comment'>-- Note: [sequence and mapM]</span>
<a name="line-524"></a>
<a name="line-525"></a><a name="mapM"></a><span class='hs-comment'>-- | @'mapM' f@ is equivalent to @'sequence' . 'map' f@.</span>
<a name="line-526"></a><span class='hs-definition'>mapM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-527"></a><span class='hs-comment'>{-# INLINE mapM #-}</span>
<a name="line-528"></a><span class='hs-definition'>mapM</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span>
<a name="line-529"></a>            <span class='hs-keyword'>where</span>
<a name="line-530"></a>              <span class='hs-varid'>k</span> <span class='hs-varid'>a</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>;</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>r</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-531"></a>
<a name="line-532"></a><span class='hs-comment'>{-
<a name="line-533"></a>Note: [sequence and mapM]
<a name="line-534"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-535"></a>Originally, we defined
<a name="line-536"></a>
<a name="line-537"></a>mapM f = sequence . map f
<a name="line-538"></a>
<a name="line-539"></a>This relied on list fusion to produce efficient code for mapM, and led to
<a name="line-540"></a>excessive allocation in cryptarithm2. Defining
<a name="line-541"></a>
<a name="line-542"></a>sequence = mapM id
<a name="line-543"></a>
<a name="line-544"></a>relies only on inlining a tiny function (id) and beta reduction, which tends to
<a name="line-545"></a>be a more reliable aspect of simplification. Indeed, this does not lead to
<a name="line-546"></a>similar problems in nofib.
<a name="line-547"></a>-}</span>
<a name="line-548"></a>
<a name="line-549"></a><a name="liftM"></a><span class='hs-comment'>-- | Promote a function to a monad.</span>
<a name="line-550"></a><span class='hs-definition'>liftM</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-551"></a><span class='hs-definition'>liftM</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span>              <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-552"></a>
<a name="line-553"></a><a name="liftM2"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-554"></a><span class='hs-comment'>-- left to right.  For example,</span>
<a name="line-555"></a><span class='hs-comment'>--</span>
<a name="line-556"></a><span class='hs-comment'>-- &gt;    liftM2 (+) [0,1] [0,2] = [0,2,1,3]</span>
<a name="line-557"></a><span class='hs-comment'>-- &gt;    liftM2 (+) (Just 1) Nothing = Nothing</span>
<a name="line-558"></a><span class='hs-comment'>--</span>
<a name="line-559"></a><span class='hs-definition'>liftM2</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-560"></a><span class='hs-definition'>liftM2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-561"></a>
<a name="line-562"></a><a name="liftM3"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-563"></a><span class='hs-comment'>-- left to right (cf. 'liftM2').</span>
<a name="line-564"></a><span class='hs-definition'>liftM3</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-565"></a><span class='hs-definition'>liftM3</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span> <span class='hs-varid'>m3</span>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>x3</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m3</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span> <span class='hs-varid'>x3</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-566"></a>
<a name="line-567"></a><a name="liftM4"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-568"></a><span class='hs-comment'>-- left to right (cf. 'liftM2').</span>
<a name="line-569"></a><span class='hs-definition'>liftM4</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-570"></a><span class='hs-definition'>liftM4</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span> <span class='hs-varid'>m3</span> <span class='hs-varid'>m4</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>x3</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m3</span><span class='hs-layout'>;</span> <span class='hs-varid'>x4</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m4</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span> <span class='hs-varid'>x3</span> <span class='hs-varid'>x4</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-571"></a>
<a name="line-572"></a><a name="liftM5"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-573"></a><span class='hs-comment'>-- left to right (cf. 'liftM2').</span>
<a name="line-574"></a><span class='hs-definition'>liftM5</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a5</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a5</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-575"></a><span class='hs-definition'>liftM5</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span> <span class='hs-varid'>m3</span> <span class='hs-varid'>m4</span> <span class='hs-varid'>m5</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>x3</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m3</span><span class='hs-layout'>;</span> <span class='hs-varid'>x4</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m4</span><span class='hs-layout'>;</span> <span class='hs-varid'>x5</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m5</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span> <span class='hs-varid'>x3</span> <span class='hs-varid'>x4</span> <span class='hs-varid'>x5</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-576"></a>
<a name="line-577"></a><span class='hs-comment'>{-# INLINEABLE liftM #-}</span>
<a name="line-578"></a><span class='hs-comment'>{-# SPECIALISE liftM :: (a1-&gt;r) -&gt; IO a1 -&gt; IO r #-}</span>
<a name="line-579"></a><span class='hs-comment'>{-# SPECIALISE liftM :: (a1-&gt;r) -&gt; Maybe a1 -&gt; Maybe r #-}</span>
<a name="line-580"></a><span class='hs-comment'>{-# INLINEABLE liftM2 #-}</span>
<a name="line-581"></a><span class='hs-comment'>{-# SPECIALISE liftM2 :: (a1-&gt;a2-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO r #-}</span>
<a name="line-582"></a><span class='hs-comment'>{-# SPECIALISE liftM2 :: (a1-&gt;a2-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe r #-}</span>
<a name="line-583"></a><span class='hs-comment'>{-# INLINEABLE liftM3 #-}</span>
<a name="line-584"></a><span class='hs-comment'>{-# SPECIALISE liftM3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO r #-}</span>
<a name="line-585"></a><span class='hs-comment'>{-# SPECIALISE liftM3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe r #-}</span>
<a name="line-586"></a><span class='hs-comment'>{-# INLINEABLE liftM4 #-}</span>
<a name="line-587"></a><span class='hs-comment'>{-# SPECIALISE liftM4 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO a4 -&gt; IO r #-}</span>
<a name="line-588"></a><span class='hs-comment'>{-# SPECIALISE liftM4 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe a4 -&gt; Maybe r #-}</span>
<a name="line-589"></a><span class='hs-comment'>{-# INLINEABLE liftM5 #-}</span>
<a name="line-590"></a><span class='hs-comment'>{-# SPECIALISE liftM5 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;a5-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO a4 -&gt; IO a5 -&gt; IO r #-}</span>
<a name="line-591"></a><span class='hs-comment'>{-# SPECIALISE liftM5 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;a5-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe a4 -&gt; Maybe a5 -&gt; Maybe r #-}</span>
<a name="line-592"></a>
<a name="line-593"></a><span class='hs-comment'>{- | In many situations, the 'liftM' operations can be replaced by uses of
<a name="line-594"></a>'ap', which promotes function application.
<a name="line-595"></a>
<a name="line-596"></a>&gt;       return f `ap` x1 `ap` ... `ap` xn
<a name="line-597"></a>
<a name="line-598"></a>is equivalent to
<a name="line-599"></a>
<a name="line-600"></a>&gt;       liftMn f x1 x2 ... xn
<a name="line-601"></a>
<a name="line-602"></a>-}</span>
<a name="line-603"></a>
<a name="line-604"></a><a name="ap"></a><span class='hs-definition'>ap</span>                <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-605"></a><span class='hs-definition'>ap</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-606"></a><span class='hs-comment'>-- Since many Applicative instances define (&lt;*&gt;) = ap, we</span>
<a name="line-607"></a><span class='hs-comment'>-- cannot define ap = (&lt;*&gt;)</span>
<a name="line-608"></a><span class='hs-comment'>{-# INLINEABLE ap #-}</span>
<a name="line-609"></a><span class='hs-comment'>{-# SPECIALISE ap :: IO (a -&gt; b) -&gt; IO a -&gt; IO b #-}</span>
<a name="line-610"></a><span class='hs-comment'>{-# SPECIALISE ap :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b #-}</span>
<a name="line-611"></a>
<a name="line-612"></a><span class='hs-comment'>-- instances for Prelude types</span>
<a name="line-613"></a>
<a name="line-614"></a><a name="instance%20Functor%20((-%3e)%20r)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-615"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>.</span><span class='hs-layout'>)</span>
<a name="line-616"></a>
<a name="line-617"></a><a name="instance%20Applicative%20((-%3e)%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-618"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>const</span>
<a name="line-619"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>g</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>g</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-620"></a>
<a name="line-621"></a><a name="instance%20Monad%20((-%3e)%20r)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-622"></a>    <span class='hs-varid'>return</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>const</span>
<a name="line-623"></a>    <span class='hs-varid'>f</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span>
<a name="line-624"></a>
<a name="line-625"></a><a name="instance%20Functor%20((,)%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-626"></a>    <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-627"></a>
<a name="line-628"></a>
<a name="line-629"></a><a name="instance%20Functor%20Maybe"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Functor</span> <span class='hs-conid'>Maybe</span>  <span class='hs-keyword'>where</span>
<a name="line-630"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Nothing</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-631"></a>    <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-632"></a>
<a name="line-633"></a><a name="instance%20Applicative%20Maybe"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyword'>where</span>
<a name="line-634"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span>
<a name="line-635"></a>
<a name="line-636"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>f</span>  <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>m</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m</span>
<a name="line-637"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-sel'>_m</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-638"></a>
<a name="line-639"></a>    <span class='hs-conid'>Just</span> <span class='hs-sel'>_m1</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>m2</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m2</span>
<a name="line-640"></a>    <span class='hs-conid'>Nothing</span>  <span class='hs-varop'>*&gt;</span> <span class='hs-sel'>_m2</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-641"></a>
<a name="line-642"></a><a name="instance%20Monad%20Maybe"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Monad</span> <span class='hs-conid'>Maybe</span>  <span class='hs-keyword'>where</span>
<a name="line-643"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-varid'>x</span>
<a name="line-644"></a>    <span class='hs-conid'>Nothing</span>  <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-645"></a>
<a name="line-646"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span>
<a name="line-647"></a>
<a name="line-648"></a>    <span class='hs-varid'>return</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span>
<a name="line-649"></a>    <span class='hs-varid'>fail</span> <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-650"></a>
<a name="line-651"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-652"></a><span class='hs-comment'>-- The Alternative class definition</span>
<a name="line-653"></a>
<a name="line-654"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>3</span> <span class='hs-varop'>&lt;|&gt;</span>
<a name="line-655"></a>
<a name="line-656"></a><a name="Alternative"></a><span class='hs-comment'>-- | A monoid on applicative functors.</span>
<a name="line-657"></a><a name="Alternative"></a><span class='hs-comment'>--</span>
<a name="line-658"></a><a name="Alternative"></a><span class='hs-comment'>-- If defined, 'some' and 'many' should be the least solutions</span>
<a name="line-659"></a><a name="Alternative"></a><span class='hs-comment'>-- of the equations:</span>
<a name="line-660"></a><a name="Alternative"></a><span class='hs-comment'>--</span>
<a name="line-661"></a><a name="Alternative"></a><span class='hs-comment'>-- * @some v = (:) '&lt;$&gt;' v '&lt;*&gt;' many v@</span>
<a name="line-662"></a><a name="Alternative"></a><span class='hs-comment'>--</span>
<a name="line-663"></a><a name="Alternative"></a><span class='hs-comment'>-- * @many v = some v '&lt;|&gt;' 'pure' []@</span>
<a name="line-664"></a><a name="Alternative"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Alternative</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<a name="line-665"></a>    <span class='hs-comment'>-- | The identity of '&lt;|&gt;'</span>
<a name="line-666"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-667"></a>    <span class='hs-comment'>-- | An associative binary operation</span>
<a name="line-668"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-669"></a>
<a name="line-670"></a>    <span class='hs-comment'>-- | One or more.</span>
<a name="line-671"></a>    <span class='hs-varid'>some</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-672"></a>    <span class='hs-varid'>some</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>some_v</span>
<a name="line-673"></a>      <span class='hs-keyword'>where</span>
<a name="line-674"></a>        <span class='hs-varid'>many_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>some_v</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-675"></a>        <span class='hs-varid'>some_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>many_v</span>
<a name="line-676"></a>
<a name="line-677"></a>    <span class='hs-comment'>-- | Zero or more.</span>
<a name="line-678"></a>    <span class='hs-varid'>many</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-679"></a>    <span class='hs-varid'>many</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>many_v</span>
<a name="line-680"></a>      <span class='hs-keyword'>where</span>
<a name="line-681"></a>        <span class='hs-varid'>many_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>some_v</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-682"></a>        <span class='hs-varid'>some_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>many_v</span>
<a name="line-683"></a>
<a name="line-684"></a>
<a name="line-685"></a><a name="instance%20Alternative%20Maybe"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Alternative</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyword'>where</span>
<a name="line-686"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-687"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-688"></a>    <span class='hs-varid'>l</span>       <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l</span>
<a name="line-689"></a>
<a name="line-690"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-691"></a><span class='hs-comment'>-- The MonadPlus class definition</span>
<a name="line-692"></a>
<a name="line-693"></a><a name="MonadPlus"></a><span class='hs-comment'>-- | Monads that also support choice and failure.</span>
<a name="line-694"></a><a name="MonadPlus"></a><span class='hs-keyword'>class</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alternative</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>where</span>
<a name="line-695"></a>   <span class='hs-comment'>-- | the identity of 'mplus'.  It should also satisfy the equations</span>
<a name="line-696"></a>   <span class='hs-comment'>--</span>
<a name="line-697"></a>   <span class='hs-comment'>-- &gt; mzero &gt;&gt;= f  =  mzero</span>
<a name="line-698"></a>   <span class='hs-comment'>-- &gt; v &gt;&gt; mzero   =  mzero</span>
<a name="line-699"></a>   <span class='hs-comment'>--</span>
<a name="line-700"></a>   <span class='hs-varid'>mzero</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-701"></a>   <span class='hs-varid'>mzero</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>empty</span>
<a name="line-702"></a>
<a name="line-703"></a>   <span class='hs-comment'>-- | an associative operation</span>
<a name="line-704"></a>   <span class='hs-varid'>mplus</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-705"></a>   <span class='hs-varid'>mplus</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span>
<a name="line-706"></a>
<a name="line-707"></a><a name="instance%20MonadPlus%20Maybe"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-conid'>Maybe</span>
<a name="line-708"></a>
<a name="line-709"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-710"></a><span class='hs-comment'>-- The list type</span>
<a name="line-711"></a>
<a name="line-712"></a><a name="instance%20Functor%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-713"></a>    <span class='hs-comment'>{-# INLINE fmap #-}</span>
<a name="line-714"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span>
<a name="line-715"></a>
<a name="line-716"></a><a name="instance%20Applicative%20%5b%5d"></a><span class='hs-comment'>-- See Note: [List comprehensions and inlining]</span>
<a name="line-717"></a><a name="instance%20Applicative%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-718"></a>    <span class='hs-comment'>{-# INLINE pure #-}</span>
<a name="line-719"></a>    <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<a name="line-720"></a>    <span class='hs-comment'>{-# INLINE (&lt;*&gt;) #-}</span>
<a name="line-721"></a>    <span class='hs-varid'>fs</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>fs</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>]</span>
<a name="line-722"></a>    <span class='hs-comment'>{-# INLINE (*&gt;) #-}</span>
<a name="line-723"></a>    <span class='hs-varid'>xs</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>ys</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ys</span><span class='hs-keyglyph'>]</span>
<a name="line-724"></a>
<a name="line-725"></a><a name="instance%20Monad%20%5b%5d"></a><span class='hs-comment'>-- See Note: [List comprehensions and inlining]</span>
<a name="line-726"></a><a name="instance%20Monad%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-conid'>[]</span>  <span class='hs-keyword'>where</span>
<a name="line-727"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;=) #-}</span>
<a name="line-728"></a>    <span class='hs-varid'>xs</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>f</span>             <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<a name="line-729"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;) #-}</span>
<a name="line-730"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span>
<a name="line-731"></a>    <span class='hs-comment'>{-# INLINE return #-}</span>
<a name="line-732"></a>    <span class='hs-varid'>return</span> <span class='hs-varid'>x</span>            <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<a name="line-733"></a>    <span class='hs-comment'>{-# INLINE fail #-}</span>
<a name="line-734"></a>    <span class='hs-varid'>fail</span> <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-735"></a>
<a name="line-736"></a><a name="instance%20Alternative%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Alternative</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-737"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-738"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span>
<a name="line-739"></a>
<a name="line-740"></a><a name="instance%20MonadPlus%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-conid'>[]</span>
<a name="line-741"></a>
<a name="line-742"></a><span class='hs-comment'>{-
<a name="line-743"></a>A few list functions that appear here because they are used here.
<a name="line-744"></a>The rest of the prelude list functions are in GHC.List.
<a name="line-745"></a>-}</span>
<a name="line-746"></a>
<a name="line-747"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-748"></a><span class='hs-comment'>--      foldr/build/augment</span>
<a name="line-749"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-750"></a>
<a name="line-751"></a><span class='hs-comment'>-- | 'foldr', applied to a binary operator, a starting value (typically</span>
<a name="line-752"></a><span class='hs-comment'>-- the right-identity of the operator), and a list, reduces the list</span>
<a name="line-753"></a><span class='hs-comment'>-- using the binary operator, from right to left:</span>
<a name="line-754"></a><span class='hs-comment'>--</span>
<a name="line-755"></a><span class='hs-comment'>-- &gt; foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)</span>
<a name="line-756"></a>
<a name="line-757"></a><span class='hs-definition'>foldr</span>            <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-758"></a><span class='hs-comment'>-- foldr _ z []     =  z</span>
<a name="line-759"></a><span class='hs-comment'>-- foldr f z (x:xs) =  f x (foldr f z xs)</span>
<a name="line-760"></a><span class='hs-comment'>{-# INLINE [0] foldr #-}</span>
<a name="line-761"></a><span class='hs-comment'>-- Inline only in the final stage, after the foldr/cons rule has had a chance</span>
<a name="line-762"></a><span class='hs-comment'>-- Also note that we inline it when it has *two* parameters, which are the</span>
<a name="line-763"></a><span class='hs-comment'>-- ones we are keen about specialising!</span>
<a name="line-764"></a><span class='hs-definition'>foldr</span> <span class='hs-varid'>k</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span>
<a name="line-765"></a>          <span class='hs-keyword'>where</span>
<a name="line-766"></a>            <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-767"></a>            <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>y</span> <span class='hs-varop'>`k`</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ys</span>
<a name="line-768"></a>
<a name="line-769"></a><span class='hs-comment'>-- | A list producer that can be fused with 'foldr'.</span>
<a name="line-770"></a><span class='hs-comment'>-- This function is merely</span>
<a name="line-771"></a><span class='hs-comment'>--</span>
<a name="line-772"></a><span class='hs-comment'>-- &gt;    build g = g (:) []</span>
<a name="line-773"></a><span class='hs-comment'>--</span>
<a name="line-774"></a><span class='hs-comment'>-- but GHC's simplifier will transform an expression of the form</span>
<a name="line-775"></a><span class='hs-comment'>-- @'foldr' k z ('build' g)@, which may arise after inlining, to @g k z@,</span>
<a name="line-776"></a><span class='hs-comment'>-- which avoids producing an intermediate list.</span>
<a name="line-777"></a>
<a name="line-778"></a><span class='hs-definition'>build</span>   <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-779"></a><span class='hs-comment'>{-# INLINE [1] build #-}</span>
<a name="line-780"></a>        <span class='hs-comment'>-- The INLINE is important, even though build is tiny,</span>
<a name="line-781"></a>        <span class='hs-comment'>-- because it prevents [] getting inlined in the version that</span>
<a name="line-782"></a>        <span class='hs-comment'>-- appears in the interface file.  If [] *is* inlined, it</span>
<a name="line-783"></a>        <span class='hs-comment'>-- won't match with [] appearing in rules in an importing module.</span>
<a name="line-784"></a>        <span class='hs-comment'>--</span>
<a name="line-785"></a>        <span class='hs-comment'>-- The "1" says to inline in phase 1</span>
<a name="line-786"></a>
<a name="line-787"></a><span class='hs-definition'>build</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>
<a name="line-788"></a>
<a name="line-789"></a><span class='hs-comment'>-- | A list producer that can be fused with 'foldr'.</span>
<a name="line-790"></a><span class='hs-comment'>-- This function is merely</span>
<a name="line-791"></a><span class='hs-comment'>--</span>
<a name="line-792"></a><span class='hs-comment'>-- &gt;    augment g xs = g (:) xs</span>
<a name="line-793"></a><span class='hs-comment'>--</span>
<a name="line-794"></a><span class='hs-comment'>-- but GHC's simplifier will transform an expression of the form</span>
<a name="line-795"></a><span class='hs-comment'>-- @'foldr' k z ('augment' g xs)@, which may arise after inlining, to</span>
<a name="line-796"></a><span class='hs-comment'>-- @g k ('foldr' k z xs)@, which avoids producing an intermediate list.</span>
<a name="line-797"></a>
<a name="line-798"></a><a name="augment"></a><span class='hs-definition'>augment</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-799"></a><span class='hs-comment'>{-# INLINE [1] augment #-}</span>
<a name="line-800"></a><span class='hs-definition'>augment</span> <span class='hs-varid'>g</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
<a name="line-801"></a>
<a name="line-802"></a><span class='hs-comment'>{-# RULES
<a name="line-803"></a>"fold/build"    forall k z (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-804"></a>                foldr k z (build g) = g k z
<a name="line-805"></a>
<a name="line-806"></a>"foldr/augment" forall k z xs (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-807"></a>                foldr k z (augment g xs) = g k (foldr k z xs)
<a name="line-808"></a>
<a name="line-809"></a>"foldr/id"                        foldr (:) [] = \x  -&gt; x
<a name="line-810"></a>"foldr/app"     [1] forall ys. foldr (:) ys = \xs -&gt; xs ++ ys
<a name="line-811"></a>        -- Only activate this from phase 1, because that's
<a name="line-812"></a>        -- when we disable the rule that expands (++) into foldr
<a name="line-813"></a>
<a name="line-814"></a>-- The foldr/cons rule looks nice, but it can give disastrously
<a name="line-815"></a>-- bloated code when commpiling
<a name="line-816"></a>--      array (a,b) [(1,2), (2,2), (3,2), ...very long list... ]
<a name="line-817"></a>-- i.e. when there are very very long literal lists
<a name="line-818"></a>-- So I've disabled it for now. We could have special cases
<a name="line-819"></a>-- for short lists, I suppose.
<a name="line-820"></a>-- "foldr/cons" forall k z x xs. foldr k z (x:xs) = k x (foldr k z xs)
<a name="line-821"></a>
<a name="line-822"></a>"foldr/single"  forall k z x. foldr k z [x] = k x z
<a name="line-823"></a>"foldr/nil"     forall k z.   foldr k z []  = z
<a name="line-824"></a>
<a name="line-825"></a>"foldr/cons/build" forall k z x (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-826"></a>                           foldr k z (x:build g) = k x (g k z)
<a name="line-827"></a>
<a name="line-828"></a>"augment/build" forall (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b)
<a name="line-829"></a>                       (h::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-830"></a>                       augment g (build h) = build (\c n -&gt; g c (h c n))
<a name="line-831"></a>"augment/nil"   forall (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-832"></a>                        augment g [] = build g
<a name="line-833"></a> #-}</span>
<a name="line-834"></a>
<a name="line-835"></a><span class='hs-comment'>-- This rule is true, but not (I think) useful:</span>
<a name="line-836"></a><span class='hs-comment'>--      augment g (augment h t) = augment (\cn -&gt; g c (h c n)) t</span>
<a name="line-837"></a>
<a name="line-838"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-839"></a><span class='hs-comment'>--              map</span>
<a name="line-840"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-841"></a>
<a name="line-842"></a><span class='hs-comment'>-- | 'map' @f xs@ is the list obtained by applying @f@ to each element</span>
<a name="line-843"></a><span class='hs-comment'>-- of @xs@, i.e.,</span>
<a name="line-844"></a><span class='hs-comment'>--</span>
<a name="line-845"></a><span class='hs-comment'>-- &gt; map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]</span>
<a name="line-846"></a><span class='hs-comment'>-- &gt; map f [x1, x2, ...] == [f x1, f x2, ...]</span>
<a name="line-847"></a>
<a name="line-848"></a><a name="map"></a><span class='hs-definition'>map</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-849"></a><span class='hs-comment'>{-# NOINLINE [1] map #-}</span>    <span class='hs-comment'>-- We want the RULE to fire first.</span>
<a name="line-850"></a>                            <span class='hs-comment'>-- It's recursive, so won't inline anyway,</span>
<a name="line-851"></a>                            <span class='hs-comment'>-- but saying so is more explicit</span>
<a name="line-852"></a><span class='hs-definition'>map</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-853"></a><span class='hs-definition'>map</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>map</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span>
<a name="line-854"></a>
<a name="line-855"></a><a name="mapFB"></a><span class='hs-comment'>-- Note eta expanded</span>
<a name="line-856"></a><span class='hs-definition'>mapFB</span> <span class='hs-keyglyph'>::</span>  <span class='hs-layout'>(</span><span class='hs-varid'>elt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>elt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span>
<a name="line-857"></a><span class='hs-comment'>{-# INLINE [0] mapFB #-}</span>
<a name="line-858"></a><span class='hs-definition'>mapFB</span> <span class='hs-varid'>c</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span>
<a name="line-859"></a>
<a name="line-860"></a><span class='hs-comment'>-- The rules for map work like this.</span>
<a name="line-861"></a><span class='hs-comment'>--</span>
<a name="line-862"></a><span class='hs-comment'>-- Up to (but not including) phase 1, we use the "map" rule to</span>
<a name="line-863"></a><span class='hs-comment'>-- rewrite all saturated applications of map with its build/fold</span>
<a name="line-864"></a><span class='hs-comment'>-- form, hoping for fusion to happen.</span>
<a name="line-865"></a><span class='hs-comment'>-- In phase 1 and 0, we switch off that rule, inline build, and</span>
<a name="line-866"></a><span class='hs-comment'>-- switch on the "mapList" rule, which rewrites the foldr/mapFB</span>
<a name="line-867"></a><span class='hs-comment'>-- thing back into plain map.</span>
<a name="line-868"></a><span class='hs-comment'>--</span>
<a name="line-869"></a><span class='hs-comment'>-- It's important that these two rules aren't both active at once</span>
<a name="line-870"></a><span class='hs-comment'>-- (along with build's unfolding) else we'd get an infinite loop</span>
<a name="line-871"></a><span class='hs-comment'>-- in the rules.  Hence the activation control below.</span>
<a name="line-872"></a><span class='hs-comment'>--</span>
<a name="line-873"></a><span class='hs-comment'>-- The "mapFB" rule optimises compositions of map.</span>
<a name="line-874"></a><span class='hs-comment'>--</span>
<a name="line-875"></a><span class='hs-comment'>-- This same pattern is followed by many other functions:</span>
<a name="line-876"></a><span class='hs-comment'>-- e.g. append, filter, iterate, repeat, etc.</span>
<a name="line-877"></a>
<a name="line-878"></a><span class='hs-comment'>{-# RULES
<a name="line-879"></a>"map"       [~1] forall f xs.   map f xs                = build (\c n -&gt; foldr (mapFB c f) n xs)
<a name="line-880"></a>"mapList"   [1]  forall f.      foldr (mapFB (:) f) []  = map f
<a name="line-881"></a>"mapFB"     forall c f g.       mapFB (mapFB c f) g     = mapFB c (f.g)
<a name="line-882"></a>  #-}</span>
<a name="line-883"></a>
<a name="line-884"></a><span class='hs-comment'>-- See Breitner, Eisenberg, Peyton Jones, and Weirich, "Safe Zero-cost</span>
<a name="line-885"></a><span class='hs-comment'>-- Coercions for Haskell", section 6.5:</span>
<a name="line-886"></a><span class='hs-comment'>--   <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf">http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf</a></span>
<a name="line-887"></a>
<a name="line-888"></a><span class='hs-comment'>{-# RULES "map/coerce" [1] map coerce = coerce #-}</span>
<a name="line-889"></a>
<a name="line-890"></a>
<a name="line-891"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-892"></a><span class='hs-comment'>--              append</span>
<a name="line-893"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-894"></a>
<a name="line-895"></a><span class='hs-comment'>-- | Append two lists, i.e.,</span>
<a name="line-896"></a><span class='hs-comment'>--</span>
<a name="line-897"></a><span class='hs-comment'>-- &gt; [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]</span>
<a name="line-898"></a><span class='hs-comment'>-- &gt; [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]</span>
<a name="line-899"></a><span class='hs-comment'>--</span>
<a name="line-900"></a><span class='hs-comment'>-- If the first list is not finite, the result is the first list.</span>
<a name="line-901"></a>
<a name="line-902"></a><a name="++"></a><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-903"></a><span class='hs-comment'>{-# NOINLINE [1] (++) #-}</span>    <span class='hs-comment'>-- We want the RULE to fire first.</span>
<a name="line-904"></a>                             <span class='hs-comment'>-- It's recursive, so won't inline anyway,</span>
<a name="line-905"></a>                             <span class='hs-comment'>-- but saying so is more explicit</span>
<a name="line-906"></a><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>     <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span>
<a name="line-907"></a><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ys</span>
<a name="line-908"></a>
<a name="line-909"></a><span class='hs-comment'>{-# RULES
<a name="line-910"></a>"++"    [~1] forall xs ys. xs ++ ys = augment (\c n -&gt; foldr c n xs) ys
<a name="line-911"></a>  #-}</span>
<a name="line-912"></a>
<a name="line-913"></a>
<a name="line-914"></a><span class='hs-comment'>-- |'otherwise' is defined as the value 'True'.  It helps to make</span>
<a name="line-915"></a><span class='hs-comment'>-- guards more readable.  eg.</span>
<a name="line-916"></a><span class='hs-comment'>--</span>
<a name="line-917"></a><span class='hs-comment'>-- &gt;  f x | x &lt; 0     = ...</span>
<a name="line-918"></a><span class='hs-comment'>-- &gt;      | otherwise = ...</span>
<a name="line-919"></a><span class='hs-definition'>otherwise</span>               <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-920"></a><span class='hs-definition'>otherwise</span>               <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>True</span>
<a name="line-921"></a>
<a name="line-922"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-923"></a><span class='hs-comment'>-- Type Char and String</span>
<a name="line-924"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-925"></a>
<a name="line-926"></a><a name="String"></a><span class='hs-comment'>-- | A 'String' is a list of characters.  String constants in Haskell are values</span>
<a name="line-927"></a><a name="String"></a><span class='hs-comment'>-- of type 'String'.</span>
<a name="line-928"></a><a name="String"></a><span class='hs-comment'>--</span>
<a name="line-929"></a><a name="String"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-930"></a>
<a name="line-931"></a><a name="unsafeChr"></a><span class='hs-definition'>unsafeChr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Char</span>
<a name="line-932"></a><span class='hs-definition'>unsafeChr</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>i</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>chr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>i</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-933"></a>
<a name="line-934"></a><a name="ord"></a><span class='hs-comment'>-- | The 'Prelude.fromEnum' method restricted to the type 'Data.Char.Char'.</span>
<a name="line-935"></a><span class='hs-definition'>ord</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Char</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-936"></a><span class='hs-definition'>ord</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-varid'>c</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-varid'>c</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-937"></a>
<a name="line-938"></a><a name="eqString"></a><span class='hs-comment'>-- | This 'String' equality predicate is used when desugaring</span>
<a name="line-939"></a><span class='hs-comment'>-- pattern-matches against strings.</span>
<a name="line-940"></a><span class='hs-definition'>eqString</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-941"></a><span class='hs-definition'>eqString</span> <span class='hs-conid'>[]</span>       <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-942"></a><span class='hs-definition'>eqString</span> <span class='hs-layout'>(</span><span class='hs-varid'>c1</span><span class='hs-conop'>:</span><span class='hs-varid'>cs1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>c2</span><span class='hs-conop'>:</span><span class='hs-varid'>cs2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>c2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>cs1</span> <span class='hs-varop'>`eqString`</span> <span class='hs-varid'>cs2</span>
<a name="line-943"></a><span class='hs-definition'>eqString</span> <span class='hs-keyword'>_</span>        <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-944"></a>
<a name="line-945"></a><span class='hs-comment'>{-# RULES "eqString" (==) = eqString #-}</span>
<a name="line-946"></a><span class='hs-comment'>-- eqString also has a BuiltInRule in PrelRules.lhs:</span>
<a name="line-947"></a><span class='hs-comment'>--      eqString (unpackCString# (Lit s1)) (unpackCString# (Lit s2) = s1==s2</span>
<a name="line-948"></a>
<a name="line-949"></a>
<a name="line-950"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-951"></a><span class='hs-comment'>-- 'Int' related definitions</span>
<a name="line-952"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-953"></a>
<a name="line-954"></a><a name="maxInt"></a><span class='hs-definition'>maxInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>minInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-955"></a>
<a name="line-956"></a><span class='hs-comment'>{- Seems clumsy. Should perhaps put minInt and MaxInt directly into MachDeps.h -}</span>
<a name="line-957"></a><span class='hs-cpp'>#if WORD_SIZE_IN_BITS == 31</span>
<a name="line-958"></a><a name="minInt"></a><span class='hs-definition'>minInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>0x40000000</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-959"></a><span class='hs-definition'>maxInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-num'>0x3FFFFFFF</span><span class='hs-cpp'>#</span>
<a name="line-960"></a><span class='hs-cpp'>#elif WORD_SIZE_IN_BITS == 32</span>
<a name="line-961"></a><span class='hs-definition'>minInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>0x80000000</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-962"></a><span class='hs-definition'>maxInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-num'>0x7FFFFFFF</span><span class='hs-cpp'>#</span>
<a name="line-963"></a><span class='hs-cpp'>#else</span>
<a name="line-964"></a><span class='hs-definition'>minInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>0x8000000000000000</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-965"></a><span class='hs-definition'>maxInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-num'>0x7FFFFFFFFFFFFFFF</span><span class='hs-cpp'>#</span>
<a name="line-966"></a><span class='hs-cpp'>#endif</span>
<a name="line-967"></a>
<a name="line-968"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-969"></a><span class='hs-comment'>-- The function type</span>
<a name="line-970"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-971"></a>
<a name="line-972"></a><a name="id"></a><span class='hs-comment'>-- | Identity function.</span>
<a name="line-973"></a><span class='hs-definition'>id</span>                      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-974"></a><span class='hs-definition'>id</span> <span class='hs-varid'>x</span>                    <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>x</span>
<a name="line-975"></a>
<a name="line-976"></a><span class='hs-comment'>-- Assertion function.  This simply ignores its boolean argument.</span>
<a name="line-977"></a><span class='hs-comment'>-- The compiler may rewrite it to @('assertError' line)@.</span>
<a name="line-978"></a>
<a name="line-979"></a><span class='hs-comment'>-- | If the first argument evaluates to 'True', then the result is the</span>
<a name="line-980"></a><span class='hs-comment'>-- second argument.  Otherwise an 'AssertionFailed' exception is raised,</span>
<a name="line-981"></a><span class='hs-comment'>-- containing a 'String' with the source file and line number of the</span>
<a name="line-982"></a><span class='hs-comment'>-- call to 'assert'.</span>
<a name="line-983"></a><span class='hs-comment'>--</span>
<a name="line-984"></a><span class='hs-comment'>-- Assertions can normally be turned on or off with a compiler flag</span>
<a name="line-985"></a><span class='hs-comment'>-- (for GHC, assertions are normally on unless optimisation is turned on</span>
<a name="line-986"></a><span class='hs-comment'>-- with @-O@ or the @-fignore-asserts@</span>
<a name="line-987"></a><span class='hs-comment'>-- option is given).  When assertions are turned off, the first</span>
<a name="line-988"></a><span class='hs-comment'>-- argument to 'assert' is ignored, and the second argument is</span>
<a name="line-989"></a><span class='hs-comment'>-- returned as the result.</span>
<a name="line-990"></a>
<a name="line-991"></a><a name="assert"></a><span class='hs-comment'>--      SLPJ: in 5.04 etc 'assert' is in GHC.Prim,</span>
<a name="line-992"></a><span class='hs-comment'>--      but from Template Haskell onwards it's simply</span>
<a name="line-993"></a><span class='hs-comment'>--      defined here in Base.lhs</span>
<a name="line-994"></a><span class='hs-definition'>assert</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-995"></a><span class='hs-definition'>assert</span> <span class='hs-sel'>_pred</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-996"></a>
<a name="line-997"></a><a name="breakpoint"></a><span class='hs-definition'>breakpoint</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-998"></a><span class='hs-definition'>breakpoint</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-999"></a>
<a name="line-1000"></a><a name="breakpointCond"></a><span class='hs-definition'>breakpointCond</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1001"></a><span class='hs-definition'>breakpointCond</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-1002"></a>
<a name="line-1003"></a><a name="Opaque"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Opaque</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-conid'>O</span> <span class='hs-varid'>a</span>
<a name="line-1004"></a>
<a name="line-1005"></a><a name="const"></a><span class='hs-comment'>-- | Constant function.</span>
<a name="line-1006"></a><span class='hs-definition'>const</span>                   <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1007"></a><span class='hs-definition'>const</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>x</span>
<a name="line-1008"></a>
<a name="line-1009"></a><a name="."></a><span class='hs-comment'>-- | Function composition.</span>
<a name="line-1010"></a><span class='hs-comment'>{-# INLINE (.) #-}</span>
<a name="line-1011"></a><span class='hs-comment'>-- Make sure it has TWO args only on the left, so that it inlines</span>
<a name="line-1012"></a><span class='hs-comment'>-- when applied to two functions, even if there is no final argument</span>
<a name="line-1013"></a><span class='hs-layout'>(</span><span class='hs-varop'>.</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span>
<a name="line-1014"></a><span class='hs-layout'>(</span><span class='hs-varop'>.</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>g</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1015"></a>
<a name="line-1016"></a><a name="flip"></a><span class='hs-comment'>-- | @'flip' f@ takes its (first) two arguments in the reverse order of @f@.</span>
<a name="line-1017"></a><span class='hs-definition'>flip</span>                    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span>
<a name="line-1018"></a><span class='hs-definition'>flip</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>              <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>f</span> <span class='hs-varid'>y</span> <span class='hs-varid'>x</span>
<a name="line-1019"></a>
<a name="line-1020"></a><a name="$"></a><span class='hs-comment'>-- | Application operator.  This operator is redundant, since ordinary</span>
<a name="line-1021"></a><span class='hs-comment'>-- application @(f x)@ means the same as @(f '$' x)@. However, '$' has</span>
<a name="line-1022"></a><span class='hs-comment'>-- low, right-associative binding precedence, so it sometimes allows</span>
<a name="line-1023"></a><span class='hs-comment'>-- parentheses to be omitted; for example:</span>
<a name="line-1024"></a><span class='hs-comment'>--</span>
<a name="line-1025"></a><span class='hs-comment'>-- &gt;     f $ g $ h x  =  f (g (h x))</span>
<a name="line-1026"></a><span class='hs-comment'>--</span>
<a name="line-1027"></a><span class='hs-comment'>-- It is also useful in higher-order situations, such as @'map' ('$' 0) xs@,</span>
<a name="line-1028"></a><span class='hs-comment'>-- or @'Data.List.zipWith' ('$') fs xs@.</span>
<a name="line-1029"></a><span class='hs-comment'>{-# INLINE ($) #-}</span>
<a name="line-1030"></a><span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span>                     <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-1031"></a><span class='hs-definition'>f</span> <span class='hs-varop'>$</span> <span class='hs-varid'>x</span>                   <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>f</span> <span class='hs-varid'>x</span>
<a name="line-1032"></a>
<a name="line-1033"></a><span class='hs-comment'>-- | Strict (call-by-value) application operator. It takes a function and an</span>
<a name="line-1034"></a><span class='hs-comment'>-- argument, evaluates the argument to weak head normal form (WHNF), then calls</span>
<a name="line-1035"></a><span class='hs-comment'>-- the function with that value.</span>
<a name="line-1036"></a>
<a name="line-1037"></a><a name="$!"></a><span class='hs-layout'>(</span><span class='hs-varop'>$!</span><span class='hs-layout'>)</span>                    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-1038"></a><span class='hs-definition'>f</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>x</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>vx</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>f</span> <span class='hs-varid'>vx</span>  <span class='hs-comment'>-- see #2273</span>
<a name="line-1039"></a>
<a name="line-1040"></a><a name="until"></a><span class='hs-comment'>-- | @'until' p f@ yields the result of applying @f@ until @p@ holds.</span>
<a name="line-1041"></a><span class='hs-definition'>until</span>                   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1042"></a><span class='hs-definition'>until</span> <span class='hs-varid'>p</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span>
<a name="line-1043"></a>  <span class='hs-keyword'>where</span>
<a name="line-1044"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<a name="line-1045"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1046"></a>
<a name="line-1047"></a><a name="asTypeOf"></a><span class='hs-comment'>-- | 'asTypeOf' is a type-restricted version of 'const'.  It is usually</span>
<a name="line-1048"></a><span class='hs-comment'>-- used as an infix operator, and its typing forces its first argument</span>
<a name="line-1049"></a><span class='hs-comment'>-- (which is usually overloaded) to have the same type as the second.</span>
<a name="line-1050"></a><span class='hs-definition'>asTypeOf</span>                <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1051"></a><span class='hs-definition'>asTypeOf</span>                <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>const</span>
<a name="line-1052"></a>
<a name="line-1053"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1054"></a><span class='hs-comment'>-- Functor/Applicative/Monad instances for IO</span>
<a name="line-1055"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1056"></a>
<a name="line-1057"></a><a name="instance%20Functor%20IO"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Functor</span> <span class='hs-conid'>IO</span> <span class='hs-keyword'>where</span>
<a name="line-1058"></a>   <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-1059"></a>
<a name="line-1060"></a><a name="instance%20Applicative%20IO"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>IO</span> <span class='hs-keyword'>where</span>
<a name="line-1061"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span>
<a name="line-1062"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ap</span>
<a name="line-1063"></a>
<a name="line-1064"></a><a name="instance%20Monad%20IO"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Monad</span> <span class='hs-conid'>IO</span>  <span class='hs-keyword'>where</span>
<a name="line-1065"></a>    <span class='hs-comment'>{-# INLINE return #-}</span>
<a name="line-1066"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;)   #-}</span>
<a name="line-1067"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;=)  #-}</span>
<a name="line-1068"></a>    <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>k</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span>
<a name="line-1069"></a>    <span class='hs-varid'>return</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>returnIO</span>
<a name="line-1070"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;=</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bindIO</span>
<a name="line-1071"></a>    <span class='hs-varid'>fail</span> <span class='hs-varid'>s</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failIO</span> <span class='hs-varid'>s</span>
<a name="line-1072"></a>
<a name="line-1073"></a><a name="returnIO"></a><span class='hs-definition'>returnIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-1074"></a><span class='hs-definition'>returnIO</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1075"></a>
<a name="line-1076"></a><a name="bindIO"></a><span class='hs-definition'>bindIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<a name="line-1077"></a><span class='hs-definition'>bindIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>new_s</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_s</span>
<a name="line-1078"></a>
<a name="line-1079"></a><a name="thenIO"></a><span class='hs-definition'>thenIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<a name="line-1080"></a><span class='hs-definition'>thenIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>new_s</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unIO</span> <span class='hs-varid'>k</span> <span class='hs-varid'>new_s</span>
<a name="line-1081"></a>
<a name="line-1082"></a><a name="unIO"></a><span class='hs-definition'>unIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>State</span><span class='hs-cpp'>#</span> <span class='hs-conid'>RealWorld</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-conid'>State</span><span class='hs-cpp'>#</span> <span class='hs-conid'>RealWorld</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1083"></a><span class='hs-definition'>unIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>
<a name="line-1084"></a>
<a name="line-1085"></a><a name="getTag"></a><span class='hs-comment'>{- |
<a name="line-1086"></a>Returns the 'tag' of a constructor application; this function is used
<a name="line-1087"></a>by the deriving code for Eq, Ord and Enum.
<a name="line-1088"></a>
<a name="line-1089"></a>The primitive dataToTag# requires an evaluated constructor application
<a name="line-1090"></a>as its argument, so we provide getTag as a wrapper that performs the
<a name="line-1091"></a>evaluation before calling dataToTag#.  We could have dataToTag#
<a name="line-1092"></a>evaluate its argument, but we prefer to do it this way because (a)
<a name="line-1093"></a>dataToTag# can be an inline primop if it doesn't need to do any
<a name="line-1094"></a>evaluation, and (b) we want to expose the evaluation to the
<a name="line-1095"></a>simplifier, because it might be possible to eliminate the evaluation
<a name="line-1096"></a>in the case when the argument is already known to be evaluated.
<a name="line-1097"></a>-}</span>
<a name="line-1098"></a><span class='hs-comment'>{-# INLINE getTag #-}</span>
<a name="line-1099"></a><span class='hs-definition'>getTag</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1100"></a><a name="!"></a><span class='hs-definition'>getTag</span> <span class='hs-varop'>!</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataToTag</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span>
<a name="line-1101"></a>
<a name="line-1102"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1103"></a><span class='hs-comment'>-- Numeric primops</span>
<a name="line-1104"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1105"></a>
<a name="line-1106"></a><span class='hs-comment'>-- Definitions of the boxed PrimOps; these will be</span>
<a name="line-1107"></a><span class='hs-comment'>-- used in the case of partial applications, etc.</span>
<a name="line-1108"></a>
<a name="line-1109"></a><span class='hs-comment'>{-# INLINE quotInt #-}</span>
<a name="line-1110"></a><span class='hs-comment'>{-# INLINE remInt #-}</span>
<a name="line-1111"></a>
<a name="line-1112"></a><a name="quotInt"></a><span class='hs-definition'>quotInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>remInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>divInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>modInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1113"></a><a name="quotInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`quotInt`</span>  <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1114"></a><a name="remInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`remInt`</span>   <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>remInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1115"></a><a name="divInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`divInt`</span>   <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>divInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1116"></a><a name="modInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`modInt`</span>   <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>modInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1117"></a>
<a name="line-1118"></a><a name="quotRemInt"></a><span class='hs-definition'>quotRemInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<a name="line-1119"></a><a name="quotRemInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`quotRemInt`</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>of</span>
<a name="line-1120"></a>                             <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1121"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-1122"></a>
<a name="line-1123"></a><a name="divModInt"></a><span class='hs-definition'>divModInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<a name="line-1124"></a><a name="divModInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`divModInt`</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>divModInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>of</span>
<a name="line-1125"></a>                            <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-1126"></a>
<a name="line-1127"></a><span class='hs-definition'>divModInt</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1128"></a><a name="x"></a><span class='hs-definition'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>`</span><span class='hs-varid'>divModInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span>
<a name="line-1129"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&gt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&lt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-1130"></a>                                    <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>of</span>
<a name="line-1131"></a>                                      <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-varop'>+#</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>+#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1132"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&lt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&gt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-1133"></a>                                    <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>+#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>of</span>
<a name="line-1134"></a>                                      <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-varop'>+#</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1135"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                                <span class='hs-keyglyph'>=</span>
<a name="line-1136"></a>                                    <span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span>
<a name="line-1137"></a>
<a name="line-1138"></a><span class='hs-comment'>-- Wrappers for the shift operations.  The uncheckedShift# family are</span>
<a name="line-1139"></a><span class='hs-comment'>-- undefined when the amount being shifted by is greater than the size</span>
<a name="line-1140"></a><span class='hs-comment'>-- in bits of Int#, so these wrappers perform a check and return</span>
<a name="line-1141"></a><span class='hs-comment'>-- either zero or -1 appropriately.</span>
<a name="line-1142"></a><span class='hs-comment'>--</span>
<a name="line-1143"></a><span class='hs-comment'>-- Note that these wrappers still produce undefined results when the</span>
<a name="line-1144"></a><span class='hs-comment'>-- second argument (the shift amount) is negative.</span>
<a name="line-1145"></a>
<a name="line-1146"></a><a name="shiftL"></a><span class='hs-comment'>-- | Shift the argument left by the specified number of bits</span>
<a name="line-1147"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1148"></a><span class='hs-definition'>shiftL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span>
<a name="line-1149"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>shiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>##</span>
<a name="line-1150"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1151"></a>
<a name="line-1152"></a><a name="shiftRL"></a><span class='hs-comment'>-- | Shift the argument right by the specified number of bits</span>
<a name="line-1153"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1154"></a><span class='hs-comment'>-- The "RL" means "right, logical" (as opposed to RA for arithmetic)</span>
<a name="line-1155"></a><span class='hs-comment'>-- (although an arithmetic right shift wouldn't make sense for Word#)</span>
<a name="line-1156"></a><span class='hs-definition'>shiftRL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span>
<a name="line-1157"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>shiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>##</span>
<a name="line-1158"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedShiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1159"></a>
<a name="line-1160"></a><a name="iShiftL"></a><span class='hs-comment'>-- | Shift the argument left by the specified number of bits</span>
<a name="line-1161"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1162"></a><span class='hs-definition'>iShiftL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1163"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>iShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-1164"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1165"></a>
<a name="line-1166"></a><a name="iShiftRA"></a><span class='hs-comment'>-- | Shift the argument right (signed) by the specified number of bits</span>
<a name="line-1167"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1168"></a><span class='hs-comment'>-- The "RA" means "right, arithmetic" (as opposed to RL for logical)</span>
<a name="line-1169"></a><span class='hs-definition'>iShiftRA</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1170"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>iShiftRA</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1171"></a>                                                          <span class='hs-keyword'>then</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1172"></a>                                                          <span class='hs-keyword'>else</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-1173"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftRA</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1174"></a>
<a name="line-1175"></a><a name="iShiftRL"></a><span class='hs-comment'>-- | Shift the argument right (unsigned) by the specified number of bits</span>
<a name="line-1176"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1177"></a><span class='hs-comment'>-- The "RL" means "right, logical" (as opposed to RA for arithmetic)</span>
<a name="line-1178"></a><span class='hs-definition'>iShiftRL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1179"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>iShiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-1180"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1181"></a>
<a name="line-1182"></a><span class='hs-comment'>-- Rules for C strings (the functions themselves are now in GHC.CString)</span>
<a name="line-1183"></a><span class='hs-comment'>{-# RULES
<a name="line-1184"></a>"unpack"       [~1] forall a   . unpackCString# a             = build (unpackFoldrCString# a)
<a name="line-1185"></a>"unpack-list"  [1]  forall a   . unpackFoldrCString# a (:) [] = unpackCString# a
<a name="line-1186"></a>"unpack-append"     forall a n . unpackFoldrCString# a (:) n  = unpackAppendCString# a n
<a name="line-1187"></a>
<a name="line-1188"></a>-- There's a built-in rule (in PrelRules.lhs) for
<a name="line-1189"></a>--      unpackFoldr "foo" c (unpackFoldr "baz" c n)  =  unpackFoldr "foobaz" c n
<a name="line-1190"></a>
<a name="line-1191"></a>  #-}</span>
<a name="line-1192"></a>
<a name="line-1193"></a>
<a name="line-1194"></a><span class='hs-cpp'>#ifdef __HADDOCK__</span>
<a name="line-1195"></a><span class='hs-comment'>-- | A special argument for the 'Control.Monad.ST.ST' type constructor,</span>
<a name="line-1196"></a><span class='hs-comment'>-- indexing a state embedded in the 'Prelude.IO' monad by</span>
<a name="line-1197"></a><span class='hs-comment'>-- 'Control.Monad.ST.stToIO'.</span>
<a name="line-1198"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>RealWorld</span>
<a name="line-1199"></a><span class='hs-cpp'>#endif</span>
</pre></body>
</html>

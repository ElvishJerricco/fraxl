<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Control/Concurrent.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE Trustworthy #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE CPP
<a name="line-3"></a>           , MagicHash
<a name="line-4"></a>           , UnboxedTuples
<a name="line-5"></a>           , ScopedTypeVariables
<a name="line-6"></a>  #-}</span>
<a name="line-7"></a><span class='hs-comment'>{-# OPTIONS_GHC -fno-warn-deprecations #-}</span>
<a name="line-8"></a><span class='hs-comment'>-- kludge for the Control.Concurrent.QSem, Control.Concurrent.QSemN</span>
<a name="line-9"></a><span class='hs-comment'>-- and Control.Concurrent.SampleVar imports.</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-12"></a><span class='hs-comment'>-- |</span>
<a name="line-13"></a><span class='hs-comment'>-- Module      :  Control.Concurrent</span>
<a name="line-14"></a><span class='hs-comment'>-- Copyright   :  (c) The University of Glasgow 2001</span>
<a name="line-15"></a><span class='hs-comment'>-- License     :  BSD-style (see the file libraries/base/LICENSE)</span>
<a name="line-16"></a><span class='hs-comment'>--</span>
<a name="line-17"></a><span class='hs-comment'>-- Maintainer  :  libraries@haskell.org</span>
<a name="line-18"></a><span class='hs-comment'>-- Stability   :  experimental</span>
<a name="line-19"></a><span class='hs-comment'>-- Portability :  non-portable (concurrency)</span>
<a name="line-20"></a><span class='hs-comment'>--</span>
<a name="line-21"></a><span class='hs-comment'>-- A common interface to a collection of useful concurrency</span>
<a name="line-22"></a><span class='hs-comment'>-- abstractions.</span>
<a name="line-23"></a><span class='hs-comment'>--</span>
<a name="line-24"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-25"></a>
<a name="line-26"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span> <span class='hs-layout'>(</span>
<a name="line-27"></a>        <span class='hs-comment'>-- * Concurrent Haskell</span>
<a name="line-28"></a>
<a name="line-29"></a>        <span class='hs-comment'>-- $conc_intro</span>
<a name="line-30"></a>
<a name="line-31"></a>        <span class='hs-comment'>-- * Basic concurrency operations</span>
<a name="line-32"></a>
<a name="line-33"></a>        <span class='hs-conid'>ThreadId</span><span class='hs-layout'>,</span>
<a name="line-34"></a>        <span class='hs-varid'>myThreadId</span><span class='hs-layout'>,</span>
<a name="line-35"></a>
<a name="line-36"></a>        <span class='hs-varid'>forkIO</span><span class='hs-layout'>,</span>
<a name="line-37"></a>        <span class='hs-varid'>forkFinally</span><span class='hs-layout'>,</span>
<a name="line-38"></a>        <span class='hs-varid'>forkIOWithUnmask</span><span class='hs-layout'>,</span>
<a name="line-39"></a>        <span class='hs-varid'>killThread</span><span class='hs-layout'>,</span>
<a name="line-40"></a>        <span class='hs-varid'>throwTo</span><span class='hs-layout'>,</span>
<a name="line-41"></a>
<a name="line-42"></a>        <span class='hs-comment'>-- ** Threads with affinity</span>
<a name="line-43"></a>        <span class='hs-varid'>forkOn</span><span class='hs-layout'>,</span>
<a name="line-44"></a>        <span class='hs-varid'>forkOnWithUnmask</span><span class='hs-layout'>,</span>
<a name="line-45"></a>        <span class='hs-varid'>getNumCapabilities</span><span class='hs-layout'>,</span>
<a name="line-46"></a>        <span class='hs-varid'>setNumCapabilities</span><span class='hs-layout'>,</span>
<a name="line-47"></a>        <span class='hs-varid'>threadCapability</span><span class='hs-layout'>,</span>
<a name="line-48"></a>
<a name="line-49"></a>        <span class='hs-comment'>-- * Scheduling</span>
<a name="line-50"></a>
<a name="line-51"></a>        <span class='hs-comment'>-- $conc_scheduling</span>
<a name="line-52"></a>        <span class='hs-varid'>yield</span><span class='hs-layout'>,</span>
<a name="line-53"></a>
<a name="line-54"></a>        <span class='hs-comment'>-- ** Blocking</span>
<a name="line-55"></a>
<a name="line-56"></a>        <span class='hs-comment'>-- $blocking</span>
<a name="line-57"></a>
<a name="line-58"></a>        <span class='hs-comment'>-- ** Waiting</span>
<a name="line-59"></a>        <span class='hs-varid'>threadDelay</span><span class='hs-layout'>,</span>
<a name="line-60"></a>        <span class='hs-varid'>threadWaitRead</span><span class='hs-layout'>,</span>
<a name="line-61"></a>        <span class='hs-varid'>threadWaitWrite</span><span class='hs-layout'>,</span>
<a name="line-62"></a>        <span class='hs-varid'>threadWaitReadSTM</span><span class='hs-layout'>,</span>
<a name="line-63"></a>        <span class='hs-varid'>threadWaitWriteSTM</span><span class='hs-layout'>,</span>
<a name="line-64"></a>
<a name="line-65"></a>        <span class='hs-comment'>-- * Communication abstractions</span>
<a name="line-66"></a>
<a name="line-67"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span><span class='hs-varop'>.</span><span class='hs-conid'>MVar</span><span class='hs-layout'>,</span>
<a name="line-68"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span><span class='hs-varop'>.</span><span class='hs-conid'>Chan</span><span class='hs-layout'>,</span>
<a name="line-69"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span><span class='hs-varop'>.</span><span class='hs-conid'>QSem</span><span class='hs-layout'>,</span>
<a name="line-70"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span><span class='hs-varop'>.</span><span class='hs-conid'>QSemN</span><span class='hs-layout'>,</span>
<a name="line-71"></a>
<a name="line-72"></a>        <span class='hs-comment'>-- * Bound Threads</span>
<a name="line-73"></a>        <span class='hs-comment'>-- $boundthreads</span>
<a name="line-74"></a>        <span class='hs-varid'>rtsSupportsBoundThreads</span><span class='hs-layout'>,</span>
<a name="line-75"></a>        <span class='hs-varid'>forkOS</span><span class='hs-layout'>,</span>
<a name="line-76"></a>        <span class='hs-varid'>isCurrentThreadBound</span><span class='hs-layout'>,</span>
<a name="line-77"></a>        <span class='hs-varid'>runInBoundThread</span><span class='hs-layout'>,</span>
<a name="line-78"></a>        <span class='hs-varid'>runInUnboundThread</span><span class='hs-layout'>,</span>
<a name="line-79"></a>
<a name="line-80"></a>        <span class='hs-comment'>-- * Weak references to ThreadIds</span>
<a name="line-81"></a>        <span class='hs-varid'>mkWeakThreadId</span><span class='hs-layout'>,</span>
<a name="line-82"></a>
<a name="line-83"></a>        <span class='hs-comment'>-- * GHC's implementation of concurrency</span>
<a name="line-84"></a>
<a name="line-85"></a>        <span class='hs-comment'>-- |This section describes features specific to GHC's</span>
<a name="line-86"></a>        <span class='hs-comment'>-- implementation of Concurrent Haskell.</span>
<a name="line-87"></a>
<a name="line-88"></a>        <span class='hs-comment'>-- ** Haskell threads and Operating System threads</span>
<a name="line-89"></a>
<a name="line-90"></a>        <span class='hs-comment'>-- $osthreads</span>
<a name="line-91"></a>
<a name="line-92"></a>        <span class='hs-comment'>-- ** Terminating the program</span>
<a name="line-93"></a>
<a name="line-94"></a>        <span class='hs-comment'>-- $termination</span>
<a name="line-95"></a>
<a name="line-96"></a>        <span class='hs-comment'>-- ** Pre-emption</span>
<a name="line-97"></a>
<a name="line-98"></a>        <span class='hs-comment'>-- $preemption</span>
<a name="line-99"></a>
<a name="line-100"></a>        <span class='hs-comment'>-- ** Deadlock</span>
<a name="line-101"></a>
<a name="line-102"></a>        <span class='hs-comment'>-- $deadlock</span>
<a name="line-103"></a>
<a name="line-104"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-105"></a>
<a name="line-106"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Exception</span><span class='hs-varop'>.</span><span class='hs-conid'>Base</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Exception</span>
<a name="line-107"></a>
<a name="line-108"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Conc</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>threadWaitRead</span><span class='hs-layout'>,</span> <span class='hs-varid'>threadWaitWrite</span><span class='hs-layout'>,</span>
<a name="line-109"></a>                        <span class='hs-varid'>threadWaitReadSTM</span><span class='hs-layout'>,</span> <span class='hs-varid'>threadWaitWriteSTM</span><span class='hs-layout'>)</span>
<a name="line-110"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>IO</span>           <span class='hs-layout'>(</span> <span class='hs-varid'>unsafeUnmask</span> <span class='hs-layout'>)</span>
<a name="line-111"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>IORef</span>        <span class='hs-layout'>(</span> <span class='hs-varid'>newIORef</span><span class='hs-layout'>,</span> <span class='hs-varid'>readIORef</span><span class='hs-layout'>,</span> <span class='hs-varid'>writeIORef</span> <span class='hs-layout'>)</span>
<a name="line-112"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Base</span>
<a name="line-113"></a>
<a name="line-114"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>System</span><span class='hs-varop'>.</span><span class='hs-conid'>Posix</span><span class='hs-varop'>.</span><span class='hs-conid'>Types</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Fd</span> <span class='hs-layout'>)</span>
<a name="line-115"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign</span><span class='hs-varop'>.</span><span class='hs-conid'>StablePtr</span>
<a name="line-116"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign</span><span class='hs-varop'>.</span><span class='hs-conid'>C</span><span class='hs-varop'>.</span><span class='hs-conid'>Types</span>
<a name="line-117"></a>
<a name="line-118"></a><span class='hs-cpp'>#ifdef mingw32_HOST_OS</span>
<a name="line-119"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign</span><span class='hs-varop'>.</span><span class='hs-conid'>C</span>
<a name="line-120"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>System</span><span class='hs-varop'>.</span><span class='hs-conid'>IO</span>
<a name="line-121"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span> <span class='hs-varid'>void</span> <span class='hs-layout'>)</span>
<a name="line-122"></a><span class='hs-cpp'>#else</span>
<a name="line-123"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Conc</span>
<a name="line-124"></a><span class='hs-cpp'>#endif</span>
<a name="line-125"></a>
<a name="line-126"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span><span class='hs-varop'>.</span><span class='hs-conid'>MVar</span>
<a name="line-127"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span><span class='hs-varop'>.</span><span class='hs-conid'>Chan</span>
<a name="line-128"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span><span class='hs-varop'>.</span><span class='hs-conid'>QSem</span>
<a name="line-129"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span><span class='hs-varop'>.</span><span class='hs-conid'>QSemN</span>
<a name="line-130"></a>
<a name="line-131"></a><span class='hs-comment'>{- $conc_intro
<a name="line-132"></a>
<a name="line-133"></a>The concurrency extension for Haskell is described in the paper
<a name="line-134"></a>/Concurrent Haskell/
<a name="line-135"></a>&lt;<a href="http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz">http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz</a>&gt;.
<a name="line-136"></a>
<a name="line-137"></a>Concurrency is \"lightweight\", which means that both thread creation
<a name="line-138"></a>and context switching overheads are extremely low.  Scheduling of
<a name="line-139"></a>Haskell threads is done internally in the Haskell runtime system, and
<a name="line-140"></a>doesn't make use of any operating system-supplied thread packages.
<a name="line-141"></a>
<a name="line-142"></a>However, if you want to interact with a foreign library that expects your
<a name="line-143"></a>program to use the operating system-supplied thread package, you can do so
<a name="line-144"></a>by using 'forkOS' instead of 'forkIO'.
<a name="line-145"></a>
<a name="line-146"></a>Haskell threads can communicate via 'MVar's, a kind of synchronised
<a name="line-147"></a>mutable variable (see "Control.Concurrent.MVar").  Several common
<a name="line-148"></a>concurrency abstractions can be built from 'MVar's, and these are
<a name="line-149"></a>provided by the "Control.Concurrent" library.
<a name="line-150"></a>In GHC, threads may also communicate via exceptions.
<a name="line-151"></a>-}</span>
<a name="line-152"></a>
<a name="line-153"></a><span class='hs-comment'>{- $conc_scheduling
<a name="line-154"></a>
<a name="line-155"></a>    Scheduling may be either pre-emptive or co-operative,
<a name="line-156"></a>    depending on the implementation of Concurrent Haskell (see below
<a name="line-157"></a>    for information related to specific compilers).  In a co-operative
<a name="line-158"></a>    system, context switches only occur when you use one of the
<a name="line-159"></a>    primitives defined in this module.  This means that programs such
<a name="line-160"></a>    as:
<a name="line-161"></a>
<a name="line-162"></a>
<a name="line-163"></a>&gt;   main = forkIO (write 'a') &gt;&gt; write 'b'
<a name="line-164"></a>&gt;     where write c = putChar c &gt;&gt; write c
<a name="line-165"></a>
<a name="line-166"></a>    will print either @aaaaaaaaaaaaaa...@ or @bbbbbbbbbbbb...@,
<a name="line-167"></a>    instead of some random interleaving of @a@s and @b@s.  In
<a name="line-168"></a>    practice, cooperative multitasking is sufficient for writing
<a name="line-169"></a>    simple graphical user interfaces.
<a name="line-170"></a>-}</span>
<a name="line-171"></a>
<a name="line-172"></a><span class='hs-comment'>{- $blocking
<a name="line-173"></a>Different Haskell implementations have different characteristics with
<a name="line-174"></a>regard to which operations block /all/ threads.
<a name="line-175"></a>
<a name="line-176"></a>Using GHC without the @-threaded@ option, all foreign calls will block
<a name="line-177"></a>all other Haskell threads in the system, although I\/O operations will
<a name="line-178"></a>not.  With the @-threaded@ option, only foreign calls with the @unsafe@
<a name="line-179"></a>attribute will block all other threads.
<a name="line-180"></a>
<a name="line-181"></a>-}</span>
<a name="line-182"></a>
<a name="line-183"></a><a name="forkFinally"></a><span class='hs-comment'>-- | fork a thread and call the supplied function when the thread is about</span>
<a name="line-184"></a><span class='hs-comment'>-- to terminate, with an exception or a returned value.  The function is</span>
<a name="line-185"></a><span class='hs-comment'>-- called with asynchronous exceptions masked.</span>
<a name="line-186"></a><span class='hs-comment'>--</span>
<a name="line-187"></a><span class='hs-comment'>-- &gt; forkFinally action and_then =</span>
<a name="line-188"></a><span class='hs-comment'>-- &gt;   mask $ \restore -&gt;</span>
<a name="line-189"></a><span class='hs-comment'>-- &gt;     forkIO $ try (restore action) &gt;&gt;= and_then</span>
<a name="line-190"></a><span class='hs-comment'>--</span>
<a name="line-191"></a><span class='hs-comment'>-- This function is useful for informing the parent when a child</span>
<a name="line-192"></a><span class='hs-comment'>-- terminates, for example.</span>
<a name="line-193"></a><span class='hs-comment'>--</span>
<a name="line-194"></a><span class='hs-comment'>-- @since 4.6.0.0</span>
<a name="line-195"></a><span class='hs-definition'>forkFinally</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-conid'>SomeException</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ThreadId</span>
<a name="line-196"></a><span class='hs-definition'>forkFinally</span> <span class='hs-varid'>action</span> <span class='hs-varid'>and_then</span> <span class='hs-keyglyph'>=</span>
<a name="line-197"></a>  <span class='hs-varid'>mask</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>restore</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-198"></a>    <span class='hs-varid'>forkIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>try</span> <span class='hs-layout'>(</span><span class='hs-varid'>restore</span> <span class='hs-varid'>action</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>and_then</span>
<a name="line-199"></a>
<a name="line-200"></a><span class='hs-comment'>-- ---------------------------------------------------------------------------</span>
<a name="line-201"></a><span class='hs-comment'>-- Bound Threads</span>
<a name="line-202"></a>
<a name="line-203"></a><span class='hs-comment'>{- $boundthreads
<a name="line-204"></a>   #boundthreads#
<a name="line-205"></a>
<a name="line-206"></a>Support for multiple operating system threads and bound threads as described
<a name="line-207"></a>below is currently only available in the GHC runtime system if you use the
<a name="line-208"></a>/-threaded/ option when linking.
<a name="line-209"></a>
<a name="line-210"></a>Other Haskell systems do not currently support multiple operating system threads.
<a name="line-211"></a>
<a name="line-212"></a>A bound thread is a haskell thread that is /bound/ to an operating system
<a name="line-213"></a>thread. While the bound thread is still scheduled by the Haskell run-time
<a name="line-214"></a>system, the operating system thread takes care of all the foreign calls made
<a name="line-215"></a>by the bound thread.
<a name="line-216"></a>
<a name="line-217"></a>To a foreign library, the bound thread will look exactly like an ordinary
<a name="line-218"></a>operating system thread created using OS functions like @pthread_create@
<a name="line-219"></a>or @CreateThread@.
<a name="line-220"></a>
<a name="line-221"></a>Bound threads can be created using the 'forkOS' function below. All foreign
<a name="line-222"></a>exported functions are run in a bound thread (bound to the OS thread that
<a name="line-223"></a>called the function). Also, the @main@ action of every Haskell program is
<a name="line-224"></a>run in a bound thread.
<a name="line-225"></a>
<a name="line-226"></a>Why do we need this? Because if a foreign library is called from a thread
<a name="line-227"></a>created using 'forkIO', it won't have access to any /thread-local state/ -
<a name="line-228"></a>state variables that have specific values for each OS thread
<a name="line-229"></a>(see POSIX's @pthread_key_create@ or Win32's @TlsAlloc@). Therefore, some
<a name="line-230"></a>libraries (OpenGL, for example) will not work from a thread created using
<a name="line-231"></a>'forkIO'. They work fine in threads created using 'forkOS' or when called
<a name="line-232"></a>from @main@ or from a @foreign export@.
<a name="line-233"></a>
<a name="line-234"></a>In terms of performance, 'forkOS' (aka bound) threads are much more
<a name="line-235"></a>expensive than 'forkIO' (aka unbound) threads, because a 'forkOS'
<a name="line-236"></a>thread is tied to a particular OS thread, whereas a 'forkIO' thread
<a name="line-237"></a>can be run by any OS thread.  Context-switching between a 'forkOS'
<a name="line-238"></a>thread and a 'forkIO' thread is many times more expensive than between
<a name="line-239"></a>two 'forkIO' threads.
<a name="line-240"></a>
<a name="line-241"></a>Note in particular that the main program thread (the thread running
<a name="line-242"></a>@Main.main@) is always a bound thread, so for good concurrency
<a name="line-243"></a>performance you should ensure that the main thread is not doing
<a name="line-244"></a>repeated communication with other threads in the system.  Typically
<a name="line-245"></a>this means forking subthreads to do the work using 'forkIO', and
<a name="line-246"></a>waiting for the results in the main thread.
<a name="line-247"></a>
<a name="line-248"></a>-}</span>
<a name="line-249"></a>
<a name="line-250"></a><span class='hs-comment'>-- | 'True' if bound threads are supported.</span>
<a name="line-251"></a><span class='hs-comment'>-- If @rtsSupportsBoundThreads@ is 'False', 'isCurrentThreadBound'</span>
<a name="line-252"></a><span class='hs-comment'>-- will always return 'False' and both 'forkOS' and 'runInBoundThread' will</span>
<a name="line-253"></a><span class='hs-comment'>-- fail.</span>
<a name="line-254"></a><span class='hs-keyword'>foreign</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>ccall</span> <span class='hs-varid'>rtsSupportsBoundThreads</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-255"></a>
<a name="line-256"></a>
<a name="line-257"></a><span class='hs-comment'>{- |
<a name="line-258"></a>Like 'forkIO', this sparks off a new thread to run the 'IO'
<a name="line-259"></a>computation passed as the first argument, and returns the 'ThreadId'
<a name="line-260"></a>of the newly created thread.
<a name="line-261"></a>
<a name="line-262"></a>However, 'forkOS' creates a /bound/ thread, which is necessary if you
<a name="line-263"></a>need to call foreign (non-Haskell) libraries that make use of
<a name="line-264"></a>thread-local state, such as OpenGL (see "Control.Concurrent#boundthreads").
<a name="line-265"></a>
<a name="line-266"></a>Using 'forkOS' instead of 'forkIO' makes no difference at all to the
<a name="line-267"></a>scheduling behaviour of the Haskell runtime system.  It is a common
<a name="line-268"></a>misconception that you need to use 'forkOS' instead of 'forkIO' to
<a name="line-269"></a>avoid blocking all the Haskell threads when making a foreign call;
<a name="line-270"></a>this isn't the case.  To allow foreign calls to be made without
<a name="line-271"></a>blocking all the Haskell threads (with GHC), it is only necessary to
<a name="line-272"></a>use the @-threaded@ option when linking your program, and to make sure
<a name="line-273"></a>the foreign import is not marked @unsafe@.
<a name="line-274"></a>-}</span>
<a name="line-275"></a>
<a name="line-276"></a><a name="forkOS"></a><span class='hs-definition'>forkOS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>ThreadId</span>
<a name="line-277"></a>
<a name="line-278"></a><span class='hs-keyword'>foreign</span> <span class='hs-varid'>export</span> <span class='hs-keyword'>ccall</span> <span class='hs-varid'>forkOS_entry</span>
<a name="line-279"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StablePtr</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-280"></a>
<a name="line-281"></a><span class='hs-keyword'>foreign</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>ccall</span> <span class='hs-str'>"forkOS_entry"</span> <span class='hs-varid'>forkOS_entry_reimported</span>
<a name="line-282"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StablePtr</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-283"></a>
<a name="line-284"></a><a name="forkOS_entry"></a><span class='hs-definition'>forkOS_entry</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StablePtr</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-285"></a><span class='hs-definition'>forkOS_entry</span> <span class='hs-varid'>stableAction</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-286"></a>        <span class='hs-varid'>action</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>deRefStablePtr</span> <span class='hs-varid'>stableAction</span>
<a name="line-287"></a>        <span class='hs-varid'>action</span>
<a name="line-288"></a>
<a name="line-289"></a><span class='hs-keyword'>foreign</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>ccall</span> <span class='hs-varid'>forkOS_createThread</span>
<a name="line-290"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StablePtr</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CInt</span>
<a name="line-291"></a>
<a name="line-292"></a><a name="failNonThreaded"></a><span class='hs-definition'>failNonThreaded</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-293"></a><span class='hs-definition'>failNonThreaded</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fail</span> <span class='hs-varop'>$</span> <span class='hs-str'>"RTS doesn't support multiple OS threads "</span>
<a name="line-294"></a>                       <span class='hs-varop'>++</span><span class='hs-str'>"(use ghc -threaded when linking)"</span>
<a name="line-295"></a>
<a name="line-296"></a><span class='hs-definition'>forkOS</span> <span class='hs-varid'>action0</span>
<a name="line-297"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>rtsSupportsBoundThreads</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-298"></a>        <span class='hs-varid'>mv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newEmptyMVar</span>
<a name="line-299"></a>        <span class='hs-varid'>b</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>Exception</span><span class='hs-varop'>.</span><span class='hs-varid'>getMaskingState</span>
<a name="line-300"></a>        <span class='hs-keyword'>let</span>
<a name="line-301"></a>            <span class='hs-comment'>-- async exceptions are masked in the child if they are masked</span>
<a name="line-302"></a>            <span class='hs-comment'>-- in the parent, as for forkIO (see #1048). forkOS_createThread</span>
<a name="line-303"></a>            <span class='hs-comment'>-- creates a thread with exceptions masked by default.</span>
<a name="line-304"></a>            <span class='hs-varid'>action1</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>of</span>
<a name="line-305"></a>                        <span class='hs-conid'>Unmasked</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unsafeUnmask</span> <span class='hs-varid'>action0</span>
<a name="line-306"></a>                        <span class='hs-conid'>MaskedInterruptible</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>action0</span>
<a name="line-307"></a>                        <span class='hs-conid'>MaskedUninterruptible</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>uninterruptibleMask_</span> <span class='hs-varid'>action0</span>
<a name="line-308"></a>
<a name="line-309"></a>            <span class='hs-varid'>action_plus</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Exception</span><span class='hs-varop'>.</span><span class='hs-varid'>catch</span> <span class='hs-varid'>action1</span> <span class='hs-varid'>childHandler</span>
<a name="line-310"></a>
<a name="line-311"></a>        <span class='hs-varid'>entry</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newStablePtr</span> <span class='hs-layout'>(</span><span class='hs-varid'>myThreadId</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>putMVar</span> <span class='hs-varid'>mv</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>action_plus</span><span class='hs-layout'>)</span>
<a name="line-312"></a>        <span class='hs-varid'>err</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>forkOS_createThread</span> <span class='hs-varid'>entry</span>
<a name="line-313"></a>        <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>err</span> <span class='hs-varop'>/=</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fail</span> <span class='hs-str'>"Cannot create OS thread."</span>
<a name="line-314"></a>        <span class='hs-varid'>tid</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>takeMVar</span> <span class='hs-varid'>mv</span>
<a name="line-315"></a>        <span class='hs-varid'>freeStablePtr</span> <span class='hs-varid'>entry</span>
<a name="line-316"></a>        <span class='hs-varid'>return</span> <span class='hs-varid'>tid</span>
<a name="line-317"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failNonThreaded</span>
<a name="line-318"></a>
<a name="line-319"></a><a name="isCurrentThreadBound"></a><span class='hs-comment'>-- | Returns 'True' if the calling thread is /bound/, that is, if it is</span>
<a name="line-320"></a><span class='hs-comment'>-- safe to use foreign libraries that rely on thread-local state from the</span>
<a name="line-321"></a><span class='hs-comment'>-- calling thread.</span>
<a name="line-322"></a><span class='hs-definition'>isCurrentThreadBound</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Bool</span>
<a name="line-323"></a><span class='hs-definition'>isCurrentThreadBound</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>s</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-324"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>isCurrentThreadBound</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>of</span>
<a name="line-325"></a>        <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s2</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>flg</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s2</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>flg</span> <span class='hs-varop'>/=#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-326"></a>
<a name="line-327"></a>
<a name="line-328"></a><a name="runInBoundThread"></a><span class='hs-comment'>{- |
<a name="line-329"></a>Run the 'IO' computation passed as the first argument. If the calling thread
<a name="line-330"></a>is not /bound/, a bound thread is created temporarily. @runInBoundThread@
<a name="line-331"></a>doesn't finish until the 'IO' computation finishes.
<a name="line-332"></a>
<a name="line-333"></a>You can wrap a series of foreign function calls that rely on thread-local state
<a name="line-334"></a>with @runInBoundThread@ so that you can use them without knowing whether the
<a name="line-335"></a>current thread is /bound/.
<a name="line-336"></a>-}</span>
<a name="line-337"></a><span class='hs-definition'>runInBoundThread</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-338"></a>
<a name="line-339"></a><span class='hs-definition'>runInBoundThread</span> <span class='hs-varid'>action</span>
<a name="line-340"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>rtsSupportsBoundThreads</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-341"></a>        <span class='hs-varid'>bound</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isCurrentThreadBound</span>
<a name="line-342"></a>        <span class='hs-keyword'>if</span> <span class='hs-varid'>bound</span>
<a name="line-343"></a>            <span class='hs-keyword'>then</span> <span class='hs-varid'>action</span>
<a name="line-344"></a>            <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-345"></a>                <span class='hs-varid'>ref</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newIORef</span> <span class='hs-varid'>undefined</span>
<a name="line-346"></a>                <span class='hs-keyword'>let</span> <span class='hs-varid'>action_plus</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Exception</span><span class='hs-varop'>.</span><span class='hs-varid'>try</span> <span class='hs-varid'>action</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>writeIORef</span> <span class='hs-varid'>ref</span>
<a name="line-347"></a>                <span class='hs-varid'>bracket</span> <span class='hs-layout'>(</span><span class='hs-varid'>newStablePtr</span> <span class='hs-varid'>action_plus</span><span class='hs-layout'>)</span>
<a name="line-348"></a>                        <span class='hs-varid'>freeStablePtr</span>
<a name="line-349"></a>                        <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>cEntry</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>forkOS_entry_reimported</span> <span class='hs-varid'>cEntry</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>readIORef</span> <span class='hs-varid'>ref</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span>
<a name="line-350"></a>                  <span class='hs-varid'>unsafeResult</span>
<a name="line-351"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failNonThreaded</span>
<a name="line-352"></a>
<a name="line-353"></a><a name="runInUnboundThread"></a><span class='hs-comment'>{- |
<a name="line-354"></a>Run the 'IO' computation passed as the first argument. If the calling thread
<a name="line-355"></a>is /bound/, an unbound thread is created temporarily using 'forkIO'.
<a name="line-356"></a>@runInBoundThread@ doesn't finish until the 'IO' computation finishes.
<a name="line-357"></a>
<a name="line-358"></a>Use this function /only/ in the rare case that you have actually observed a
<a name="line-359"></a>performance loss due to the use of bound threads. A program that
<a name="line-360"></a>doesn't need its main thread to be bound and makes /heavy/ use of concurrency
<a name="line-361"></a>(e.g. a web server), might want to wrap its @main@ action in
<a name="line-362"></a>@runInUnboundThread@.
<a name="line-363"></a>
<a name="line-364"></a>Note that exceptions which are thrown to the current thread are thrown in turn
<a name="line-365"></a>to the thread that is executing the given computation. This ensures there's
<a name="line-366"></a>always a way of killing the forked thread.
<a name="line-367"></a>-}</span>
<a name="line-368"></a><span class='hs-definition'>runInUnboundThread</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-369"></a>
<a name="line-370"></a><span class='hs-definition'>runInUnboundThread</span> <span class='hs-varid'>action</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-371"></a>  <span class='hs-varid'>bound</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isCurrentThreadBound</span>
<a name="line-372"></a>  <span class='hs-keyword'>if</span> <span class='hs-varid'>bound</span>
<a name="line-373"></a>    <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span>
<a name="line-374"></a>      <span class='hs-varid'>mv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newEmptyMVar</span>
<a name="line-375"></a>      <span class='hs-varid'>mask</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>restore</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-376"></a>        <span class='hs-varid'>tid</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>forkIO</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Exception</span><span class='hs-varop'>.</span><span class='hs-varid'>try</span> <span class='hs-layout'>(</span><span class='hs-varid'>restore</span> <span class='hs-varid'>action</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>putMVar</span> <span class='hs-varid'>mv</span>
<a name="line-377"></a>        <span class='hs-keyword'>let</span> <span class='hs-varid'>wait</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>takeMVar</span> <span class='hs-varid'>mv</span> <span class='hs-varop'>`</span><span class='hs-conid'>Exception</span><span class='hs-varop'>.</span><span class='hs-varid'>catch</span><span class='hs-varop'>`</span> <span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SomeException</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-378"></a>                     <span class='hs-conid'>Exception</span><span class='hs-varop'>.</span><span class='hs-varid'>throwTo</span> <span class='hs-varid'>tid</span> <span class='hs-varid'>e</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>wait</span>
<a name="line-379"></a>        <span class='hs-varid'>wait</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>unsafeResult</span>
<a name="line-380"></a>    <span class='hs-keyword'>else</span> <span class='hs-varid'>action</span>
<a name="line-381"></a>
<a name="line-382"></a><a name="unsafeResult"></a><span class='hs-definition'>unsafeResult</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Either</span> <span class='hs-conid'>SomeException</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-383"></a><span class='hs-definition'>unsafeResult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>either</span> <span class='hs-conid'>Exception</span><span class='hs-varop'>.</span><span class='hs-varid'>throwIO</span> <span class='hs-varid'>return</span>
<a name="line-384"></a>
<a name="line-385"></a><span class='hs-comment'>-- ---------------------------------------------------------------------------</span>
<a name="line-386"></a><span class='hs-comment'>-- threadWaitRead/threadWaitWrite</span>
<a name="line-387"></a>
<a name="line-388"></a><a name="threadWaitRead"></a><span class='hs-comment'>-- | Block the current thread until data is available to read on the</span>
<a name="line-389"></a><span class='hs-comment'>-- given file descriptor (GHC only).</span>
<a name="line-390"></a><span class='hs-comment'>--</span>
<a name="line-391"></a><span class='hs-comment'>-- This will throw an 'IOError' if the file descriptor was closed</span>
<a name="line-392"></a><span class='hs-comment'>-- while this thread was blocked.  To safely close a file descriptor</span>
<a name="line-393"></a><span class='hs-comment'>-- that has been used with 'threadWaitRead', use</span>
<a name="line-394"></a><span class='hs-comment'>-- 'GHC.Conc.closeFdWith'.</span>
<a name="line-395"></a><span class='hs-definition'>threadWaitRead</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Fd</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-396"></a><span class='hs-definition'>threadWaitRead</span> <span class='hs-varid'>fd</span>
<a name="line-397"></a><span class='hs-cpp'>#ifdef mingw32_HOST_OS</span>
<a name="line-398"></a>  <span class='hs-comment'>-- we have no IO manager implementing threadWaitRead on Windows.</span>
<a name="line-399"></a>  <span class='hs-comment'>-- fdReady does the right thing, but we have to call it in a</span>
<a name="line-400"></a>  <span class='hs-comment'>-- separate thread, otherwise threadWaitRead won't be interruptible,</span>
<a name="line-401"></a>  <span class='hs-comment'>-- and this only works with -threaded.</span>
<a name="line-402"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>threaded</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>withThread</span> <span class='hs-layout'>(</span><span class='hs-varid'>waitFd</span> <span class='hs-varid'>fd</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span>
<a name="line-403"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fd</span> <span class='hs-keyword'>of</span>
<a name="line-404"></a>                  <span class='hs-num'>0</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>hWaitForInput</span> <span class='hs-varid'>stdin</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<a name="line-405"></a>                          <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-406"></a>                        <span class='hs-comment'>-- hWaitForInput does work properly, but we can only</span>
<a name="line-407"></a>                        <span class='hs-comment'>-- do this for stdin since we know its FD.</span>
<a name="line-408"></a>                  <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"threadWaitRead requires -threaded on Windows, or use System.IO.hWaitForInput"</span>
<a name="line-409"></a><span class='hs-cpp'>#else</span>
<a name="line-410"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Conc</span><span class='hs-varop'>.</span><span class='hs-varid'>threadWaitRead</span> <span class='hs-varid'>fd</span>
<a name="line-411"></a><span class='hs-cpp'>#endif</span>
<a name="line-412"></a>
<a name="line-413"></a><a name="threadWaitWrite"></a><span class='hs-comment'>-- | Block the current thread until data can be written to the</span>
<a name="line-414"></a><span class='hs-comment'>-- given file descriptor (GHC only).</span>
<a name="line-415"></a><span class='hs-comment'>--</span>
<a name="line-416"></a><span class='hs-comment'>-- This will throw an 'IOError' if the file descriptor was closed</span>
<a name="line-417"></a><span class='hs-comment'>-- while this thread was blocked.  To safely close a file descriptor</span>
<a name="line-418"></a><span class='hs-comment'>-- that has been used with 'threadWaitWrite', use</span>
<a name="line-419"></a><span class='hs-comment'>-- 'GHC.Conc.closeFdWith'.</span>
<a name="line-420"></a><span class='hs-definition'>threadWaitWrite</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Fd</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-421"></a><span class='hs-definition'>threadWaitWrite</span> <span class='hs-varid'>fd</span>
<a name="line-422"></a><span class='hs-cpp'>#ifdef mingw32_HOST_OS</span>
<a name="line-423"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>threaded</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>withThread</span> <span class='hs-layout'>(</span><span class='hs-varid'>waitFd</span> <span class='hs-varid'>fd</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<a name="line-424"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"threadWaitWrite requires -threaded on Windows"</span>
<a name="line-425"></a><span class='hs-cpp'>#else</span>
<a name="line-426"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Conc</span><span class='hs-varop'>.</span><span class='hs-varid'>threadWaitWrite</span> <span class='hs-varid'>fd</span>
<a name="line-427"></a><span class='hs-cpp'>#endif</span>
<a name="line-428"></a>
<a name="line-429"></a><a name="threadWaitReadSTM"></a><span class='hs-comment'>-- | Returns an STM action that can be used to wait for data</span>
<a name="line-430"></a><span class='hs-comment'>-- to read from a file descriptor. The second returned value</span>
<a name="line-431"></a><span class='hs-comment'>-- is an IO action that can be used to deregister interest</span>
<a name="line-432"></a><span class='hs-comment'>-- in the file descriptor.</span>
<a name="line-433"></a><span class='hs-comment'>--</span>
<a name="line-434"></a><span class='hs-comment'>-- @since 4.7.0.0</span>
<a name="line-435"></a><span class='hs-definition'>threadWaitReadSTM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Fd</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>STM</span> <span class='hs-conid'>()</span><span class='hs-layout'>,</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<a name="line-436"></a><span class='hs-definition'>threadWaitReadSTM</span> <span class='hs-varid'>fd</span>
<a name="line-437"></a><span class='hs-cpp'>#ifdef mingw32_HOST_OS</span>
<a name="line-438"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>threaded</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTVarIO</span> <span class='hs-conid'>Nothing</span>
<a name="line-439"></a>                  <span class='hs-varid'>mask_</span> <span class='hs-varop'>$</span> <span class='hs-varid'>void</span> <span class='hs-varop'>$</span> <span class='hs-varid'>forkIO</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>result</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>try</span> <span class='hs-layout'>(</span><span class='hs-varid'>waitFd</span> <span class='hs-varid'>fd</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span>
<a name="line-440"></a>                                             <span class='hs-varid'>atomically</span> <span class='hs-layout'>(</span><span class='hs-varid'>writeTVar</span> <span class='hs-varid'>v</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>result</span><span class='hs-layout'>)</span>
<a name="line-441"></a>                  <span class='hs-keyword'>let</span> <span class='hs-varid'>waitAction</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>result</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readTVar</span> <span class='hs-varid'>v</span>
<a name="line-442"></a>                                      <span class='hs-keyword'>case</span> <span class='hs-varid'>result</span> <span class='hs-keyword'>of</span>
<a name="line-443"></a>                                        <span class='hs-conid'>Nothing</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>retry</span>
<a name="line-444"></a>                                        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-445"></a>                                        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>throwSTM</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IOException</span><span class='hs-layout'>)</span>
<a name="line-446"></a>                  <span class='hs-keyword'>let</span> <span class='hs-varid'>killAction</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-447"></a>                  <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>waitAction</span><span class='hs-layout'>,</span> <span class='hs-varid'>killAction</span><span class='hs-layout'>)</span>
<a name="line-448"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"threadWaitReadSTM requires -threaded on Windows"</span>
<a name="line-449"></a><span class='hs-cpp'>#else</span>
<a name="line-450"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Conc</span><span class='hs-varop'>.</span><span class='hs-varid'>threadWaitReadSTM</span> <span class='hs-varid'>fd</span>
<a name="line-451"></a><span class='hs-cpp'>#endif</span>
<a name="line-452"></a>
<a name="line-453"></a><a name="threadWaitWriteSTM"></a><span class='hs-comment'>-- | Returns an STM action that can be used to wait until data</span>
<a name="line-454"></a><span class='hs-comment'>-- can be written to a file descriptor. The second returned value</span>
<a name="line-455"></a><span class='hs-comment'>-- is an IO action that can be used to deregister interest</span>
<a name="line-456"></a><span class='hs-comment'>-- in the file descriptor.</span>
<a name="line-457"></a><span class='hs-comment'>--</span>
<a name="line-458"></a><span class='hs-comment'>-- @since 4.7.0.0</span>
<a name="line-459"></a><span class='hs-definition'>threadWaitWriteSTM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Fd</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>STM</span> <span class='hs-conid'>()</span><span class='hs-layout'>,</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<a name="line-460"></a><span class='hs-definition'>threadWaitWriteSTM</span> <span class='hs-varid'>fd</span>
<a name="line-461"></a><span class='hs-cpp'>#ifdef mingw32_HOST_OS</span>
<a name="line-462"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>threaded</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTVarIO</span> <span class='hs-conid'>Nothing</span>
<a name="line-463"></a>                  <span class='hs-varid'>mask_</span> <span class='hs-varop'>$</span> <span class='hs-varid'>void</span> <span class='hs-varop'>$</span> <span class='hs-varid'>forkIO</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>result</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>try</span> <span class='hs-layout'>(</span><span class='hs-varid'>waitFd</span> <span class='hs-varid'>fd</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<a name="line-464"></a>                                             <span class='hs-varid'>atomically</span> <span class='hs-layout'>(</span><span class='hs-varid'>writeTVar</span> <span class='hs-varid'>v</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>result</span><span class='hs-layout'>)</span>
<a name="line-465"></a>                  <span class='hs-keyword'>let</span> <span class='hs-varid'>waitAction</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>result</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readTVar</span> <span class='hs-varid'>v</span>
<a name="line-466"></a>                                      <span class='hs-keyword'>case</span> <span class='hs-varid'>result</span> <span class='hs-keyword'>of</span>
<a name="line-467"></a>                                        <span class='hs-conid'>Nothing</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>retry</span>
<a name="line-468"></a>                                        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-469"></a>                                        <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>throwSTM</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IOException</span><span class='hs-layout'>)</span>
<a name="line-470"></a>                  <span class='hs-keyword'>let</span> <span class='hs-varid'>killAction</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-471"></a>                  <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>waitAction</span><span class='hs-layout'>,</span> <span class='hs-varid'>killAction</span><span class='hs-layout'>)</span>
<a name="line-472"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"threadWaitWriteSTM requires -threaded on Windows"</span>
<a name="line-473"></a><span class='hs-cpp'>#else</span>
<a name="line-474"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Conc</span><span class='hs-varop'>.</span><span class='hs-varid'>threadWaitWriteSTM</span> <span class='hs-varid'>fd</span>
<a name="line-475"></a><span class='hs-cpp'>#endif</span>
<a name="line-476"></a>
<a name="line-477"></a><span class='hs-cpp'>#ifdef mingw32_HOST_OS</span>
<a name="line-478"></a><span class='hs-keyword'>foreign</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>ccall</span> <span class='hs-keyword'>unsafe</span> <span class='hs-str'>"rtsSupportsBoundThreads"</span> <span class='hs-varid'>threaded</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-479"></a>
<a name="line-480"></a><a name="withThread"></a><span class='hs-definition'>withThread</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-481"></a><span class='hs-definition'>withThread</span> <span class='hs-varid'>io</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-482"></a>  <span class='hs-varid'>m</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newEmptyMVar</span>
<a name="line-483"></a>  <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mask_</span> <span class='hs-varop'>$</span> <span class='hs-varid'>forkIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>try</span> <span class='hs-varid'>io</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span>
<a name="line-484"></a>  <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>takeMVar</span> <span class='hs-varid'>m</span>
<a name="line-485"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>of</span>
<a name="line-486"></a>    <span class='hs-conid'>Right</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>a</span>
<a name="line-487"></a>    <span class='hs-conid'>Left</span> <span class='hs-varid'>e</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>throwIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IOException</span><span class='hs-layout'>)</span>
<a name="line-488"></a>
<a name="line-489"></a><a name="waitFd"></a><span class='hs-definition'>waitFd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Fd</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CInt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-490"></a><span class='hs-definition'>waitFd</span> <span class='hs-varid'>fd</span> <span class='hs-varid'>write</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-491"></a>   <span class='hs-varid'>throwErrnoIfMinus1_</span> <span class='hs-str'>"fdReady"</span> <span class='hs-varop'>$</span>
<a name="line-492"></a>        <span class='hs-varid'>fdReady</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromIntegral</span> <span class='hs-varid'>fd</span><span class='hs-layout'>)</span> <span class='hs-varid'>write</span> <span class='hs-varid'>iNFINITE</span> <span class='hs-num'>0</span>
<a name="line-493"></a>
<a name="line-494"></a><a name="iNFINITE"></a><span class='hs-definition'>iNFINITE</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CInt</span>
<a name="line-495"></a><span class='hs-definition'>iNFINITE</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0xFFFFFFFF</span> <span class='hs-comment'>-- urgh</span>
<a name="line-496"></a>
<a name="line-497"></a><span class='hs-keyword'>foreign</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>ccall</span> <span class='hs-keyword'>safe</span> <span class='hs-str'>"fdReady"</span>
<a name="line-498"></a>  <span class='hs-varid'>fdReady</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CInt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CInt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CInt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CInt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CInt</span>
<a name="line-499"></a><span class='hs-cpp'>#endif</span>
<a name="line-500"></a>
<a name="line-501"></a><span class='hs-comment'>-- ---------------------------------------------------------------------------</span>
<a name="line-502"></a><span class='hs-comment'>-- More docs</span>
<a name="line-503"></a>
<a name="line-504"></a><span class='hs-comment'>{- $osthreads
<a name="line-505"></a>
<a name="line-506"></a>      #osthreads# In GHC, threads created by 'forkIO' are lightweight threads, and
<a name="line-507"></a>      are managed entirely by the GHC runtime.  Typically Haskell
<a name="line-508"></a>      threads are an order of magnitude or two more efficient (in
<a name="line-509"></a>      terms of both time and space) than operating system threads.
<a name="line-510"></a>
<a name="line-511"></a>      The downside of having lightweight threads is that only one can
<a name="line-512"></a>      run at a time, so if one thread blocks in a foreign call, for
<a name="line-513"></a>      example, the other threads cannot continue.  The GHC runtime
<a name="line-514"></a>      works around this by making use of full OS threads where
<a name="line-515"></a>      necessary.  When the program is built with the @-threaded@
<a name="line-516"></a>      option (to link against the multithreaded version of the
<a name="line-517"></a>      runtime), a thread making a @safe@ foreign call will not block
<a name="line-518"></a>      the other threads in the system; another OS thread will take
<a name="line-519"></a>      over running Haskell threads until the original call returns.
<a name="line-520"></a>      The runtime maintains a pool of these /worker/ threads so that
<a name="line-521"></a>      multiple Haskell threads can be involved in external calls
<a name="line-522"></a>      simultaneously.
<a name="line-523"></a>
<a name="line-524"></a>      The "System.IO" library manages multiplexing in its own way.  On
<a name="line-525"></a>      Windows systems it uses @safe@ foreign calls to ensure that
<a name="line-526"></a>      threads doing I\/O operations don't block the whole runtime,
<a name="line-527"></a>      whereas on Unix systems all the currently blocked I\/O requests
<a name="line-528"></a>      are managed by a single thread (the /IO manager thread/) using
<a name="line-529"></a>      a mechanism such as @epoll@ or @kqueue@, depending on what is
<a name="line-530"></a>      provided by the host operating system.
<a name="line-531"></a>
<a name="line-532"></a>      The runtime will run a Haskell thread using any of the available
<a name="line-533"></a>      worker OS threads.  If you need control over which particular OS
<a name="line-534"></a>      thread is used to run a given Haskell thread, perhaps because
<a name="line-535"></a>      you need to call a foreign library that uses OS-thread-local
<a name="line-536"></a>      state, then you need bound threads (see "Control.Concurrent#boundthreads").
<a name="line-537"></a>
<a name="line-538"></a>      If you don't use the @-threaded@ option, then the runtime does
<a name="line-539"></a>      not make use of multiple OS threads.  Foreign calls will block
<a name="line-540"></a>      all other running Haskell threads until the call returns.  The
<a name="line-541"></a>      "System.IO" library still does multiplexing, so there can be multiple
<a name="line-542"></a>      threads doing I\/O, and this is handled internally by the runtime using
<a name="line-543"></a>      @select@.
<a name="line-544"></a>-}</span>
<a name="line-545"></a>
<a name="line-546"></a><span class='hs-comment'>{- $termination
<a name="line-547"></a>
<a name="line-548"></a>      In a standalone GHC program, only the main thread is
<a name="line-549"></a>      required to terminate in order for the process to terminate.
<a name="line-550"></a>      Thus all other forked threads will simply terminate at the same
<a name="line-551"></a>      time as the main thread (the terminology for this kind of
<a name="line-552"></a>      behaviour is \"daemonic threads\").
<a name="line-553"></a>
<a name="line-554"></a>      If you want the program to wait for child threads to
<a name="line-555"></a>      finish before exiting, you need to program this yourself.  A
<a name="line-556"></a>      simple mechanism is to have each child thread write to an
<a name="line-557"></a>      'MVar' when it completes, and have the main
<a name="line-558"></a>      thread wait on all the 'MVar's before
<a name="line-559"></a>      exiting:
<a name="line-560"></a>
<a name="line-561"></a>&gt;   myForkIO :: IO () -&gt; IO (MVar ())
<a name="line-562"></a>&gt;   myForkIO io = do
<a name="line-563"></a>&gt;     mvar &lt;- newEmptyMVar
<a name="line-564"></a>&gt;     forkFinally io (\_ -&gt; putMVar mvar ())
<a name="line-565"></a>&gt;     return mvar
<a name="line-566"></a>
<a name="line-567"></a>      Note that we use 'forkFinally' to make sure that the
<a name="line-568"></a>      'MVar' is written to even if the thread dies or
<a name="line-569"></a>      is killed for some reason.
<a name="line-570"></a>
<a name="line-571"></a>      A better method is to keep a global list of all child
<a name="line-572"></a>      threads which we should wait for at the end of the program:
<a name="line-573"></a>
<a name="line-574"></a>&gt;    children :: MVar [MVar ()]
<a name="line-575"></a>&gt;    children = unsafePerformIO (newMVar [])
<a name="line-576"></a>&gt;
<a name="line-577"></a>&gt;    waitForChildren :: IO ()
<a name="line-578"></a>&gt;    waitForChildren = do
<a name="line-579"></a>&gt;      cs &lt;- takeMVar children
<a name="line-580"></a>&gt;      case cs of
<a name="line-581"></a>&gt;        []   -&gt; return ()
<a name="line-582"></a>&gt;        m:ms -&gt; do
<a name="line-583"></a>&gt;           putMVar children ms
<a name="line-584"></a>&gt;           takeMVar m
<a name="line-585"></a>&gt;           waitForChildren
<a name="line-586"></a>&gt;
<a name="line-587"></a>&gt;    forkChild :: IO () -&gt; IO ThreadId
<a name="line-588"></a>&gt;    forkChild io = do
<a name="line-589"></a>&gt;        mvar &lt;- newEmptyMVar
<a name="line-590"></a>&gt;        childs &lt;- takeMVar children
<a name="line-591"></a>&gt;        putMVar children (mvar:childs)
<a name="line-592"></a>&gt;        forkFinally io (\_ -&gt; putMVar mvar ())
<a name="line-593"></a>&gt;
<a name="line-594"></a>&gt;     main =
<a name="line-595"></a>&gt;       later waitForChildren $
<a name="line-596"></a>&gt;       ...
<a name="line-597"></a>
<a name="line-598"></a>      The main thread principle also applies to calls to Haskell from
<a name="line-599"></a>      outside, using @foreign export@.  When the @foreign export@ed
<a name="line-600"></a>      function is invoked, it starts a new main thread, and it returns
<a name="line-601"></a>      when this main thread terminates.  If the call causes new
<a name="line-602"></a>      threads to be forked, they may remain in the system after the
<a name="line-603"></a>      @foreign export@ed function has returned.
<a name="line-604"></a>-}</span>
<a name="line-605"></a>
<a name="line-606"></a><span class='hs-comment'>{- $preemption
<a name="line-607"></a>
<a name="line-608"></a>      GHC implements pre-emptive multitasking: the execution of
<a name="line-609"></a>      threads are interleaved in a random fashion.  More specifically,
<a name="line-610"></a>      a thread may be pre-empted whenever it allocates some memory,
<a name="line-611"></a>      which unfortunately means that tight loops which do no
<a name="line-612"></a>      allocation tend to lock out other threads (this only seems to
<a name="line-613"></a>      happen with pathological benchmark-style code, however).
<a name="line-614"></a>
<a name="line-615"></a>      The rescheduling timer runs on a 20ms granularity by
<a name="line-616"></a>      default, but this may be altered using the
<a name="line-617"></a>      @-i\&lt;n\&gt;@ RTS option.  After a rescheduling
<a name="line-618"></a>      \"tick\" the running thread is pre-empted as soon as
<a name="line-619"></a>      possible.
<a name="line-620"></a>
<a name="line-621"></a>      One final note: the
<a name="line-622"></a>      @aaaa@ @bbbb@ example may not
<a name="line-623"></a>      work too well on GHC (see Scheduling, above), due
<a name="line-624"></a>      to the locking on a 'System.IO.Handle'.  Only one thread
<a name="line-625"></a>      may hold the lock on a 'System.IO.Handle' at any one
<a name="line-626"></a>      time, so if a reschedule happens while a thread is holding the
<a name="line-627"></a>      lock, the other thread won't be able to run.  The upshot is that
<a name="line-628"></a>      the switch from @aaaa@ to
<a name="line-629"></a>      @bbbbb@ happens infrequently.  It can be
<a name="line-630"></a>      improved by lowering the reschedule tick period.  We also have a
<a name="line-631"></a>      patch that causes a reschedule whenever a thread waiting on a
<a name="line-632"></a>      lock is woken up, but haven't found it to be useful for anything
<a name="line-633"></a>      other than this example :-)
<a name="line-634"></a>-}</span>
<a name="line-635"></a>
<a name="line-636"></a><span class='hs-comment'>{- $deadlock
<a name="line-637"></a>
<a name="line-638"></a>GHC attempts to detect when threads are deadlocked using the garbage
<a name="line-639"></a>collector.  A thread that is not reachable (cannot be found by
<a name="line-640"></a>following pointers from live objects) must be deadlocked, and in this
<a name="line-641"></a>case the thread is sent an exception.  The exception is either
<a name="line-642"></a>'BlockedIndefinitelyOnMVar', 'BlockedIndefinitelyOnSTM',
<a name="line-643"></a>'NonTermination', or 'Deadlock', depending on the way in which the
<a name="line-644"></a>thread is deadlocked.
<a name="line-645"></a>
<a name="line-646"></a>Note that this feature is intended for debugging, and should not be
<a name="line-647"></a>relied on for the correct operation of your program.  There is no
<a name="line-648"></a>guarantee that the garbage collector will be accurate enough to detect
<a name="line-649"></a>your deadlock, and no guarantee that the garbage collector will run in
<a name="line-650"></a>a timely enough manner.  Basically, the same caveats as for finalizers
<a name="line-651"></a>apply to deadlock detection.
<a name="line-652"></a>
<a name="line-653"></a>There is a subtle interaction between deadlock detection and
<a name="line-654"></a>finalizers (as created by 'Foreign.Concurrent.newForeignPtr' or the
<a name="line-655"></a>functions in "System.Mem.Weak"): if a thread is blocked waiting for a
<a name="line-656"></a>finalizer to run, then the thread will be considered deadlocked and
<a name="line-657"></a>sent an exception.  So preferably don't do this, but if you have no
<a name="line-658"></a>alternative then it is possible to prevent the thread from being
<a name="line-659"></a>considered deadlocked by making a 'StablePtr' pointing to it.  Don't
<a name="line-660"></a>forget to release the 'StablePtr' later with 'freeStablePtr'.
<a name="line-661"></a>-}</span>
</pre></body>
</html>

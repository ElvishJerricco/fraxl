-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Basic libraries
--   
--   This package contains the <a>Prelude</a> and its support libraries,
--   and a large collection of useful libraries ranging from data
--   structures to parsing combinators and debugging utilities.
@package base
@version 4.8.2.0


-- | The highly unsafe primitive <a>unsafeCoerce</a> converts a value from
--   any type to any other type. Needless to say, if you use this function,
--   it is your responsibility to ensure that the old and new types have
--   identical internal representations, in order to prevent runtime
--   corruption.
--   
--   The types for which <a>unsafeCoerce</a> is representation-safe may
--   differ from compiler to compiler (and version to version).
--   
--   <ul>
--   <li>Documentation for correct usage in GHC will be found under
--   <a>unsafeCoerce#</a> in GHC.Base (around which <a>unsafeCoerce</a> is
--   just a trivial wrapper).</li>
--   <li>In nhc98, the only representation-safe coercions are between Enum
--   types with the same range (e.g. Int, Int32, Char, Word32), or between
--   a newtype and the type that it wraps.</li>
--   </ul>
module Unsafe.Coerce
unsafeCoerce :: a -> b


-- | The tuple data types, and associated functions.
module Data.Tuple

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
uncurry :: (a -> b -> c) -> ((a, b) -> c)

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)


-- | The Maybe type, and associated operations.
module Data.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <tt>show</tt> to a <tt>Maybe Int</tt>. If we have <tt>Just
--   n</tt>, we want to show the underlying <a>Int</a> <tt>n</tt>. But if
--   we have <a>Nothing</a>, we return the empty string instead of (for
--   example) "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when not given <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]


-- | Converting values to readable strings: the <a>Show</a> class and
--   associated functions.
module Text.Show

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a where showsPrec _ x s = show x ++ s show x = shows x "" showList ls s = showList__ shows ls s

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: (Show a) => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | Show a list (using square brackets and commas), given a function for
--   showing elements.
showListWith :: (a -> ShowS) -> [a] -> ShowS


-- | Equality
module Data.Eq

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool


-- | Functors: uniform action over a parameterized type, generalizing the
--   <a>map</a> function on lists.
module Data.Functor

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor f where (<$) = fmap . const
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b

-- | An infix synonym for <a>fmap</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()


-- | Simple combinators working solely on and with functions.
module Data.Function

-- | Identity function.
id :: a -> a

-- | Constant function.
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
flip :: (a -> b -> c) -> b -> a -> c

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
($) :: (a -> b) -> a -> b

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
(&) :: a -> (a -> b) -> b

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
fix :: (a -> a) -> a

-- | <tt>(*) `on` f = \x y -&gt; f x * f y</tt>.
--   
--   Typical usage: <tt><a>sortBy</a> (<tt>compare</tt> `on`
--   <tt>fst</tt>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><tt>(*) `on` <a>id</a> = (*)</tt> (if <tt>(*) ∉ {⊥, <a>const</a>
--   ⊥}</tt>)</li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c


-- | The <a>Bool</a> type and related functions.
module Data.Bool
data Bool :: *
False :: Bool
True :: Bool

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a


-- | Basic operations on type-level Booleans.
module Data.Type.Bool

-- | Type-level <a>If</a>. <tt>If True a b</tt> ==&gt; <tt>a</tt>; <tt>If
--   False a b</tt> ==&gt; <tt>b</tt>

-- | Type-level "and"

-- | Type-level "or"

-- | Type-level "not"

module GHC.Char

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char


-- | This module defines bitwise operations for signed and unsigned
--   integers. Instances of the class <a>Bits</a> for the <a>Int</a> and
--   <a>Integer</a> types are available from this module, and instances for
--   explicitly sized integral types are available from the <a>Data.Int</a>
--   and <a>Data.Word</a> modules.
module Data.Bits

-- | The <a>Bits</a> class defines bitwise operations over integral types.
--   
--   <ul>
--   <li>Bits are numbered from 0 with bit 0 being the least significant
--   bit.</li>
--   </ul>
class Eq a => Bits a where x `shift` i | i < 0 = x `shiftR` (- i) | i > 0 = x `shiftL` i | otherwise = x x `rotate` i | i < 0 = x `rotateR` (- i) | i > 0 = x `rotateL` i | otherwise = x zeroBits = clearBit (bit 0) 0 x `setBit` i = x .|. bit i x `clearBit` i = x .&. complement (bit i) x `complementBit` i = x `xor` bit i x `shiftL` i = x `shift` i x `unsafeShiftL` i = x `shiftL` i x `shiftR` i = x `shift` (- i) x `unsafeShiftR` i = x `shiftR` i x `rotateL` i = x `rotate` i x `rotateR` i = x `rotate` (- i)

-- | Bitwise "and"
(.&.) :: Bits a => a -> a -> a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a

-- | Reverse all the bits in the argument
complement :: Bits a => a -> a

-- | <tt><a>shift</a> x i</tt> shifts <tt>x</tt> left by <tt>i</tt> bits if
--   <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise. Right
--   shifts perform sign extension on signed number types; i.e. they fill
--   the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this unified <a>shift</a> or
--   <a>shiftL</a> and <a>shiftR</a>, depending on which is more convenient
--   for the type in question.
shift :: Bits a => a -> Int -> a

-- | <tt><a>rotate</a> x i</tt> rotates <tt>x</tt> left by <tt>i</tt> bits
--   if <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise.
--   
--   For unbounded types like <a>Integer</a>, <a>rotate</a> is equivalent
--   to <a>shift</a>.
--   
--   An instance can define either this unified <a>rotate</a> or
--   <a>rotateL</a> and <a>rotateR</a>, depending on which is more
--   convenient for the type in question.
rotate :: Bits a => a -> Int -> a

-- | <a>zeroBits</a> is the value with all bits unset.
--   
--   The following laws ought to hold (for all valid bit indices
--   <tt><i>n</i></tt>):
--   
--   <ul>
--   <li><pre><a>clearBit</a> <a>zeroBits</a> <i>n</i> ==
--   <a>zeroBits</a></pre></li>
--   <li><pre><a>setBit</a> <a>zeroBits</a> <i>n</i> == <a>bit</a>
--   <i>n</i></pre></li>
--   <li><pre><a>testBit</a> <a>zeroBits</a> <i>n</i> == False</pre></li>
--   <li><pre><a>popCount</a> <a>zeroBits</a> == 0</pre></li>
--   </ul>
--   
--   This method uses <tt><a>clearBit</a> (<a>bit</a> 0) 0</tt> as its
--   default implementation (which ought to be equivalent to
--   <a>zeroBits</a> for types which possess a 0th bit).
zeroBits :: Bits a => a

-- | <tt>bit <i>i</i></tt> is a value with the <tt><i>i</i></tt>th bit set
--   and all other bits clear.
--   
--   Can be implemented using <a>bitDefault</a> if <tt>a</tt> is also an
--   instance of <a>Num</a>.
--   
--   See also <a>zeroBits</a>.
bit :: Bits a => Int -> a

-- | <tt>x `setBit` i</tt> is the same as <tt>x .|. bit i</tt>
setBit :: Bits a => a -> Int -> a

-- | <tt>x `clearBit` i</tt> is the same as <tt>x .&amp;. complement (bit
--   i)</tt>
clearBit :: Bits a => a -> Int -> a

-- | <tt>x `complementBit` i</tt> is the same as <tt>x `xor` bit i</tt>
complementBit :: Bits a => a -> Int -> a

-- | Return <a>True</a> if the <tt>n</tt>th bit of the argument is 1
--   
--   Can be implemented using <a>testBitDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
testBit :: Bits a => a -> Int -> Bool

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Returns Nothing for types that do
--   not have a fixed bitsize, like <a>Integer</a>.
bitSizeMaybe :: Bits a => a -> Maybe Int

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. The function <a>bitSize</a> is
--   undefined for types that do not have a fixed bitsize, like
--   <a>Integer</a>.

-- | <i>Deprecated: Use <a>bitSizeMaybe</a> or <a>finiteBitSize</a>
--   instead</i>
bitSize :: Bits a => a -> Int

-- | Return <a>True</a> if the argument is a signed type. The actual value
--   of the argument is ignored
isSigned :: Bits a => a -> Bool

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
--   
--   An instance can define either this and <a>shiftR</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftL :: Bits a => a -> Int -> a

-- | Shift the argument left by the specified number of bits. The result is
--   undefined for negative shift amounts and shift amounts greater or
--   equal to the <a>bitSize</a>.
--   
--   Defaults to <a>shiftL</a> unless defined explicitly by an instance.
unsafeShiftL :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits. The
--   result is undefined for negative shift amounts and shift amounts
--   greater or equal to the <a>bitSize</a>.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this and <a>shiftL</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftR :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits, which
--   must be non-negative an smaller than the number of bits in the type.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   Defaults to <a>shiftR</a> unless defined explicitly by an instance.
unsafeShiftR :: Bits a => a -> Int -> a

-- | Rotate the argument left by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateR</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateL :: Bits a => a -> Int -> a

-- | Rotate the argument right by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateL</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateR :: Bits a => a -> Int -> a

-- | Return the number of set bits in the argument. This number is known as
--   the population count or the Hamming weight.
--   
--   Can be implemented using <a>popCountDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
popCount :: Bits a => a -> Int

-- | The <a>FiniteBits</a> class denotes types with a finite, fixed number
--   of bits.
class Bits b => FiniteBits b where countLeadingZeros x = (w - 1) - go (w - 1) where go i | i < 0 = i | testBit x i = i | otherwise = go (i - 1) w = finiteBitSize x countTrailingZeros x = go 0 where go i | i >= w = i | testBit x i = i | otherwise = go (i + 1) w = finiteBitSize x

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Moreover, <a>finiteBitSize</a> is
--   total, in contrast to the deprecated <a>bitSize</a> function it
--   replaces.
--   
--   <pre>
--   <a>finiteBitSize</a> = <a>bitSize</a>
--   <a>bitSizeMaybe</a> = <a>Just</a> . <a>finiteBitSize</a>
--   </pre>
finiteBitSize :: FiniteBits b => b -> Int

-- | Count number of zero bits preceding the most significant set bit.
--   
--   <pre>
--   <a>countLeadingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   </pre>
--   
--   <a>countLeadingZeros</a> can be used to compute log base 2 via
--   
--   <pre>
--   logBase2 x = <a>finiteBitSize</a> x - 1 - <a>countLeadingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countLeadingZeros :: FiniteBits b => b -> Int

-- | Count number of zero bits following the least significant set bit.
--   
--   <pre>
--   <a>countTrailingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   <a>countTrailingZeros</a> . <a>negate</a> = <a>countTrailingZeros</a>
--   </pre>
--   
--   The related <a>find-first-set operation</a> can be expressed in terms
--   of <a>countTrailingZeros</a> as follows
--   
--   <pre>
--   findFirstSet x = 1 + <a>countTrailingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countTrailingZeros :: FiniteBits b => b -> Int

-- | Default implementation for <a>bit</a>.
--   
--   Note that: <tt>bitDefault i = 1 <a>shiftL</a> i</tt>
bitDefault :: (Bits a, Num a) => Int -> a

-- | Default implementation for <a>testBit</a>.
--   
--   Note that: <tt>testBitDefault x i = (x .&amp;. bit i) /= 0</tt>
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool

-- | Default implementation for <a>popCount</a>.
--   
--   This implementation is intentionally naive. Instances are expected to
--   provide an optimized implementation for their size.
popCountDefault :: (Bits a, Num a) => a -> Int

-- | Attempt to convert an <a>Integral</a> type <tt>a</tt> to an
--   <a>Integral</a> type <tt>b</tt> using the size of the types as
--   measured by <a>Bits</a> methods.
--   
--   A simpler version of this function is:
--   
--   <pre>
--   toIntegral :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   toIntegral x
--     | toInteger x == y = Just (fromInteger y)
--     | otherwise        = Nothing
--     where
--       y = toInteger x
--   </pre>
--   
--   This version requires going through <a>Integer</a>, which can be
--   inefficient. However, <tt>toIntegralSized</tt> is optimized to allow
--   GHC to statically determine the relative type sizes (as measured by
--   <a>bitSizeMaybe</a> and <a>isSigned</a>) and avoid going through
--   <a>Integer</a> for many types. (The implementation uses
--   <a>fromIntegral</a>, which is itself optimized with rules for
--   <tt>base</tt> types but may go through <a>Integer</a> for some type
--   pairs.)
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b
instance Data.Bits.Bits GHC.Types.Bool
instance Data.Bits.FiniteBits GHC.Types.Bool
instance Data.Bits.Bits GHC.Types.Int
instance Data.Bits.FiniteBits GHC.Types.Int
instance Data.Bits.Bits GHC.Types.Word
instance Data.Bits.FiniteBits GHC.Types.Word
instance Data.Bits.Bits GHC.Integer.Type.Integer


-- | Safe coercions between data types.
--   
--   More in-depth information can be found on the <a>Roles wiki page</a>
module Data.Coerce

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible * a b => a -> b

-- | This two-parameter class has instances for types <tt>a</tt> and
--   <tt>b</tt> if the compiler can infer that they have the same
--   representation. This class does not have regular instances; instead
--   they are created on-the-fly during type-checking. Trying to manually
--   declare an instance of <tt>Coercible</tt> is an error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class Coercible (a :: k) (b :: k)


-- | This is a library of parser combinators, originally written by Koen
--   Claessen. It parses all alternatives in parallel, so it never keeps
--   hold of the beginning of the input string, a common source of space
--   leaks with other parsers. The '(+++)' choice combinator is genuinely
--   commutative; it makes no difference which branch is "shorter".
module Text.ParserCombinators.ReadP
data ReadP a

-- | Consumes and returns the next character. Fails if there is no input
--   left.
get :: ReadP Char

-- | Look-ahead: returns the part of the input that is left, without
--   consuming it.
look :: ReadP String

-- | Symmetric choice.
(+++) :: ReadP a -> ReadP a -> ReadP a

-- | Local, exclusive, left-biased choice: If left parser locally produces
--   any result at all, then right parser is not used.
(<++) :: ReadP a -> ReadP a -> ReadP a

-- | Transforms a parser into one that does the same, but in addition
--   returns the exact characters read. IMPORTANT NOTE: <a>gather</a> gives
--   a runtime error if its first argument is built using any occurrences
--   of readS_to_P.
gather :: ReadP a -> ReadP (String, a)

-- | Always fails.
pfail :: ReadP a

-- | Succeeds iff we are at the end of input
eof :: ReadP ()

-- | Consumes and returns the next character, if it satisfies the specified
--   predicate.
satisfy :: (Char -> Bool) -> ReadP Char

-- | Parses and returns the specified character.
char :: Char -> ReadP Char

-- | Parses and returns the specified string.
string :: String -> ReadP String

-- | Parses the first zero or more characters satisfying the predicate.
--   Always succeds, exactly once having consumed all the characters Hence
--   NOT the same as (many (satisfy p))
munch :: (Char -> Bool) -> ReadP String

-- | Parses the first one or more characters satisfying the predicate.
--   Fails if none, else succeeds exactly once having consumed all the
--   characters Hence NOT the same as (many1 (satisfy p))
munch1 :: (Char -> Bool) -> ReadP String

-- | Skips all whitespace.
skipSpaces :: ReadP ()

-- | Combines all parsers in the specified list.
choice :: [ReadP a] -> ReadP a

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt> in
--   sequence. A list of results is returned.
count :: Int -> ReadP a -> ReadP [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and finally <tt>close</tt>. Only the value of <tt>p</tt> is
--   returned.
between :: ReadP open -> ReadP close -> ReadP a -> ReadP a

-- | <tt>option x p</tt> will either parse <tt>p</tt> or return <tt>x</tt>
--   without consuming any input.
option :: a -> ReadP a -> ReadP a

-- | <tt>optional p</tt> optionally parses <tt>p</tt> and always returns
--   <tt>()</tt>.
optional :: ReadP a -> ReadP ()

-- | Parses zero or more occurrences of the given parser.
many :: ReadP a -> ReadP [a]

-- | Parses one or more occurrences of the given parser.
many1 :: ReadP a -> ReadP [a]

-- | Like <a>many</a>, but discards the result.
skipMany :: ReadP a -> ReadP ()

-- | Like <a>many1</a>, but discards the result.
skipMany1 :: ReadP a -> ReadP ()

-- | <tt>sepBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>sepBy1 p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>endBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>endBy p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy1 :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>chainr p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a

-- | <tt>chainl p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>left</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a

-- | Like <a>chainl</a>, but parses one or more occurrences of <tt>p</tt>.
chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a

-- | Like <a>chainr</a>, but parses one or more occurrences of <tt>p</tt>.
chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a

-- | <tt>manyTill p end</tt> parses zero or more occurrences of <tt>p</tt>,
--   until <tt>end</tt> succeeds. Returns a list of values returned by
--   <tt>p</tt>.
manyTill :: ReadP a -> ReadP end -> ReadP [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | Converts a parser into a Haskell ReadS-style function. This is the
--   main way in which you can "run" a <a>ReadP</a> parser: the expanded
--   type is <tt> readP_to_S :: ReadP a -&gt; String -&gt; [(a,String)]
--   </tt>
readP_to_S :: ReadP a -> ReadS a

-- | Converts a Haskell ReadS-style function into a parser. Warning: This
--   introduces local backtracking in the resulting parser, and therefore a
--   possible inefficiency.
readS_to_P :: ReadS a -> ReadP a
instance GHC.Base.Functor Text.ParserCombinators.ReadP.P
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.P
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.P
instance GHC.Base.Monad Text.ParserCombinators.ReadP.P
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.P
instance GHC.Base.Functor Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Monad Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.ReadP


-- | This library defines parser combinators for precedence parsing.
module Text.ParserCombinators.ReadPrec
data ReadPrec a
type Prec = Int
minPrec :: Prec

-- | Lift a precedence-insensitive <a>ReadP</a> to a <a>ReadPrec</a>.
lift :: ReadP a -> ReadPrec a

-- | <tt>(prec n p)</tt> checks whether the precedence context is less than
--   or equal to <tt>n</tt>, and
--   
--   <ul>
--   <li>if not, fails</li>
--   <li>if so, parses <tt>p</tt> in context <tt>n</tt>.</li>
--   </ul>
prec :: Prec -> ReadPrec a -> ReadPrec a

-- | Increases the precedence context by one.
step :: ReadPrec a -> ReadPrec a

-- | Resets the precedence context to zero.
reset :: ReadPrec a -> ReadPrec a

-- | Consumes and returns the next character. Fails if there is no input
--   left.
get :: ReadPrec Char

-- | Look-ahead: returns the part of the input that is left, without
--   consuming it.
look :: ReadPrec String

-- | Symmetric choice.
(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a

-- | Local, exclusive, left-biased choice: If left parser locally produces
--   any result at all, then right parser is not used.
(<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a

-- | Always fails.
pfail :: ReadPrec a

-- | Combines all parsers in the specified list.
choice :: [ReadPrec a] -> ReadPrec a
readPrec_to_P :: ReadPrec a -> (Int -> ReadP a)
readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a
readPrec_to_S :: ReadPrec a -> (Int -> ReadS a)
readS_to_Prec :: (Int -> ReadS a) -> ReadPrec a
instance GHC.Base.Functor Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Applicative Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Monad Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Alternative Text.ParserCombinators.ReadPrec.ReadPrec


-- | The cut-down Haskell lexer, used by Text.Read
module Text.Read.Lex
data Lexeme

-- | Character literal
Char :: Char -> Lexeme

-- | String literal, with escapes interpreted
String :: String -> Lexeme

-- | Punctuation or reserved symbol, e.g. <tt>(</tt>, <tt>::</tt>
Punc :: String -> Lexeme

-- | Haskell identifier, e.g. <tt>foo</tt>, <tt>Baz</tt>
Ident :: String -> Lexeme

-- | Haskell symbol, e.g. <tt>&gt;&gt;</tt>, <tt>:%</tt>
Symbol :: String -> Lexeme

Number :: Number -> Lexeme
EOF :: Lexeme

data Number

numberToInteger :: Number -> Maybe Integer

numberToFixed :: Integer -> Number -> Maybe (Integer, Integer)

numberToRational :: Number -> Rational

numberToRangedRational :: (Int, Int) -> Number -> Maybe Rational
lex :: ReadP Lexeme

expect :: Lexeme -> ReadP ()

-- | Haskell lexer: returns the lexed string, rather than the lexeme
hsLex :: ReadP String
lexChar :: ReadP Char
readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
readOctP :: (Eq a, Num a) => ReadP a
readDecP :: (Eq a, Num a) => ReadP a
readHexP :: (Eq a, Num a) => ReadP a
instance GHC.Show.Show Text.Read.Lex.Lexeme
instance GHC.Classes.Eq Text.Read.Lex.Lexeme
instance GHC.Show.Show Text.Read.Lex.Number
instance GHC.Classes.Eq Text.Read.Lex.Number


-- | NB. the contents of this module are only available on Windows.
--   
--   Installing Win32 console handlers.
module GHC.ConsoleHandler

module GHC.Constants


-- | Unsigned integer types.
module Data.Word

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word :: *

-- | 8-bit unsigned integer type
data Word8

-- | 16-bit unsigned integer type
data Word16

-- | 32-bit unsigned integer type
data Word32

-- | 64-bit unsigned integer type
data Word64

-- | Swap bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64


-- | Orderings
module Data.Ord

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
data Ordering :: *
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
--   
--   Provides <a>Show</a> and <a>Read</a> instances (<i>since:
--   4.7.0.0</i>).
newtype Down a
Down :: a -> Down a

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
instance GHC.Read.Read a => GHC.Read.Read (Data.Ord.Down a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Ord.Down a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Ord.Down a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Ord.Down a)


-- | Definition of propositional equality <tt>(:~:)</tt>. Pattern-matching
--   on a variable of type <tt>(a :~: b)</tt> produces a proof that <tt>a ~
--   b</tt>.
module Data.Type.Equality

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data (:~:) a b
Refl :: a :~: a

-- | Symmetry of equality
sym :: (a :~: b) -> (b :~: a)

-- | Transitivity of equality
trans :: (a :~: b) -> (b :~: c) -> (a :~: c)

-- | Type-safe cast, using propositional equality
castWith :: (a :~: b) -> a -> b

-- | Generalized form of type-safe cast using propositional equality
gcastWith :: (a :~: b) -> ((a ~ b) => r) -> r

-- | Apply one equality to another, respectively
apply :: (f :~: g) -> (a :~: b) -> (f a :~: g b)

-- | Extract equality of the arguments from an equality of a applied types
inner :: (f a :~: g b) -> (a :~: b)

-- | Extract equality of type constructors from an equality of applied
--   types
outer :: (f a :~: g b) -> (f :~: g)

-- | This class contains types where you can learn the equality of two
--   types from information contained in <i>terms</i>. Typically, only
--   singleton types should inhabit this class.
class TestEquality f

-- | Conditionally prove the equality of <tt>a</tt> and <tt>b</tt>.
testEquality :: TestEquality f => f a -> f b -> Maybe (a :~: b)

-- | A type family to compute Boolean equality. Instances are provided only
--   for <i>open</i> kinds, such as <tt>*</tt> and function kinds.
--   Instances are also provided for datatypes exported from base. A
--   poly-kinded instance is <i>not</i> provided, as a recursive definition
--   for algebraic kinds is generally more useful.
instance forall (k :: BOX) (a :: k) (b :: k). GHC.Classes.Eq (a Data.Type.Equality.:~: b)
instance forall (k :: BOX) (a :: k) (b :: k). GHC.Show.Show (a Data.Type.Equality.:~: b)
instance forall (k :: BOX) (a :: k) (b :: k). GHC.Classes.Ord (a Data.Type.Equality.:~: b)
instance forall (k :: BOX) (a :: k) (b :: k). (a ~ b) => GHC.Read.Read (a Data.Type.Equality.:~: b)
instance forall (k :: BOX) (a :: k) (b :: k). (a ~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~: b)
instance forall (k :: BOX) (a :: k) (b :: k). (a ~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~: b)
instance forall (k :: BOX) (a :: k). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~:) a)


-- | Definition of representational equality (<a>Coercion</a>).
module Data.Type.Coercion

-- | Representational equality. If <tt>Coercion a b</tt> is inhabited by
--   some terminating value, then the type <tt>a</tt> has the same
--   underlying representation as the type <tt>b</tt>.
--   
--   To use this equality in practice, pattern-match on the <tt>Coercion a
--   b</tt> to get out the <tt>Coercible a b</tt> instance, and then use
--   <a>coerce</a> to apply it.
data Coercion a b
Coercion :: Coercion a b

-- | Type-safe cast, using representational equality
coerceWith :: Coercion a b -> a -> b

-- | Symmetry of representational equality
sym :: Coercion a b -> Coercion b a

-- | Transitivity of representational equality
trans :: Coercion a b -> Coercion b c -> Coercion a c

-- | Convert propositional (nominal) equality to representational equality
repr :: (a :~: b) -> Coercion a b

-- | This class contains types where you can learn the equality of two
--   types from information contained in <i>terms</i>. Typically, only
--   singleton types should inhabit this class.
class TestCoercion f

-- | Conditionally prove the representational equality of <tt>a</tt> and
--   <tt>b</tt>.
testCoercion :: TestCoercion f => f a -> f b -> Maybe (Coercion a b)
instance forall (k :: BOX) (a :: k) (b :: k). GHC.Classes.Eq (Data.Type.Coercion.Coercion a b)
instance forall (k :: BOX) (a :: k) (b :: k). GHC.Show.Show (Data.Type.Coercion.Coercion a b)
instance forall (k :: BOX) (a :: k) (b :: k). GHC.Classes.Ord (Data.Type.Coercion.Coercion a b)
instance forall (k :: BOX) (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Read.Read (Data.Type.Coercion.Coercion a b)
instance forall (k :: BOX) (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Enum.Enum (Data.Type.Coercion.Coercion a b)
instance forall (k :: BOX) (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Enum.Bounded (Data.Type.Coercion.Coercion a b)
instance forall (k :: BOX) (a :: k). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~:) a)
instance forall (k :: BOX) (a :: k). Data.Type.Coercion.TestCoercion (Data.Type.Coercion.Coercion a)


module Control.Category

-- | A class for categories. id and (.) must form a monoid.
class Category cat

-- | the identity morphism
id :: Category cat => cat a a

-- | morphism composition
(.) :: Category cat => cat b c -> cat a b -> cat a c

-- | Right-to-left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c

-- | Left-to-right composition
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
instance Control.Category.Category (->)
instance Control.Category.Category (Data.Type.Equality.:~:)
instance Control.Category.Category Data.Type.Coercion.Coercion


-- | The Char type and associated operations.
module Data.Char

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects lower-case alphabetic Unicode characters (letters).
isLower :: Char -> Bool

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
isUpper :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
isAlpha :: Char -> Bool

-- | Selects alphabetic or numeric digit Unicode characters.
--   
--   Note that numeric digits outside the ASCII range are selected by this
--   function but not by <a>isDigit</a>. Such digits may be part of
--   identifiers but are not used by the printer and reader to represent
--   numbers.
isAlphaNum :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
isPrint :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isAlpha</a>.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Letter".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLetter 'a'
--   True
--   
--   &gt;&gt;&gt; isLetter 'A'
--   True
--   
--   &gt;&gt;&gt; isLetter '0'
--   False
--   
--   &gt;&gt;&gt; isLetter '%'
--   False
--   
--   &gt;&gt;&gt; isLetter '♥'
--   False
--   
--   &gt;&gt;&gt; isLetter '\31'
--   False
--   </pre>
--   
--   Ensure that <a>isLetter</a> and <a>isAlpha</a> are equivalent.
--   
--   <pre>
--   &gt;&gt;&gt; let chars = [(chr 0)..]
--   
--   &gt;&gt;&gt; let letters = map isLetter chars
--   
--   &gt;&gt;&gt; let alphas = map isAlpha chars
--   
--   &gt;&gt;&gt; letters == alphas
--   True
--   </pre>
isLetter :: Char -> Bool

-- | Selects Unicode mark characters, for example accents and the like,
--   which combine with preceding characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>NonSpacingMark</a></li>
--   <li><a>SpacingCombiningMark</a></li>
--   <li><a>EnclosingMark</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Mark".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isMark 'a'
--   False
--   
--   &gt;&gt;&gt; isMark '0'
--   False
--   </pre>
--   
--   Combining marks such as accent characters usually need to follow
--   another character before they become printable:
--   
--   <pre>
--   &gt;&gt;&gt; map isMark "ò"
--   [False,True]
--   </pre>
--   
--   Puns are not necessarily supported:
--   
--   <pre>
--   &gt;&gt;&gt; isMark '✓'
--   False
--   </pre>
isMark :: Char -> Bool

-- | Selects Unicode numeric characters, including digits from various
--   scripts, Roman numerals, et cetera.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>DecimalNumber</a></li>
--   <li><a>LetterNumber</a></li>
--   <li><a>OtherNumber</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Number".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'a'
--   False
--   
--   &gt;&gt;&gt; isNumber '%'
--   False
--   
--   &gt;&gt;&gt; isNumber '3'
--   True
--   </pre>
--   
--   ASCII <tt>'0'</tt> through <tt>'9'</tt> are all numbers:
--   
--   <pre>
--   &gt;&gt;&gt; and $ map isNumber ['0'..'9']
--   True
--   </pre>
--   
--   Unicode Roman numerals are "numbers" as well:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'Ⅸ'
--   True
--   </pre>
isNumber :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Selects Unicode space and separator characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>Space</a></li>
--   <li><a>LineSeparator</a></li>
--   <li><a>ParagraphSeparator</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Separator".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator 'a'
--   False
--   
--   &gt;&gt;&gt; isSeparator '6'
--   False
--   
--   &gt;&gt;&gt; isSeparator ' '
--   True
--   </pre>
--   
--   Warning: newlines and tab characters are not considered separators.
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\n'
--   False
--   
--   &gt;&gt;&gt; isSeparator '\t'
--   False
--   </pre>
--   
--   But some more exotic characters are (like HTML's <tt>&amp;nbsp;</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\160'
--   True
--   </pre>
isSeparator :: Char -> Bool

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <a>Read</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char

-- | Convert a single digit <a>Char</a> to the corresponding <a>Int</a>.
--   This function fails unless its argument satisfies <a>isHexDigit</a>,
--   but recognises both upper- and lower-case hexadecimal digits (that is,
--   <tt>'0'</tt>..<tt>'9'</tt>, <tt>'a'</tt>..<tt>'f'</tt>,
--   <tt>'A'</tt>..<tt>'F'</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   Characters <tt>'0'</tt> through <tt>'9'</tt> are converted properly to
--   <tt>0..9</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['0'..'9']
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   Both upper- and lower-case <tt>'A'</tt> through <tt>'F'</tt> are
--   converted as well, to <tt>10..15</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['a'..'f']
--   [10,11,12,13,14,15]
--   
--   &gt;&gt;&gt; map digitToInt ['A'..'F']
--   [10,11,12,13,14,15]
--   </pre>
--   
--   Anything else throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; digitToInt 'G'
--   *** Exception: Char.digitToInt: not a digit 'G'
--   
--   &gt;&gt;&gt; digitToInt '♥'
--   *** Exception: Char.digitToInt: not a digit '\9829'
--   </pre>
digitToInt :: Char -> Int

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char
instance GHC.Arr.Ix Data.Char.GeneralCategory
instance GHC.Enum.Bounded Data.Char.GeneralCategory
instance GHC.Show.Show Data.Char.GeneralCategory
instance GHC.Read.Read Data.Char.GeneralCategory
instance GHC.Enum.Enum Data.Char.GeneralCategory
instance GHC.Classes.Ord Data.Char.GeneralCategory
instance GHC.Classes.Eq Data.Char.GeneralCategory


-- | This legacy module provides access to the list-specialised operations
--   of <a>Data.List</a>. This module may go away again in future GHC
--   versions and is provided as transitional tool to access some of the
--   list-specialised operations that had to be generalised due to the
--   implementation of the <a>Foldable/Traversable-in-Prelude Proposal
--   (FTP)</a>.
--   
--   If the operations needed are available in <a>GHC.List</a>, it's
--   recommended to avoid importing this module and use <a>GHC.List</a>
--   instead for now.
module GHC.OldList

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]

-- | Extract the first element of a list, which must be non-empty.
head :: [a] -> a

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: [a] -> [a]

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: [a] -> [a]

-- | Decompose a list into its head and tail. If the list is empty, returns
--   <a>Nothing</a>. If the list is non-empty, returns <tt><a>Just</a> (x,
--   xs)</tt>, where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.
uncons :: [a] -> Maybe (a, [a])

-- | Test whether a list is empty.
null :: [a] -> Bool

-- | <i>O(n)</i>. <a>length</a> returns the length of a finite list as an
--   <a>Int</a>. It is an instance of the more general
--   <a>genericLength</a>, the result type of which may be any kind of
--   number.
length :: [a] -> Int

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | The <a>intersperse</a> function takes an element and a list and
--   `intersperses' that element between the elements of the list. For
--   example,
--   
--   <pre>
--   intersperse ',' "abcde" == "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   subsequences "abc" == ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   permutations "abc" == ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a list, reduces the
--   list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   The list must be finite.
foldl :: (b -> a -> b) -> b -> [a] -> b

-- | A strict version of <a>foldl</a>.
foldl' :: (b -> a -> b) -> b -> [a] -> b

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty lists.
foldl1 :: (a -> a -> a) -> [a] -> a

-- | A strict version of <a>foldl1</a>
foldl1' :: (a -> a -> a) -> [a] -> a

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a list, reduces
--   the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty lists.
foldr1 :: (a -> a -> a) -> [a] -> a

-- | Concatenate a list of lists.
concat :: [[a]] -> [a]

-- | Map a function over a list and concatenate the results.
concatMap :: (a -> [b]) -> [a] -> [b]

-- | <a>and</a> returns the conjunction of a Boolean list. For the result
--   to be <a>True</a>, the list must be finite; <a>False</a>, however,
--   results from a <a>False</a> value at a finite index of a finite or
--   infinite list.
and :: [Bool] -> Bool

-- | <a>or</a> returns the disjunction of a Boolean list. For the result to
--   be <a>False</a>, the list must be finite; <a>True</a>, however,
--   results from a <a>True</a> value at a finite index of a finite or
--   infinite list.
or :: [Bool] -> Bool

-- | Applied to a predicate and a list, <a>any</a> determines if any
--   element of the list satisfies the predicate. For the result to be
--   <a>False</a>, the list must be finite; <a>True</a>, however, results
--   from a <a>True</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
any :: (a -> Bool) -> [a] -> Bool

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   elements of the list satisfy the predicate. For the result to be
--   <a>True</a>, the list must be finite; <a>False</a>, however, results
--   from a <a>False</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
all :: (a -> Bool) -> [a] -> Bool

-- | The <a>sum</a> function computes the sum of a finite list of numbers.
sum :: (Num a) => [a] -> a

-- | The <a>product</a> function computes the product of a finite list of
--   numbers.
product :: (Num a) => [a] -> a

-- | <a>maximum</a> returns the maximum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>maximumBy</a>, which allows the programmer to supply their own
--   comparison function.
maximum :: (Ord a) => [a] -> a

-- | <a>minimum</a> returns the minimum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>minimumBy</a>, which allows the programmer to supply their own
--   comparison function.
minimum :: (Ord a) => [a] -> a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | A strictly accumulating version of <a>scanl</a>
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a list,
--   passing an accumulating parameter from left to right, and returning a
--   final value of this accumulator together with the new list.
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a list,
--   passing an accumulating parameter from right to left, and returning a
--   final value of this accumulator together with the new list.
mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--    [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   dropWhileEnd isSpace "foo\n" == "foo"
--   dropWhileEnd isSpace "foo bar" == "foo bar"
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>stripPrefix</a> function drops the given prefix from a list. It
--   returns <a>Nothing</a> if the list did not start with the prefix
--   given, or <a>Just</a> the list after the prefix, if it does.
--   
--   <pre>
--   stripPrefix "foo" "foobar" == Just "bar"
--   stripPrefix "foo" "foo" == Just ""
--   stripPrefix "foo" "barfoo" == Nothing
--   stripPrefix "foo" "barfoobaz" == Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   inits "abc" == ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: [a] -> [[a]]

-- | The <a>tails</a> function returns all final segments of the argument,
--   longest first. For example,
--   
--   <pre>
--   tails "abc" == ["abc", "bc", "c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
isPrefixOf :: (Eq a) => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
isSuffixOf :: (Eq a) => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   Example:
--   
--   <pre>
--   isInfixOf "Haskell" "I really like Haskell." == True
--   isInfixOf "Ial" "I really like Haskell." == False
--   </pre>
isInfixOf :: (Eq a) => [a] -> [a] -> Bool

-- | <a>elem</a> is the list membership predicate, usually written in infix
--   form, e.g., <tt>x `elem` xs</tt>. For the result to be <a>False</a>,
--   the list must be finite; <a>True</a>, however, results from an element
--   equal to <tt>x</tt> found at a finite index of a finite or infinite
--   list.
elem :: (Eq a) => a -> [a] -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Eq a) => a -> [a] -> Bool

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: (Eq a) => a -> [(a, b)] -> Maybe b

-- | The <a>find</a> function takes a predicate and a list and returns the
--   first element in the list matching the predicate, or <a>Nothing</a> if
--   there is no such element.
find :: (a -> Bool) -> [a] -> Maybe a

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element.
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   If one input list is short, excess elements of the longer list are
--   discarded.
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
unwords :: [String] -> String

-- | <i>O(n^2)</i>. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
nub :: (Eq a) => [a] -> [a]

-- | <a>delete</a> <tt>x</tt> removes the first occurrence of <tt>x</tt>
--   from its list argument. For example,
--   
--   <pre>
--   delete 'a' "banana" == "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: (Eq a) => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: (Eq a) => [a] -> [a] -> [a]

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   "dog" `union` "cow" == "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: (Eq a) => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: (Eq a) => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
sort :: (Ord a) => [a] -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy . comparing
--   f</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | The <a>insert</a> function takes an element and a list and inserts the
--   element into the list at the first position where it is less than or
--   equal to the next element. In particular, if the list is sorted before
--   the call, the result will also be sorted. It is a special case of
--   <a>insertBy</a>, which allows the programmer to supply their own
--   comparison function.
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | The <a>deleteBy</a> function behaves like <a>delete</a>, but takes a
--   user-supplied equality predicate.
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The <a>maximumBy</a> function takes a comparison function and a list
--   and returns the greatest element of the list by the comparison
--   function. The list must be finite and non-empty.
maximumBy :: (a -> a -> Ordering) -> [a] -> a

-- | The <a>minimumBy</a> function takes a comparison function and a list
--   and returns the least element of the list by the comparison function.
--   The list must be finite and non-empty.
minimumBy :: (a -> a -> Ordering) -> [a] -> a

-- | The <a>genericLength</a> function is an overloaded version of
--   <a>length</a>. In particular, instead of returning an <a>Int</a>, it
--   returns any type which is an instance of <a>Num</a>. It is, however,
--   less efficient than <a>length</a>.
genericLength :: (Num i) => [a] -> i

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: (Integral i) => i -> [a] -> [a]

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: (Integral i) => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: (Integral i) => i -> [a] -> ([a], [a])

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: (Integral i) => [a] -> i -> a

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: (Integral i) => i -> a -> [a]


-- | Definition of a Proxy type (poly-kinded in GHC)
module Data.Proxy

-- | A concrete, poly-kinded proxy type
data Proxy t
Proxy :: Proxy t

-- | <a>asProxyTypeOf</a> is a type-restricted version of <a>const</a>. It
--   is usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   tag of the second.
asProxyTypeOf :: a -> Proxy a -> a

-- | A concrete, promotable proxy type, for use at the kind level There are
--   no instances for this because it is intended at the kind level only
data KProxy (t :: *)
KProxy :: KProxy
instance forall (k :: BOX) (s :: k). GHC.Classes.Eq (Data.Proxy.Proxy s)
instance forall (k :: BOX) (s :: k). GHC.Classes.Ord (Data.Proxy.Proxy s)
instance forall (k :: BOX) (s :: k). GHC.Show.Show (Data.Proxy.Proxy s)
instance forall (k :: BOX) (s :: k). GHC.Read.Read (Data.Proxy.Proxy s)
instance forall (k :: BOX) (s :: k). GHC.Enum.Enum (Data.Proxy.Proxy s)
instance forall (k :: BOX) (s :: k). GHC.Arr.Ix (Data.Proxy.Proxy s)
instance forall (k :: BOX) (s :: k). GHC.Enum.Bounded (Data.Proxy.Proxy s)
instance forall (k :: BOX) (s :: k). GHC.Base.Monoid (Data.Proxy.Proxy s)
instance GHC.Base.Functor Data.Proxy.Proxy
instance GHC.Base.Applicative Data.Proxy.Proxy
instance GHC.Base.Monad Data.Proxy.Proxy


-- | Odds and ends, mostly functions for reading and showing
--   <a>RealFloat</a>-like kind of values.
module Numeric

-- | Converts a possibly-negative <a>Real</a> value to a string.
showSigned :: (Real a) => (a -> ShowS) -> Int -> a -> ShowS

-- | Shows a <i>non-negative</i> <a>Integral</a> number using the base
--   specified by the first argument, and the character representation
--   specified by the second.
showIntAtBase :: (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 10.
showInt :: Integral a => a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 16.
showHex :: (Integral a, Show a) => a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 8.
showOct :: (Integral a, Show a) => a -> ShowS

-- | Show a signed <a>RealFloat</a> value using scientific (exponential)
--   notation (e.g. <tt>2.45e2</tt>, <tt>1.5e-3</tt>).
--   
--   In the call <tt><a>showEFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showEFloat :: (RealFloat a) => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   (e.g. <tt>245000</tt>, <tt>0.0015</tt>).
--   
--   In the call <tt><a>showFFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showFFloat :: (RealFloat a) => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   for arguments whose absolute value lies between <tt>0.1</tt> and
--   <tt>9,999,999</tt>, and scientific notation otherwise.
--   
--   In the call <tt><a>showGFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showGFloat :: (RealFloat a) => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   (e.g. <tt>245000</tt>, <tt>0.0015</tt>).
--   
--   This behaves as <a>showFFloat</a>, except that a decimal point is
--   always guaranteed, even if not needed.
showFFloatAlt :: (RealFloat a) => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   for arguments whose absolute value lies between <tt>0.1</tt> and
--   <tt>9,999,999</tt>, and scientific notation otherwise.
--   
--   This behaves as <a>showFFloat</a>, except that a decimal point is
--   always guaranteed, even if not needed.
showGFloatAlt :: (RealFloat a) => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value to full precision using standard
--   decimal notation for arguments whose absolute value lies between
--   <tt>0.1</tt> and <tt>9,999,999</tt>, and scientific notation
--   otherwise.
showFloat :: (RealFloat a) => a -> ShowS

-- | <a>floatToDigits</a> takes a base and a non-negative <a>RealFloat</a>
--   number, and returns a list of digits and an exponent. In particular,
--   if <tt>x&gt;=0</tt>, and
--   
--   <pre>
--   floatToDigits base x = ([d1,d2,...,dn], e)
--   </pre>
--   
--   then
--   
--   <ol>
--   <li><pre>n &gt;= 1</pre></li>
--   <li><pre>x = 0.d1d2...dn * (base**e)</pre></li>
--   <li><pre>0 &lt;= di &lt;= base-1</pre></li>
--   </ol>
floatToDigits :: (RealFloat a) => Integer -> a -> ([Int], Int)

-- | Reads a <i>signed</i> <a>Real</a> value, given a reader for an
--   unsigned value.
readSigned :: (Real a) => ReadS a -> ReadS a

-- | Reads an <i>unsigned</i> <a>Integral</a> value in an arbitrary base.
readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a

-- | Read an unsigned number in decimal notation.
readDec :: (Eq a, Num a) => ReadS a

-- | Read an unsigned number in octal notation.
readOct :: (Eq a, Num a) => ReadS a

-- | Read an unsigned number in hexadecimal notation. Both upper or lower
--   case letters are allowed.
readHex :: (Eq a, Num a) => ReadS a

-- | Reads an <i>unsigned</i> <a>RealFrac</a> value, expressed in decimal
--   scientific notation.
readFloat :: RealFrac a => ReadS a

-- | Reads a non-empty string of decimal digits.
lexDigits :: ReadS String

-- | Converts a <a>Rational</a> value into any type in class
--   <a>RealFloat</a>.
fromRat :: (RealFloat a) => Rational -> a

module GHC.Fingerprint.Type
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
instance GHC.Classes.Ord GHC.Fingerprint.Type.Fingerprint
instance GHC.Classes.Eq GHC.Fingerprint.Type.Fingerprint
instance GHC.Show.Show GHC.Fingerprint.Type.Fingerprint


-- | The representations of the types TyCon and TypeRep, and the function
--   mkTyCon which is used by derived instances of Typeable to construct a
--   TyCon.
module Data.Typeable.Internal

-- | A concrete, poly-kinded proxy type
data Proxy t
Proxy :: Proxy t

-- | A concrete representation of a (monomorphic) type. <a>TypeRep</a>
--   supports reasonably efficient equality.
data TypeRep
TypeRep :: {-# UNPACK #-} !Fingerprint -> TyCon -> [KindRep] -> [TypeRep] -> TypeRep
type KindRep = TypeRep
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
typeOf :: Typeable a => a -> TypeRep
typeOf1 :: Typeable t => t a -> TypeRep
typeOf2 :: Typeable t => t a b -> TypeRep
typeOf3 :: Typeable t => t a b c -> TypeRep
typeOf4 :: Typeable t => t a b c d -> TypeRep
typeOf5 :: Typeable t => t a b c d e -> TypeRep
typeOf6 :: Typeable t => t a b c d e f -> TypeRep
typeOf7 :: Typeable t => t a b c d e f g -> TypeRep

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable1 (a :: * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable2 (a :: * -> * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable3 (a :: * -> * -> * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable4 (a :: * -> * -> * -> * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable5 (a :: * -> * -> * -> * -> * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable6 (a :: * -> * -> * -> * -> * -> * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable7 (a :: * -> * -> * -> * -> * -> * -> * -> *) = Typeable a

-- | An abstract representation of a type constructor. <a>TyCon</a> objects
--   can be built using <a>mkTyCon</a>.
data TyCon
TyCon :: {-# UNPACK #-} !Fingerprint -> String -> String -> String -> TyCon

[tyConFingerprint] :: TyCon -> {-# UNPACK #-} !Fingerprint

[tyConPackage] :: TyCon -> String

[tyConModule] :: TyCon -> String

[tyConName] :: TyCon -> String

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
typeRep :: Typeable a => proxy a -> TypeRep
mkTyCon :: Word# -> Word# -> String -> String -> String -> TyCon

-- | Builds a <a>TyCon</a> object representing a type constructor. An
--   implementation of <a>Data.Typeable</a> should ensure that the
--   following holds:
--   
--   <pre>
--   A==A' ^ B==B' ^ C==C' ==&gt; mkTyCon A B C == mkTyCon A' B' C'
--   </pre>
mkTyCon3 :: String -> String -> String -> TyCon

-- | Applies a monomorphic type constructor to a sequence of types
mkTyConApp :: TyCon -> [TypeRep] -> TypeRep

-- | Applies a polymorhic type constructor to a sequence of kinds and types
mkPolyTyConApp :: TyCon -> [KindRep] -> [TypeRep] -> TypeRep

-- | Adds a TypeRep argument to a TypeRep.
mkAppTy :: TypeRep -> TypeRep -> TypeRep

-- | Observe the type constructor of a type representation
typeRepTyCon :: TypeRep -> TyCon

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable a
typeRep# :: Typeable a => Proxy# a -> TypeRep

-- | A special case of <a>mkTyConApp</a>, which applies the function type
--   constructor to a pair of types.
mkFunTy :: TypeRep -> TypeRep -> TypeRep

-- | Splits a type constructor application. Note that if the type
--   construcotr is polymorphic, this will not return the kinds that were
--   used. See <a>splitPolyTyConApp</a> if you need all parts.
splitTyConApp :: TypeRep -> (TyCon, [TypeRep])

-- | Split a type constructor application
splitPolyTyConApp :: TypeRep -> (TyCon, [KindRep], [TypeRep])

-- | Applies a type to a function type. Returns: <tt><a>Just</a> u</tt> if
--   the first argument represents a function of type <tt>t -&gt; u</tt>
--   and the second argument represents a function of type <tt>t</tt>.
--   Otherwise, returns <a>Nothing</a>.
funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep

-- | Observe the argument types of a type representation
typeRepArgs :: TypeRep -> [TypeRep]

-- | Observe the <a>Fingerprint</a> of a type representation
typeRepFingerprint :: TypeRep -> Fingerprint

-- | Helper to fully evaluate <a>TypeRep</a> for use as
--   <tt>NFData(rnf)</tt> implementation
rnfTypeRep :: TypeRep -> ()
showsTypeRep :: TypeRep -> ShowS

-- | Observe string encoding of a type representation

-- | <i>Deprecated: renamed to <a>tyConName</a>; <a>tyConModule</a> and
--   <a>tyConPackage</a> are also available.</i>
tyConString :: TyCon -> String

-- | Helper to fully evaluate <a>TyCon</a> for use as <tt>NFData(rnf)</tt>
--   implementation
rnfTyCon :: TyCon -> ()
listTc :: TyCon
funTc :: TyCon

-- | Observe the argument kinds of a type representation
typeRepKinds :: TypeRep -> [KindRep]

-- | An internal function, to make representations for type literals.
typeLitTypeRep :: String -> TypeRep
instance GHC.Classes.Eq Data.Typeable.Internal.TypeRep
instance GHC.Classes.Ord Data.Typeable.Internal.TypeRep
instance GHC.Classes.Eq Data.Typeable.Internal.TyCon
instance GHC.Classes.Ord Data.Typeable.Internal.TyCon
instance GHC.Show.Show Data.Typeable.Internal.TypeRep
instance GHC.Show.Show Data.Typeable.Internal.TyCon


-- | This module is part of the Foreign Function Interface (FFI) and will
--   usually be imported via the module <a>Foreign</a>.
module Foreign.StablePtr

-- | A <i>stable pointer</i> is a reference to a Haskell expression that is
--   guaranteed not to be affected by garbage collection, i.e., it will
--   neither be deallocated nor will the value of the stable pointer itself
--   change during garbage collection (ordinary references may be relocated
--   during garbage collection). Consequently, stable pointers can be
--   passed to foreign code, which can treat it as an opaque reference to a
--   Haskell value.
--   
--   A value of type <tt>StablePtr a</tt> is a stable pointer to a Haskell
--   expression of type <tt>a</tt>.
data StablePtr a

-- | Create a stable pointer referring to the given Haskell value.
newStablePtr :: a -> IO (StablePtr a)

-- | Obtain the Haskell value referenced by a stable pointer, i.e., the
--   same value that was passed to the corresponding call to
--   <tt>makeStablePtr</tt>. If the argument to <a>deRefStablePtr</a> has
--   already been freed using <a>freeStablePtr</a>, the behaviour of
--   <a>deRefStablePtr</a> is undefined.
deRefStablePtr :: StablePtr a -> IO a

-- | Dissolve the association between the stable pointer and the Haskell
--   value. Afterwards, if the stable pointer is passed to
--   <a>deRefStablePtr</a> or <a>freeStablePtr</a>, the behaviour is
--   undefined. However, the stable pointer may still be passed to
--   <a>castStablePtrToPtr</a>, but the <tt><a>Ptr</a> ()</tt> value
--   returned by <a>castStablePtrToPtr</a>, in this case, is undefined (in
--   particular, it may be <a>nullPtr</a>). Nevertheless, the call to
--   <a>castStablePtrToPtr</a> is guaranteed not to diverge.
freeStablePtr :: StablePtr a -> IO ()

-- | Coerce a stable pointer to an address. No guarantees are made about
--   the resulting value, except that the original stable pointer can be
--   recovered by <a>castPtrToStablePtr</a>. In particular, the address may
--   not refer to an accessible memory location and any attempt to pass it
--   to the member functions of the class <a>Storable</a> leads to
--   undefined behaviour.
castStablePtrToPtr :: StablePtr a -> Ptr ()

-- | The inverse of <a>castStablePtrToPtr</a>, i.e., we have the identity
--   
--   <pre>
--   sp == castPtrToStablePtr (castStablePtrToPtr sp)
--   </pre>
--   
--   for any stable pointer <tt>sp</tt> on which <a>freeStablePtr</a> has
--   not been executed yet. Moreover, <a>castPtrToStablePtr</a> may only be
--   applied to pointers that have been produced by
--   <a>castStablePtrToPtr</a>.
castPtrToStablePtr :: Ptr () -> StablePtr a


-- | The <a>Typeable</a> class reifies types to some extent by associating
--   type representations to types. These type representations can be
--   compared, and one can in turn define a type-safe cast operation. To
--   this end, an unsafe cast is guarded by a test for type
--   (representation) equivalence. The module <a>Data.Dynamic</a> uses
--   Typeable for an implementation of dynamics. The module
--   <a>Data.Data</a> uses Typeable and type-safe cast (but not dynamics)
--   to support the "Scrap your boilerplate" style of generic programming.
--   
--   <h2>Compatibility Notes</h2>
--   
--   Since GHC 7.8, <a>Typeable</a> is poly-kinded. The changes required
--   for this might break some old programs involving <a>Typeable</a>. More
--   details on this, including how to fix your code, can be found on the
--   <a>PolyTypeable wiki page</a>
module Data.Typeable

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable a

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
typeRep :: Typeable a => proxy a -> TypeRep

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data (:~:) a b
Refl :: a :~: a
typeOf :: Typeable a => a -> TypeRep
typeOf1 :: Typeable t => t a -> TypeRep
typeOf2 :: Typeable t => t a b -> TypeRep
typeOf3 :: Typeable t => t a b c -> TypeRep
typeOf4 :: Typeable t => t a b c d -> TypeRep
typeOf5 :: Typeable t => t a b c d e -> TypeRep
typeOf6 :: Typeable t => t a b c d e f -> TypeRep
typeOf7 :: Typeable t => t a b c d e f g -> TypeRep

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable1 (a :: * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable2 (a :: * -> * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable3 (a :: * -> * -> * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable4 (a :: * -> * -> * -> * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable5 (a :: * -> * -> * -> * -> * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable6 (a :: * -> * -> * -> * -> * -> * -> *) = Typeable a

-- | <i>Deprecated: renamed to <a>Typeable</a></i>
type Typeable7 (a :: * -> * -> * -> * -> * -> * -> * -> *) = Typeable a

-- | The type-safe cast operation
cast :: (Typeable a, Typeable b) => a -> Maybe b

-- | Extract a witness of equality of two types
eqT :: (Typeable a, Typeable b) => Maybe (a :~: b)

-- | A flexible variation parameterised in a type constructor
gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)

-- | Cast over <tt>k1 -&gt; k2</tt>
gcast1 :: (Typeable t, Typeable t') => c (t a) -> Maybe (c (t' a))

-- | Cast over <tt>k1 -&gt; k2 -&gt; k3</tt>
gcast2 :: (Typeable t, Typeable t') => c (t a b) -> Maybe (c (t' a b))

-- | A concrete, poly-kinded proxy type
data Proxy t
Proxy :: Proxy t

-- | A concrete representation of a (monomorphic) type. <a>TypeRep</a>
--   supports reasonably efficient equality.
data TypeRep

-- | Observe the <a>Fingerprint</a> of a type representation
typeRepFingerprint :: TypeRep -> Fingerprint

-- | Helper to fully evaluate <a>TypeRep</a> for use as
--   <tt>NFData(rnf)</tt> implementation
rnfTypeRep :: TypeRep -> ()
showsTypeRep :: TypeRep -> ShowS

-- | An abstract representation of a type constructor. <a>TyCon</a> objects
--   can be built using <a>mkTyCon</a>.
data TyCon

tyConFingerprint :: TyCon -> Fingerprint

-- | Observe string encoding of a type representation

-- | <i>Deprecated: renamed to <a>tyConName</a>; <a>tyConModule</a> and
--   <a>tyConPackage</a> are also available.</i>
tyConString :: TyCon -> String

tyConPackage :: TyCon -> String

tyConModule :: TyCon -> String

tyConName :: TyCon -> String

-- | Helper to fully evaluate <a>TyCon</a> for use as <tt>NFData(rnf)</tt>
--   implementation
rnfTyCon :: TyCon -> ()

-- | Builds a <a>TyCon</a> object representing a type constructor. An
--   implementation of <a>Data.Typeable</a> should ensure that the
--   following holds:
--   
--   <pre>
--   A==A' ^ B==B' ^ C==C' ==&gt; mkTyCon A B C == mkTyCon A' B' C'
--   </pre>
mkTyCon3 :: String -> String -> String -> TyCon

-- | Applies a monomorphic type constructor to a sequence of types
mkTyConApp :: TyCon -> [TypeRep] -> TypeRep

-- | Adds a TypeRep argument to a TypeRep.
mkAppTy :: TypeRep -> TypeRep -> TypeRep

-- | A special case of <a>mkTyConApp</a>, which applies the function type
--   constructor to a pair of types.
mkFunTy :: TypeRep -> TypeRep -> TypeRep

-- | Splits a type constructor application. Note that if the type
--   construcotr is polymorphic, this will not return the kinds that were
--   used. See <a>splitPolyTyConApp</a> if you need all parts.
splitTyConApp :: TypeRep -> (TyCon, [TypeRep])

-- | Applies a type to a function type. Returns: <tt><a>Just</a> u</tt> if
--   the first argument represents a function of type <tt>t -&gt; u</tt>
--   and the second argument represents a function of type <tt>t</tt>.
--   Otherwise, returns <a>Nothing</a>.
funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep

-- | Observe the type constructor of a type representation
typeRepTyCon :: TypeRep -> TyCon

-- | Observe the argument types of a type representation
typeRepArgs :: TypeRep -> [TypeRep]


-- | Signed integer types
module Data.Int

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | 8-bit signed integer type
data Int8

-- | 16-bit signed integer type
data Int16

-- | 32-bit signed integer type
data Int32

-- | 64-bit signed integer type
data Int64


-- | The Either type, and associated operations.
module Data.Either

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <tt>length</tt> function (if we have a <a>String</a>) or the
--   "times-two" function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Either.Either a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Either.Either a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Either.Either a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Either.Either a b)
instance GHC.Base.Functor (Data.Either.Either a)
instance GHC.Base.Applicative (Data.Either.Either e)
instance GHC.Base.Monad (Data.Either.Either e)


-- | If you're using <tt>GHC.Generics</tt>, you should consider using the
--   <a>http://hackage.haskell.org/package/generic-deriving</a> package,
--   which contains many useful generic functions.
module GHC.Generics

-- | Void: used for datatypes without constructors
data V1 p

-- | Unit: used for constructors without arguments
data U1 p
U1 :: U1 p

-- | Used for marking occurrences of the parameter
newtype Par1 p
Par1 :: p -> Par1 p
[unPar1] :: Par1 p -> p

-- | Recursive calls of kind * -&gt; *
newtype Rec1 f p
Rec1 :: f p -> Rec1 f p
[unRec1] :: Rec1 f p -> f p

-- | Constants, additional parameters and recursion of kind *
newtype K1 i c p
K1 :: c -> K1 i c p
[unK1] :: K1 i c p -> c

-- | Meta-information (constructor names, etc.)
newtype M1 i c f p
M1 :: f p -> M1 i c f p
[unM1] :: M1 i c f p -> f p

-- | Sums: encode choice between constructors
data (:+:) f g p
L1 :: (f p) -> (:+:) f g p
R1 :: (g p) -> (:+:) f g p

-- | Products: encode multiple arguments to constructors
data (:*:) f g p
(:*:) :: f p -> g p -> (:*:) f g p

-- | Composition of functors
newtype (:.:) f g p
Comp1 :: f (g p) -> (:.:) f g p
[unComp1] :: (:.:) f g p -> f (g p)

-- | Type synonym for encoding recursion (of kind *)
type Rec0 = K1 R

-- | Type synonym for encoding parameters (other than the last)

-- | <i>Deprecated: <a>Par0</a> is no longer used; use <a>Rec0</a>
--   instead</i>
type Par0 = K1 P

-- | Tag for K1: recursion (of kind *)
data R

-- | Tag for K1: parameters (other than the last)

-- | <i>Deprecated: <a>P</a> is no longer used; use <a>R</a> instead</i>
data P

-- | Type synonym for encoding meta-information for datatypes
type D1 = M1 D

-- | Type synonym for encoding meta-information for constructors
type C1 = M1 C

-- | Type synonym for encoding meta-information for record selectors
type S1 = M1 S

-- | Tag for M1: datatype
data D

-- | Tag for M1: constructor
data C

-- | Tag for M1: record selector
data S

-- | Class for datatypes that represent datatypes
class Datatype d where isNewtype _ = False

-- | The name of the datatype (unqualified)
datatypeName :: Datatype d => t d (f :: * -> *) a -> [Char]

-- | The fully-qualified name of the module where the type is declared
moduleName :: Datatype d => t d (f :: * -> *) a -> [Char]

-- | Marks if the datatype is actually a newtype
isNewtype :: Datatype d => t d (f :: * -> *) a -> Bool

-- | Class for datatypes that represent data constructors
class Constructor c where conFixity _ = Prefix conIsRecord _ = False

-- | The name of the constructor
conName :: Constructor c => t c (f :: * -> *) a -> [Char]

-- | The fixity of the constructor
conFixity :: Constructor c => t c (f :: * -> *) a -> Fixity

-- | Marks if this constructor is a record
conIsRecord :: Constructor c => t c (f :: * -> *) a -> Bool

-- | Class for datatypes that represent records
class Selector s

-- | The name of the selector
selName :: Selector s => t s (f :: * -> *) a -> [Char]

-- | Used for constructor fields without a name
data NoSelector

-- | Datatype to represent the fixity of a constructor. An infix |
--   declaration directly corresponds to an application of <a>Infix</a>.
data Fixity
Prefix :: Fixity
Infix :: Associativity -> Int -> Fixity

-- | Datatype to represent the associativity of a constructor
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | Datatype to represent the arity of a tuple.
data Arity
NoArity :: Arity
Arity :: Int -> Arity

-- | Get the precedence of a fixity value.
prec :: Fixity -> Int

-- | Representable types of kind *. This class is derivable in GHC with the
--   DeriveGeneric flag on.
class Generic a where type family Rep a :: * -> *

-- | Convert from the datatype to its representation
from :: Generic a => a -> (Rep a) x

-- | Convert from the representation to the datatype
to :: Generic a => (Rep a) x -> a

-- | Representable types of kind * -&gt; *. This class is derivable in GHC
--   with the DeriveGeneric flag on.
class Generic1 f where type family Rep1 f :: * -> *

-- | Convert from the datatype to its representation
from1 :: Generic1 f => f a -> (Rep1 f) a

-- | Convert from the representation to the datatype
to1 :: Generic1 f => (Rep1 f) a -> f a
instance GHC.Generics.Constructor GHC.Generics.C1_1Bool
instance GHC.Generics.Constructor GHC.Generics.C1_0Bool
instance GHC.Generics.Datatype GHC.Generics.D1Bool
instance GHC.Generics.Constructor GHC.Generics.C1_2Ordering
instance GHC.Generics.Constructor GHC.Generics.C1_1Ordering
instance GHC.Generics.Constructor GHC.Generics.C1_0Ordering
instance GHC.Generics.Datatype GHC.Generics.D1Ordering
instance GHC.Generics.Constructor GHC.Generics.C1_0()
instance GHC.Generics.Datatype GHC.Generics.D1()
instance GHC.Generics.Constructor GHC.Generics.C1_1[]
instance GHC.Generics.Constructor GHC.Generics.C1_0[]
instance GHC.Generics.Datatype GHC.Generics.D1[]
instance GHC.Generics.Constructor GHC.Generics.C1_1Maybe
instance GHC.Generics.Constructor GHC.Generics.C1_0Maybe
instance GHC.Generics.Datatype GHC.Generics.D1Maybe
instance GHC.Generics.Constructor GHC.Generics.C1_1Either
instance GHC.Generics.Constructor GHC.Generics.C1_0Either
instance GHC.Generics.Datatype GHC.Generics.D1Either
instance GHC.Generics.Constructor GHC.Generics.C1_0(,)
instance GHC.Generics.Datatype GHC.Generics.D1(,)
instance GHC.Generics.Constructor GHC.Generics.C1_0(,,)
instance GHC.Generics.Datatype GHC.Generics.D1(,,)
instance GHC.Generics.Constructor GHC.Generics.C1_0(,,,)
instance GHC.Generics.Datatype GHC.Generics.D1(,,,)
instance GHC.Generics.Constructor GHC.Generics.C1_0(,,,,)
instance GHC.Generics.Datatype GHC.Generics.D1(,,,,)
instance GHC.Generics.Constructor GHC.Generics.C1_0(,,,,,)
instance GHC.Generics.Datatype GHC.Generics.D1(,,,,,)
instance GHC.Generics.Constructor GHC.Generics.C1_0(,,,,,,)
instance GHC.Generics.Datatype GHC.Generics.D1(,,,,,,)
instance GHC.Generics.Constructor GHC.Generics.C1_0Proxy
instance GHC.Generics.Datatype GHC.Generics.D1Proxy
instance GHC.Generics.Constructor GHC.Generics.C1_1Arity
instance GHC.Generics.Constructor GHC.Generics.C1_0Arity
instance GHC.Generics.Datatype GHC.Generics.D1Arity
instance GHC.Generics.Constructor GHC.Generics.C1_1Fixity
instance GHC.Generics.Constructor GHC.Generics.C1_0Fixity
instance GHC.Generics.Datatype GHC.Generics.D1Fixity
instance GHC.Generics.Constructor GHC.Generics.C1_2Associativity
instance GHC.Generics.Constructor GHC.Generics.C1_1Associativity
instance GHC.Generics.Constructor GHC.Generics.C1_0Associativity
instance GHC.Generics.Datatype GHC.Generics.D1Associativity
instance GHC.Generics.Selector GHC.Generics.S1_0_0:.:
instance GHC.Generics.Constructor GHC.Generics.C1_0:.:
instance GHC.Generics.Datatype GHC.Generics.D1:.:
instance GHC.Generics.Constructor GHC.Generics.C1_0:*:
instance GHC.Generics.Datatype GHC.Generics.D1:*:
instance GHC.Generics.Constructor GHC.Generics.C1_1:+:
instance GHC.Generics.Constructor GHC.Generics.C1_0:+:
instance GHC.Generics.Datatype GHC.Generics.D1:+:
instance GHC.Generics.Selector GHC.Generics.S1_0_0M1
instance GHC.Generics.Constructor GHC.Generics.C1_0M1
instance GHC.Generics.Datatype GHC.Generics.D1M1
instance GHC.Generics.Selector GHC.Generics.S1_0_0K1
instance GHC.Generics.Constructor GHC.Generics.C1_0K1
instance GHC.Generics.Datatype GHC.Generics.D1K1
instance GHC.Generics.Selector GHC.Generics.S1_0_0Rec1
instance GHC.Generics.Constructor GHC.Generics.C1_0Rec1
instance GHC.Generics.Datatype GHC.Generics.D1Rec1
instance GHC.Generics.Selector GHC.Generics.S1_0_0Par1
instance GHC.Generics.Constructor GHC.Generics.C1_0Par1
instance GHC.Generics.Datatype GHC.Generics.D1Par1
instance GHC.Generics.Constructor GHC.Generics.C1_0U1
instance GHC.Generics.Datatype GHC.Generics.D1U1
instance GHC.Generics.Generic GHC.Generics.Arity
instance GHC.Read.Read GHC.Generics.Arity
instance GHC.Classes.Ord GHC.Generics.Arity
instance GHC.Show.Show GHC.Generics.Arity
instance GHC.Classes.Eq GHC.Generics.Arity
instance GHC.Generics.Generic GHC.Generics.Fixity
instance GHC.Read.Read GHC.Generics.Fixity
instance GHC.Classes.Ord GHC.Generics.Fixity
instance GHC.Show.Show GHC.Generics.Fixity
instance GHC.Classes.Eq GHC.Generics.Fixity
instance GHC.Generics.Generic GHC.Generics.Associativity
instance GHC.Read.Read GHC.Generics.Associativity
instance GHC.Classes.Ord GHC.Generics.Associativity
instance GHC.Show.Show GHC.Generics.Associativity
instance GHC.Classes.Eq GHC.Generics.Associativity
instance GHC.Generics.Generic ((GHC.Generics.:.:) f g p)
instance GHC.Show.Show (f (g p)) => GHC.Show.Show ((GHC.Generics.:.:) f g p)
instance GHC.Read.Read (f (g p)) => GHC.Read.Read ((GHC.Generics.:.:) f g p)
instance GHC.Classes.Ord (f (g p)) => GHC.Classes.Ord ((GHC.Generics.:.:) f g p)
instance GHC.Classes.Eq (f (g p)) => GHC.Classes.Eq ((GHC.Generics.:.:) f g p)
instance GHC.Generics.Generic ((GHC.Generics.:*:) f g p)
instance (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:*:) f g p)
instance (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:*:) f g p)
instance (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:*:) f g p)
instance (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:*:) f g p)
instance GHC.Generics.Generic ((GHC.Generics.:+:) f g p)
instance (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:+:) f g p)
instance (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:+:) f g p)
instance (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:+:) f g p)
instance (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:+:) f g p)
instance GHC.Generics.Generic (GHC.Generics.M1 i c f p)
instance GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.M1 i c f p)
instance GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.M1 i c f p)
instance GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.M1 i c f p)
instance GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.M1 i c f p)
instance GHC.Generics.Generic (GHC.Generics.K1 i c p)
instance GHC.Show.Show c => GHC.Show.Show (GHC.Generics.K1 i c p)
instance GHC.Read.Read c => GHC.Read.Read (GHC.Generics.K1 i c p)
instance GHC.Classes.Ord c => GHC.Classes.Ord (GHC.Generics.K1 i c p)
instance GHC.Classes.Eq c => GHC.Classes.Eq (GHC.Generics.K1 i c p)
instance GHC.Generics.Generic (GHC.Generics.Rec1 f p)
instance GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.Rec1 f p)
instance GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.Rec1 f p)
instance GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.Rec1 f p)
instance GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.Rec1 f p)
instance GHC.Generics.Generic (GHC.Generics.Par1 p)
instance GHC.Show.Show p => GHC.Show.Show (GHC.Generics.Par1 p)
instance GHC.Read.Read p => GHC.Read.Read (GHC.Generics.Par1 p)
instance GHC.Classes.Ord p => GHC.Classes.Ord (GHC.Generics.Par1 p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (GHC.Generics.Par1 p)
instance GHC.Generics.Generic (GHC.Generics.U1 p)
instance GHC.Show.Show (GHC.Generics.U1 p)
instance GHC.Read.Read (GHC.Generics.U1 p)
instance GHC.Classes.Ord (GHC.Generics.U1 p)
instance GHC.Classes.Eq (GHC.Generics.U1 p)
instance GHC.Generics.Generic [a]
instance GHC.Generics.Generic (GHC.Base.Maybe a)
instance GHC.Generics.Generic (Data.Either.Either a b)
instance GHC.Generics.Generic GHC.Types.Bool
instance GHC.Generics.Generic GHC.Types.Ordering
instance GHC.Generics.Generic ()
instance GHC.Generics.Generic (a, b)
instance GHC.Generics.Generic (a, b, c)
instance GHC.Generics.Generic (a, b, c, d)
instance GHC.Generics.Generic (a, b, c, d, e)
instance GHC.Generics.Generic (a, b, c, d, e, f)
instance GHC.Generics.Generic (a, b, c, d, e, f, g)
instance GHC.Generics.Generic1 []
instance GHC.Generics.Generic1 GHC.Base.Maybe
instance GHC.Generics.Generic1 (Data.Either.Either a)
instance GHC.Generics.Generic1 ((,) a)
instance GHC.Generics.Generic1 ((,,) a b)
instance GHC.Generics.Generic1 ((,,,) a b c)
instance GHC.Generics.Generic1 ((,,,,) a b c d)
instance GHC.Generics.Generic1 ((,,,,,) a b c d e)
instance GHC.Generics.Generic1 ((,,,,,,) a b c d e f)
instance GHC.Generics.Generic (Data.Proxy.Proxy t)
instance GHC.Generics.Selector GHC.Generics.NoSelector
instance GHC.Generics.Datatype GHC.Generics.D_Int
instance GHC.Generics.Constructor GHC.Generics.C_Int
instance GHC.Generics.Generic GHC.Types.Int
instance GHC.Generics.Datatype GHC.Generics.D_Float
instance GHC.Generics.Constructor GHC.Generics.C_Float
instance GHC.Generics.Generic GHC.Types.Float
instance GHC.Generics.Datatype GHC.Generics.D_Double
instance GHC.Generics.Constructor GHC.Generics.C_Double
instance GHC.Generics.Generic GHC.Types.Double
instance GHC.Generics.Datatype GHC.Generics.D_Char
instance GHC.Generics.Constructor GHC.Generics.C_Char
instance GHC.Generics.Generic GHC.Types.Char


-- | A class for monoids (types with an associative binary operation that
--   has an identity) with various general-purpose instances.
module Data.Monoid

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
class Monoid a where mconcat = foldr mappend mempty

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid. For most types, the default definition
--   for <a>mconcat</a> will be used, but the function is included in the
--   class definition so that an optimized version can be provided for
--   specific types.
mconcat :: Monoid a => [a] -> a

-- | An infix synonym for <a>mappend</a>.
(<>) :: Monoid m => m -> m -> m

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction (<a>||</a>).
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Maybe monoid returning the leftmost non-Nothing value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
newtype First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | Maybe monoid returning the rightmost non-Nothing value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
newtype Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | Monoid under <a>&lt;|&gt;</a>.
newtype Alt f a
Alt :: f a -> Alt f a
[getAlt] :: Alt f a -> f a
instance GHC.Generics.Selector Data.Monoid.S1_0_0Alt
instance GHC.Generics.Constructor Data.Monoid.C1_0Alt
instance GHC.Generics.Datatype Data.Monoid.D1Alt
instance GHC.Generics.Selector Data.Monoid.S1_0_0Last
instance GHC.Generics.Constructor Data.Monoid.C1_0Last
instance GHC.Generics.Datatype Data.Monoid.D1Last
instance GHC.Generics.Selector Data.Monoid.S1_0_0First
instance GHC.Generics.Constructor Data.Monoid.C1_0First
instance GHC.Generics.Datatype Data.Monoid.D1First
instance GHC.Generics.Selector Data.Monoid.S1_0_0Product
instance GHC.Generics.Constructor Data.Monoid.C1_0Product
instance GHC.Generics.Datatype Data.Monoid.D1Product
instance GHC.Generics.Selector Data.Monoid.S1_0_0Sum
instance GHC.Generics.Constructor Data.Monoid.C1_0Sum
instance GHC.Generics.Datatype Data.Monoid.D1Sum
instance GHC.Generics.Selector Data.Monoid.S1_0_0Any
instance GHC.Generics.Constructor Data.Monoid.C1_0Any
instance GHC.Generics.Datatype Data.Monoid.D1Any
instance GHC.Generics.Selector Data.Monoid.S1_0_0All
instance GHC.Generics.Constructor Data.Monoid.C1_0All
instance GHC.Generics.Datatype Data.Monoid.D1All
instance GHC.Generics.Selector Data.Monoid.S1_0_0Endo
instance GHC.Generics.Constructor Data.Monoid.C1_0Endo
instance GHC.Generics.Datatype Data.Monoid.D1Endo
instance GHC.Generics.Selector Data.Monoid.S1_0_0Dual
instance GHC.Generics.Constructor Data.Monoid.C1_0Dual
instance GHC.Generics.Datatype Data.Monoid.D1Dual
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Monoid.Alt f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Monoid.Alt f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Monoid.Alt f)
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (Data.Monoid.Alt f)
instance GHC.Base.Monad f => GHC.Base.Monad (Data.Monoid.Alt f)
instance forall (k :: BOX) (f :: k -> *) (a :: k). GHC.Enum.Enum (f a) => GHC.Enum.Enum (Data.Monoid.Alt f a)
instance forall (k :: BOX) (f :: k -> *) (a :: k). GHC.Num.Num (f a) => GHC.Num.Num (Data.Monoid.Alt f a)
instance forall (k :: BOX) (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Monoid.Alt f a)
instance forall (k :: BOX) (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Monoid.Alt f a)
instance forall (k :: BOX) (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Monoid.Alt f a)
instance forall (k :: BOX) (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (Data.Monoid.Alt f a)
instance GHC.Generics.Generic1 (Data.Monoid.Alt f)
instance forall (k :: BOX) (f :: k -> *) (a :: k). GHC.Generics.Generic (Data.Monoid.Alt f a)
instance GHC.Base.Monad Data.Monoid.Last
instance GHC.Base.Applicative Data.Monoid.Last
instance GHC.Base.Functor Data.Monoid.Last
instance GHC.Generics.Generic1 Data.Monoid.Last
instance GHC.Generics.Generic (Data.Monoid.Last a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Last a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Last a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.Last a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.Last a)
instance GHC.Base.Monad Data.Monoid.First
instance GHC.Base.Applicative Data.Monoid.First
instance GHC.Base.Functor Data.Monoid.First
instance GHC.Generics.Generic1 Data.Monoid.First
instance GHC.Generics.Generic (Data.Monoid.First a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.First a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.First a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.First a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.First a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Monoid.Product a)
instance GHC.Generics.Generic1 Data.Monoid.Product
instance GHC.Generics.Generic (Data.Monoid.Product a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Monoid.Product a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Product a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Product a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.Product a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.Product a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Monoid.Sum a)
instance GHC.Generics.Generic1 Data.Monoid.Sum
instance GHC.Generics.Generic (Data.Monoid.Sum a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Monoid.Sum a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Sum a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Sum a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.Sum a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.Sum a)
instance GHC.Generics.Generic Data.Monoid.Any
instance GHC.Enum.Bounded Data.Monoid.Any
instance GHC.Show.Show Data.Monoid.Any
instance GHC.Read.Read Data.Monoid.Any
instance GHC.Classes.Ord Data.Monoid.Any
instance GHC.Classes.Eq Data.Monoid.Any
instance GHC.Generics.Generic Data.Monoid.All
instance GHC.Enum.Bounded Data.Monoid.All
instance GHC.Show.Show Data.Monoid.All
instance GHC.Read.Read Data.Monoid.All
instance GHC.Classes.Ord Data.Monoid.All
instance GHC.Classes.Eq Data.Monoid.All
instance GHC.Generics.Generic (Data.Monoid.Endo a)
instance GHC.Generics.Generic1 Data.Monoid.Dual
instance GHC.Generics.Generic (Data.Monoid.Dual a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Monoid.Dual a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Dual a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Dual a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.Dual a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.Dual a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Monoid.Dual a)
instance GHC.Base.Monoid (Data.Monoid.Endo a)
instance GHC.Base.Monoid Data.Monoid.All
instance GHC.Base.Monoid Data.Monoid.Any
instance GHC.Num.Num a => GHC.Base.Monoid (Data.Monoid.Sum a)
instance GHC.Num.Num a => GHC.Base.Monoid (Data.Monoid.Product a)
instance GHC.Base.Monoid (Data.Monoid.First a)
instance GHC.Base.Monoid (Data.Monoid.Last a)
instance GHC.Base.Alternative f => GHC.Base.Monoid (Data.Monoid.Alt f a)


-- | Class of data structures that can be folded to a summary value.
module Data.Foldable

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable t where fold = foldMap id foldMap f = foldr (mappend . f) mempty foldr f z t = appEndo (foldMap (Endo #. f) t) z foldr' f z0 xs = foldl f' id xs z0 where f' k x z = k $! f x z foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z foldl' f z0 xs = foldr f' id xs z0 where f' x k z = k $! f z x foldr1 f xs = fromMaybe (error "foldr1: empty structure") (foldr mf Nothing xs) where mf x m = Just (case m of { Nothing -> x Just y -> f x y }) foldl1 f xs = fromMaybe (error "foldl1: empty structure") (foldl mf Nothing xs) where mf m y = Just (case m of { Nothing -> y Just x -> f x y }) toList t = build (\ c n -> foldr c n t) null = foldr (\ _ _ -> False) True length = foldl' (\ c _ -> c + 1) 0 elem = any . (==) maximum = fromMaybe (error "maximum: empty structure") . getMax . foldMap (Max #. (Just :: a -> Maybe a)) minimum = fromMaybe (error "minimum: empty structure") . getMin . foldMap (Min #. (Just :: a -> Maybe a)) sum = getSum #. foldMap Sum product = getProduct #. foldMap Product

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   <pre>
--   <a>foldr</a> f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Right-associative fold of a structure, but with strict application of
--   the operator.
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   <pre>
--   <a>foldl</a> f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure. but with strict application of
--   the operator.
--   
--   <pre>
--   <a>foldl</a> f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and ignore the results. For a version that doesn't
--   ignore the results see <a>traverse</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | The sum of a collection of actions, generalizing <a>concat</a>.
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The sum of a collection of actions, generalizing <a>concat</a>. As of
--   base 4.8.0.0, <a>msum</a> is just <a>asum</a>, specialized to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
instance Data.Foldable.Foldable GHC.Base.Maybe
instance Data.Foldable.Foldable []
instance Data.Foldable.Foldable (Data.Either.Either a)
instance Data.Foldable.Foldable ((,) a)
instance GHC.Arr.Ix i => Data.Foldable.Foldable (GHC.Arr.Array i)
instance Data.Foldable.Foldable Data.Proxy.Proxy
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Foldable.Max a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Foldable.Min a)


-- | Converting strings to values.
--   
--   The <a>Text.Read</a> library is the canonical library to import for
--   <a>Read</a>-class facilities. For GHC only, it offers an extended and
--   much improved <a>Read</a> class, which constitutes a proposed
--   alternative to the Haskell 2010 <a>Read</a>. In particular, writing
--   parsers is easier, and the parsers are much more efficient.
module Text.Read

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
class Read a where readsPrec = readPrec_to_S readPrec readList = readPrec_to_S (list readPrec) 0 readPrec = readS_to_Prec readsPrec readListPrec = readS_to_Prec (\ _ -> readList)

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | Proposed replacement for <a>readsPrec</a> using new-style parsers (GHC
--   only).
readPrec :: Read a => ReadPrec a

-- | Proposed replacement for <a>readList</a> using new-style parsers (GHC
--   only). The default definition uses <a>readList</a>. Instances that
--   define <a>readPrec</a> should also define <a>readListPrec</a> as
--   <a>readListPrecDefault</a>.
readListPrec :: Read a => ReadPrec [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process.
read :: Read a => String -> a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String
data Lexeme

-- | Character literal
Char :: Char -> Lexeme

-- | String literal, with escapes interpreted
String :: String -> Lexeme

-- | Punctuation or reserved symbol, e.g. <tt>(</tt>, <tt>::</tt>
Punc :: String -> Lexeme

-- | Haskell identifier, e.g. <tt>foo</tt>, <tt>Baz</tt>
Ident :: String -> Lexeme

-- | Haskell symbol, e.g. <tt>&gt;&gt;</tt>, <tt>:%</tt>
Symbol :: String -> Lexeme

Number :: Number -> Lexeme
EOF :: Lexeme

-- | Parse a single lexeme
lexP :: ReadPrec Lexeme

-- | <tt>(parens p)</tt> parses "P", "(P0)", "((P0))", etc, where
--   <tt>p</tt> parses "P" in the current precedence context and parses
--   "P0" in precedence context zero
parens :: ReadPrec a -> ReadPrec a

-- | A possible replacement definition for the <a>readList</a> method (GHC
--   only). This is only needed for GHC, and even then only for <a>Read</a>
--   instances where <a>readListPrec</a> isn't defined as
--   <a>readListPrecDefault</a>.
readListDefault :: Read a => ReadS [a]

-- | A possible replacement definition for the <a>readListPrec</a> method,
--   defined using <a>readPrec</a> (GHC only).
readListPrecDefault :: Read a => ReadPrec [a]

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result. A <a>Left</a> value indicates a parse error.
readEither :: Read a => String -> Either String a

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
readMaybe :: Read a => String -> Maybe a


-- | Mutable references in the IO monad.
module Data.IORef

-- | A mutable variable in the <a>IO</a> monad
data IORef a

-- | Build a new <a>IORef</a>
newIORef :: a -> IO (IORef a)

-- | Read the value of an <a>IORef</a>
readIORef :: IORef a -> IO a

-- | Write a new value into an <a>IORef</a>
writeIORef :: IORef a -> a -> IO ()

-- | Mutate the contents of an <a>IORef</a>.
--   
--   Be warned that <a>modifyIORef</a> does not apply the function
--   strictly. This means if the program calls <a>modifyIORef</a> many
--   times, but seldomly uses the value, thunks will pile up in memory
--   resulting in a space leak. This is a common mistake made when using an
--   IORef as a counter. For example, the following will likely produce a
--   stack overflow:
--   
--   <pre>
--   ref &lt;- newIORef 0
--   replicateM_ 1000000 $ modifyIORef ref (+1)
--   readIORef ref &gt;&gt;= print
--   </pre>
--   
--   To avoid this problem, use <a>modifyIORef'</a> instead.
modifyIORef :: IORef a -> (a -> a) -> IO ()

-- | Strict version of <a>modifyIORef</a>
modifyIORef' :: IORef a -> (a -> a) -> IO ()

-- | Atomically modifies the contents of an <a>IORef</a>.
--   
--   This function is useful for using <a>IORef</a> in a safe way in a
--   multithreaded program. If you only have one <a>IORef</a>, then using
--   <a>atomicModifyIORef</a> to access and modify it will prevent race
--   conditions.
--   
--   Extending the atomicity to multiple <a>IORef</a>s is problematic, so
--   it is recommended that if you need to do anything more complicated
--   then using <a>MVar</a> instead is a good idea.
--   
--   <a>atomicModifyIORef</a> does not apply the function strictly. This is
--   important to know even if all you are doing is replacing the value.
--   For example, this will leak memory:
--   
--   <pre>
--   ref &lt;- newIORef '1'
--   forever $ atomicModifyIORef ref (\_ -&gt; ('2', ()))
--   </pre>
--   
--   Use <a>atomicModifyIORef'</a> or <a>atomicWriteIORef</a> to avoid this
--   problem.
atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b

-- | Strict version of <a>atomicModifyIORef</a>. This forces both the value
--   stored in the <a>IORef</a> as well as the value returned.
atomicModifyIORef' :: IORef a -> (a -> (a, b)) -> IO b

-- | Variant of <a>writeIORef</a> with the "barrier to reordering" property
--   that <a>atomicModifyIORef</a> has.
atomicWriteIORef :: IORef a -> a -> IO ()

-- | Make a <a>Weak</a> pointer to an <a>IORef</a>, using the second
--   argument as a finalizer to run when <a>IORef</a> is garbage-collected
mkWeakIORef :: IORef a -> IO () -> IO (Weak (IORef a))


-- | Marshalling support. Unsafe API.
module Foreign.Marshal.Unsafe

-- | Sometimes an external entity is a pure function, except that it passes
--   arguments and/or results via pointers. The function
--   <tt>unsafeLocalState</tt> permits the packaging of such entities as
--   pure functions.
--   
--   The only IO operations allowed in the IO action passed to
--   <tt>unsafeLocalState</tt> are (a) local allocation (<tt>alloca</tt>,
--   <tt>allocaBytes</tt> and derived operations such as <tt>withArray</tt>
--   and <tt>withCString</tt>), and (b) pointer operations
--   (<tt>Foreign.Storable</tt> and <tt>Foreign.Ptr</tt>) on the pointers
--   to local storage, and (c) foreign functions whose only observable
--   effect is to read and/or write the locally allocated memory. Passing
--   an IO operation that does not obey these rules results in undefined
--   behaviour.
--   
--   It is expected that this operation will be replaced in a future
--   revision of Haskell.
unsafeLocalState :: IO a -> a


-- | The Dynamic interface provides basic support for dynamic types.
--   
--   Operations for injecting values of arbitrary type into a dynamically
--   typed value, Dynamic, are provided, together with operations for
--   converting dynamic values into a concrete (monomorphic) type.
module Data.Dynamic

-- | A value of type <a>Dynamic</a> is an object encapsulated together with
--   its type.
--   
--   A <a>Dynamic</a> may only represent a monomorphic value; an attempt to
--   create a value of type <a>Dynamic</a> from a polymorphically-typed
--   expression will result in an ambiguity error (see <a>toDyn</a>).
--   
--   <a>Show</a>ing a value of type <a>Dynamic</a> returns a pretty-printed
--   representation of the object's type; useful for debugging.
data Dynamic

-- | Converts an arbitrary value into an object of type <a>Dynamic</a>.
--   
--   The type of the object must be an instance of <a>Typeable</a>, which
--   ensures that only monomorphically-typed objects may be converted to
--   <a>Dynamic</a>. To convert a polymorphic object into <a>Dynamic</a>,
--   give it a monomorphic type signature. For example:
--   
--   <pre>
--   toDyn (id :: Int -&gt; Int)
--   </pre>
toDyn :: Typeable a => a -> Dynamic

-- | Converts a <a>Dynamic</a> object back into an ordinary Haskell value
--   of the correct type. See also <a>fromDynamic</a>.
fromDyn :: Typeable a => Dynamic -> a -> a

-- | Converts a <a>Dynamic</a> object back into an ordinary Haskell value
--   of the correct type. See also <a>fromDyn</a>.
fromDynamic :: Typeable a => Dynamic -> Maybe a
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
dynApp :: Dynamic -> Dynamic -> Dynamic
dynTypeRep :: Dynamic -> TypeRep
instance GHC.Show.Show Data.Dynamic.Dynamic
instance GHC.Exception.Exception Data.Dynamic.Dynamic


-- | The module <a>Foreign.Storable</a> provides most elementary support
--   for marshalling and is part of the language-independent portion of the
--   Foreign Function Interface (FFI), and will normally be imported via
--   the <a>Foreign</a> module.
module Foreign.Storable

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class Storable a where peekElemOff = peekElemOff_ undefined where peekElemOff_ :: a -> Ptr a -> Int -> IO a peekElemOff_ undef ptr off = peekByteOff ptr (off * sizeOf undef) pokeElemOff ptr off val = pokeByteOff ptr (off * sizeOf val) val peekByteOff ptr off = peek (ptr `plusPtr` off) pokeByteOff ptr off = poke (ptr `plusPtr` off) peek ptr = peekElemOff ptr 0 poke ptr = pokeElemOff ptr 0

-- | Computes the storage requirements (in bytes) of the argument. The
--   value of the argument is not used.
sizeOf :: Storable a => a -> Int

-- | Computes the alignment constraint of the argument. An alignment
--   constraint <tt>x</tt> is fulfilled by any address divisible by
--   <tt>x</tt>. The value of the argument is not used.
alignment :: Storable a => a -> Int

-- | Read a value from a memory area regarded as an array of values of the
--   same kind. The first argument specifies the start address of the array
--   and the second the index into the array (the first element of the
--   array has index <tt>0</tt>). The following equality holds,
--   
--   <pre>
--   peekElemOff addr idx = IOExts.fixIO $ \result -&gt;
--     peek (addr `plusPtr` (idx * sizeOf result))
--   </pre>
--   
--   Note that this is only a specification, not necessarily the concrete
--   implementation of the function.
peekElemOff :: Storable a => Ptr a -> Int -> IO a

-- | Write a value to a memory area regarded as an array of values of the
--   same kind. The following equality holds:
--   
--   <pre>
--   pokeElemOff addr idx x = 
--     poke (addr `plusPtr` (idx * sizeOf x)) x
--   </pre>
pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()

-- | Read a value from a memory location given by a base address and
--   offset. The following equality holds:
--   
--   <pre>
--   peekByteOff addr off = peek (addr `plusPtr` off)
--   </pre>
peekByteOff :: Storable a => Ptr b -> Int -> IO a

-- | Write a value to a memory location given by a base address and offset.
--   The following equality holds:
--   
--   <pre>
--   pokeByteOff addr off x = poke (addr `plusPtr` off) x
--   </pre>
pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()

-- | Read a value from the given memory location.
--   
--   Note that the peek and poke functions might require properly aligned
--   addresses to function correctly. This is architecture dependent; thus,
--   portable code should ensure that when peeking or poking values of some
--   type <tt>a</tt>, the alignment constraint for <tt>a</tt>, as given by
--   the function <a>alignment</a> is fulfilled.
peek :: Storable a => Ptr a -> IO a

-- | Write the given value to the given memory location. Alignment
--   restrictions might apply; see <a>peek</a>.
poke :: Storable a => Ptr a -> a -> IO ()
instance Foreign.Storable.Storable GHC.Types.Bool
instance Foreign.Storable.Storable GHC.Types.Char
instance Foreign.Storable.Storable GHC.Types.Int
instance Foreign.Storable.Storable GHC.Types.Word
instance Foreign.Storable.Storable (GHC.Ptr.Ptr a)
instance Foreign.Storable.Storable (GHC.Ptr.FunPtr a)
instance Foreign.Storable.Storable (GHC.Stable.StablePtr a)
instance Foreign.Storable.Storable GHC.Types.Float
instance Foreign.Storable.Storable GHC.Types.Double
instance Foreign.Storable.Storable GHC.Word.Word8
instance Foreign.Storable.Storable GHC.Word.Word16
instance Foreign.Storable.Storable GHC.Word.Word32
instance Foreign.Storable.Storable GHC.Word.Word64
instance Foreign.Storable.Storable GHC.Int.Int8
instance Foreign.Storable.Storable GHC.Int.Int16
instance Foreign.Storable.Storable GHC.Int.Int32
instance Foreign.Storable.Storable GHC.Int.Int64
instance (Foreign.Storable.Storable a, GHC.Real.Integral a) => Foreign.Storable.Storable (GHC.Real.Ratio a)
instance Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint


-- | Mapping of C types to corresponding Haskell types.
module Foreign.C.Types

-- | Haskell type representing the C <tt>char</tt> type.
newtype CChar
CChar :: Int8 -> CChar

-- | Haskell type representing the C <tt>signed char</tt> type.
newtype CSChar
CSChar :: Int8 -> CSChar

-- | Haskell type representing the C <tt>unsigned char</tt> type.
newtype CUChar
CUChar :: Word8 -> CUChar

-- | Haskell type representing the C <tt>short</tt> type.
newtype CShort
CShort :: Int16 -> CShort

-- | Haskell type representing the C <tt>unsigned short</tt> type.
newtype CUShort
CUShort :: Word16 -> CUShort

-- | Haskell type representing the C <tt>int</tt> type.
newtype CInt
CInt :: Int32 -> CInt

-- | Haskell type representing the C <tt>unsigned int</tt> type.
newtype CUInt
CUInt :: Word32 -> CUInt

-- | Haskell type representing the C <tt>long</tt> type.
newtype CLong
CLong :: Int64 -> CLong

-- | Haskell type representing the C <tt>unsigned long</tt> type.
newtype CULong
CULong :: Word64 -> CULong

-- | Haskell type representing the C <tt>ptrdiff_t</tt> type.
newtype CPtrdiff
CPtrdiff :: Int64 -> CPtrdiff

-- | Haskell type representing the C <tt>size_t</tt> type.
newtype CSize
CSize :: Word64 -> CSize

-- | Haskell type representing the C <tt>wchar_t</tt> type.
newtype CWchar
CWchar :: Int32 -> CWchar

-- | Haskell type representing the C <tt>sig_atomic_t</tt> type.
newtype CSigAtomic
CSigAtomic :: Int32 -> CSigAtomic

-- | Haskell type representing the C <tt>long long</tt> type.
newtype CLLong
CLLong :: Int64 -> CLLong

-- | Haskell type representing the C <tt>unsigned long long</tt> type.
newtype CULLong
CULLong :: Word64 -> CULLong
newtype CIntPtr
CIntPtr :: Int64 -> CIntPtr
newtype CUIntPtr
CUIntPtr :: Word64 -> CUIntPtr
newtype CIntMax
CIntMax :: Int64 -> CIntMax
newtype CUIntMax
CUIntMax :: Word64 -> CUIntMax

-- | Haskell type representing the C <tt>clock_t</tt> type.
newtype CClock
CClock :: Word64 -> CClock

-- | Haskell type representing the C <tt>time_t</tt> type.
newtype CTime
CTime :: Int64 -> CTime

-- | Haskell type representing the C <tt>useconds_t</tt> type.
newtype CUSeconds
CUSeconds :: Word32 -> CUSeconds

-- | Haskell type representing the C <tt>suseconds_t</tt> type.
newtype CSUSeconds
CSUSeconds :: Int32 -> CSUSeconds

-- | Haskell type representing the C <tt>float</tt> type.
newtype CFloat
CFloat :: Float -> CFloat

-- | Haskell type representing the C <tt>double</tt> type.
newtype CDouble
CDouble :: Double -> CDouble

-- | Haskell type representing the C <tt>FILE</tt> type.
data CFile

-- | Haskell type representing the C <tt>fpos_t</tt> type.
data CFpos

-- | Haskell type representing the C <tt>jmp_buf</tt> type.
data CJmpBuf
instance Data.Bits.FiniteBits Foreign.C.Types.CUIntMax
instance Data.Bits.Bits Foreign.C.Types.CUIntMax
instance GHC.Real.Integral Foreign.C.Types.CUIntMax
instance GHC.Enum.Bounded Foreign.C.Types.CUIntMax
instance GHC.Real.Real Foreign.C.Types.CUIntMax
instance Foreign.Storable.Storable Foreign.C.Types.CUIntMax
instance GHC.Enum.Enum Foreign.C.Types.CUIntMax
instance GHC.Num.Num Foreign.C.Types.CUIntMax
instance GHC.Classes.Ord Foreign.C.Types.CUIntMax
instance GHC.Classes.Eq Foreign.C.Types.CUIntMax
instance Data.Bits.FiniteBits Foreign.C.Types.CIntMax
instance Data.Bits.Bits Foreign.C.Types.CIntMax
instance GHC.Real.Integral Foreign.C.Types.CIntMax
instance GHC.Enum.Bounded Foreign.C.Types.CIntMax
instance GHC.Real.Real Foreign.C.Types.CIntMax
instance Foreign.Storable.Storable Foreign.C.Types.CIntMax
instance GHC.Enum.Enum Foreign.C.Types.CIntMax
instance GHC.Num.Num Foreign.C.Types.CIntMax
instance GHC.Classes.Ord Foreign.C.Types.CIntMax
instance GHC.Classes.Eq Foreign.C.Types.CIntMax
instance Data.Bits.FiniteBits Foreign.C.Types.CUIntPtr
instance Data.Bits.Bits Foreign.C.Types.CUIntPtr
instance GHC.Real.Integral Foreign.C.Types.CUIntPtr
instance GHC.Enum.Bounded Foreign.C.Types.CUIntPtr
instance GHC.Real.Real Foreign.C.Types.CUIntPtr
instance Foreign.Storable.Storable Foreign.C.Types.CUIntPtr
instance GHC.Enum.Enum Foreign.C.Types.CUIntPtr
instance GHC.Num.Num Foreign.C.Types.CUIntPtr
instance GHC.Classes.Ord Foreign.C.Types.CUIntPtr
instance GHC.Classes.Eq Foreign.C.Types.CUIntPtr
instance Data.Bits.FiniteBits Foreign.C.Types.CIntPtr
instance Data.Bits.Bits Foreign.C.Types.CIntPtr
instance GHC.Real.Integral Foreign.C.Types.CIntPtr
instance GHC.Enum.Bounded Foreign.C.Types.CIntPtr
instance GHC.Real.Real Foreign.C.Types.CIntPtr
instance Foreign.Storable.Storable Foreign.C.Types.CIntPtr
instance GHC.Enum.Enum Foreign.C.Types.CIntPtr
instance GHC.Num.Num Foreign.C.Types.CIntPtr
instance GHC.Classes.Ord Foreign.C.Types.CIntPtr
instance GHC.Classes.Eq Foreign.C.Types.CIntPtr
instance GHC.Real.Real Foreign.C.Types.CSUSeconds
instance Foreign.Storable.Storable Foreign.C.Types.CSUSeconds
instance GHC.Enum.Enum Foreign.C.Types.CSUSeconds
instance GHC.Num.Num Foreign.C.Types.CSUSeconds
instance GHC.Classes.Ord Foreign.C.Types.CSUSeconds
instance GHC.Classes.Eq Foreign.C.Types.CSUSeconds
instance GHC.Real.Real Foreign.C.Types.CUSeconds
instance Foreign.Storable.Storable Foreign.C.Types.CUSeconds
instance GHC.Enum.Enum Foreign.C.Types.CUSeconds
instance GHC.Num.Num Foreign.C.Types.CUSeconds
instance GHC.Classes.Ord Foreign.C.Types.CUSeconds
instance GHC.Classes.Eq Foreign.C.Types.CUSeconds
instance GHC.Real.Real Foreign.C.Types.CTime
instance Foreign.Storable.Storable Foreign.C.Types.CTime
instance GHC.Enum.Enum Foreign.C.Types.CTime
instance GHC.Num.Num Foreign.C.Types.CTime
instance GHC.Classes.Ord Foreign.C.Types.CTime
instance GHC.Classes.Eq Foreign.C.Types.CTime
instance GHC.Real.Real Foreign.C.Types.CClock
instance Foreign.Storable.Storable Foreign.C.Types.CClock
instance GHC.Enum.Enum Foreign.C.Types.CClock
instance GHC.Num.Num Foreign.C.Types.CClock
instance GHC.Classes.Ord Foreign.C.Types.CClock
instance GHC.Classes.Eq Foreign.C.Types.CClock
instance Data.Bits.FiniteBits Foreign.C.Types.CSigAtomic
instance Data.Bits.Bits Foreign.C.Types.CSigAtomic
instance GHC.Real.Integral Foreign.C.Types.CSigAtomic
instance GHC.Enum.Bounded Foreign.C.Types.CSigAtomic
instance GHC.Real.Real Foreign.C.Types.CSigAtomic
instance Foreign.Storable.Storable Foreign.C.Types.CSigAtomic
instance GHC.Enum.Enum Foreign.C.Types.CSigAtomic
instance GHC.Num.Num Foreign.C.Types.CSigAtomic
instance GHC.Classes.Ord Foreign.C.Types.CSigAtomic
instance GHC.Classes.Eq Foreign.C.Types.CSigAtomic
instance Data.Bits.FiniteBits Foreign.C.Types.CWchar
instance Data.Bits.Bits Foreign.C.Types.CWchar
instance GHC.Real.Integral Foreign.C.Types.CWchar
instance GHC.Enum.Bounded Foreign.C.Types.CWchar
instance GHC.Real.Real Foreign.C.Types.CWchar
instance Foreign.Storable.Storable Foreign.C.Types.CWchar
instance GHC.Enum.Enum Foreign.C.Types.CWchar
instance GHC.Num.Num Foreign.C.Types.CWchar
instance GHC.Classes.Ord Foreign.C.Types.CWchar
instance GHC.Classes.Eq Foreign.C.Types.CWchar
instance Data.Bits.FiniteBits Foreign.C.Types.CSize
instance Data.Bits.Bits Foreign.C.Types.CSize
instance GHC.Real.Integral Foreign.C.Types.CSize
instance GHC.Enum.Bounded Foreign.C.Types.CSize
instance GHC.Real.Real Foreign.C.Types.CSize
instance Foreign.Storable.Storable Foreign.C.Types.CSize
instance GHC.Enum.Enum Foreign.C.Types.CSize
instance GHC.Num.Num Foreign.C.Types.CSize
instance GHC.Classes.Ord Foreign.C.Types.CSize
instance GHC.Classes.Eq Foreign.C.Types.CSize
instance Data.Bits.FiniteBits Foreign.C.Types.CPtrdiff
instance Data.Bits.Bits Foreign.C.Types.CPtrdiff
instance GHC.Real.Integral Foreign.C.Types.CPtrdiff
instance GHC.Enum.Bounded Foreign.C.Types.CPtrdiff
instance GHC.Real.Real Foreign.C.Types.CPtrdiff
instance Foreign.Storable.Storable Foreign.C.Types.CPtrdiff
instance GHC.Enum.Enum Foreign.C.Types.CPtrdiff
instance GHC.Num.Num Foreign.C.Types.CPtrdiff
instance GHC.Classes.Ord Foreign.C.Types.CPtrdiff
instance GHC.Classes.Eq Foreign.C.Types.CPtrdiff
instance GHC.Float.RealFloat Foreign.C.Types.CDouble
instance GHC.Real.RealFrac Foreign.C.Types.CDouble
instance GHC.Float.Floating Foreign.C.Types.CDouble
instance GHC.Real.Fractional Foreign.C.Types.CDouble
instance GHC.Real.Real Foreign.C.Types.CDouble
instance Foreign.Storable.Storable Foreign.C.Types.CDouble
instance GHC.Enum.Enum Foreign.C.Types.CDouble
instance GHC.Num.Num Foreign.C.Types.CDouble
instance GHC.Classes.Ord Foreign.C.Types.CDouble
instance GHC.Classes.Eq Foreign.C.Types.CDouble
instance GHC.Float.RealFloat Foreign.C.Types.CFloat
instance GHC.Real.RealFrac Foreign.C.Types.CFloat
instance GHC.Float.Floating Foreign.C.Types.CFloat
instance GHC.Real.Fractional Foreign.C.Types.CFloat
instance GHC.Real.Real Foreign.C.Types.CFloat
instance Foreign.Storable.Storable Foreign.C.Types.CFloat
instance GHC.Enum.Enum Foreign.C.Types.CFloat
instance GHC.Num.Num Foreign.C.Types.CFloat
instance GHC.Classes.Ord Foreign.C.Types.CFloat
instance GHC.Classes.Eq Foreign.C.Types.CFloat
instance Data.Bits.FiniteBits Foreign.C.Types.CULLong
instance Data.Bits.Bits Foreign.C.Types.CULLong
instance GHC.Real.Integral Foreign.C.Types.CULLong
instance GHC.Enum.Bounded Foreign.C.Types.CULLong
instance GHC.Real.Real Foreign.C.Types.CULLong
instance Foreign.Storable.Storable Foreign.C.Types.CULLong
instance GHC.Enum.Enum Foreign.C.Types.CULLong
instance GHC.Num.Num Foreign.C.Types.CULLong
instance GHC.Classes.Ord Foreign.C.Types.CULLong
instance GHC.Classes.Eq Foreign.C.Types.CULLong
instance Data.Bits.FiniteBits Foreign.C.Types.CLLong
instance Data.Bits.Bits Foreign.C.Types.CLLong
instance GHC.Real.Integral Foreign.C.Types.CLLong
instance GHC.Enum.Bounded Foreign.C.Types.CLLong
instance GHC.Real.Real Foreign.C.Types.CLLong
instance Foreign.Storable.Storable Foreign.C.Types.CLLong
instance GHC.Enum.Enum Foreign.C.Types.CLLong
instance GHC.Num.Num Foreign.C.Types.CLLong
instance GHC.Classes.Ord Foreign.C.Types.CLLong
instance GHC.Classes.Eq Foreign.C.Types.CLLong
instance Data.Bits.FiniteBits Foreign.C.Types.CULong
instance Data.Bits.Bits Foreign.C.Types.CULong
instance GHC.Real.Integral Foreign.C.Types.CULong
instance GHC.Enum.Bounded Foreign.C.Types.CULong
instance GHC.Real.Real Foreign.C.Types.CULong
instance Foreign.Storable.Storable Foreign.C.Types.CULong
instance GHC.Enum.Enum Foreign.C.Types.CULong
instance GHC.Num.Num Foreign.C.Types.CULong
instance GHC.Classes.Ord Foreign.C.Types.CULong
instance GHC.Classes.Eq Foreign.C.Types.CULong
instance Data.Bits.FiniteBits Foreign.C.Types.CLong
instance Data.Bits.Bits Foreign.C.Types.CLong
instance GHC.Real.Integral Foreign.C.Types.CLong
instance GHC.Enum.Bounded Foreign.C.Types.CLong
instance GHC.Real.Real Foreign.C.Types.CLong
instance Foreign.Storable.Storable Foreign.C.Types.CLong
instance GHC.Enum.Enum Foreign.C.Types.CLong
instance GHC.Num.Num Foreign.C.Types.CLong
instance GHC.Classes.Ord Foreign.C.Types.CLong
instance GHC.Classes.Eq Foreign.C.Types.CLong
instance Data.Bits.FiniteBits Foreign.C.Types.CUInt
instance Data.Bits.Bits Foreign.C.Types.CUInt
instance GHC.Real.Integral Foreign.C.Types.CUInt
instance GHC.Enum.Bounded Foreign.C.Types.CUInt
instance GHC.Real.Real Foreign.C.Types.CUInt
instance Foreign.Storable.Storable Foreign.C.Types.CUInt
instance GHC.Enum.Enum Foreign.C.Types.CUInt
instance GHC.Num.Num Foreign.C.Types.CUInt
instance GHC.Classes.Ord Foreign.C.Types.CUInt
instance GHC.Classes.Eq Foreign.C.Types.CUInt
instance Data.Bits.FiniteBits Foreign.C.Types.CInt
instance Data.Bits.Bits Foreign.C.Types.CInt
instance GHC.Real.Integral Foreign.C.Types.CInt
instance GHC.Enum.Bounded Foreign.C.Types.CInt
instance GHC.Real.Real Foreign.C.Types.CInt
instance Foreign.Storable.Storable Foreign.C.Types.CInt
instance GHC.Enum.Enum Foreign.C.Types.CInt
instance GHC.Num.Num Foreign.C.Types.CInt
instance GHC.Classes.Ord Foreign.C.Types.CInt
instance GHC.Classes.Eq Foreign.C.Types.CInt
instance Data.Bits.FiniteBits Foreign.C.Types.CUShort
instance Data.Bits.Bits Foreign.C.Types.CUShort
instance GHC.Real.Integral Foreign.C.Types.CUShort
instance GHC.Enum.Bounded Foreign.C.Types.CUShort
instance GHC.Real.Real Foreign.C.Types.CUShort
instance Foreign.Storable.Storable Foreign.C.Types.CUShort
instance GHC.Enum.Enum Foreign.C.Types.CUShort
instance GHC.Num.Num Foreign.C.Types.CUShort
instance GHC.Classes.Ord Foreign.C.Types.CUShort
instance GHC.Classes.Eq Foreign.C.Types.CUShort
instance Data.Bits.FiniteBits Foreign.C.Types.CShort
instance Data.Bits.Bits Foreign.C.Types.CShort
instance GHC.Real.Integral Foreign.C.Types.CShort
instance GHC.Enum.Bounded Foreign.C.Types.CShort
instance GHC.Real.Real Foreign.C.Types.CShort
instance Foreign.Storable.Storable Foreign.C.Types.CShort
instance GHC.Enum.Enum Foreign.C.Types.CShort
instance GHC.Num.Num Foreign.C.Types.CShort
instance GHC.Classes.Ord Foreign.C.Types.CShort
instance GHC.Classes.Eq Foreign.C.Types.CShort
instance Data.Bits.FiniteBits Foreign.C.Types.CUChar
instance Data.Bits.Bits Foreign.C.Types.CUChar
instance GHC.Real.Integral Foreign.C.Types.CUChar
instance GHC.Enum.Bounded Foreign.C.Types.CUChar
instance GHC.Real.Real Foreign.C.Types.CUChar
instance Foreign.Storable.Storable Foreign.C.Types.CUChar
instance GHC.Enum.Enum Foreign.C.Types.CUChar
instance GHC.Num.Num Foreign.C.Types.CUChar
instance GHC.Classes.Ord Foreign.C.Types.CUChar
instance GHC.Classes.Eq Foreign.C.Types.CUChar
instance Data.Bits.FiniteBits Foreign.C.Types.CSChar
instance Data.Bits.Bits Foreign.C.Types.CSChar
instance GHC.Real.Integral Foreign.C.Types.CSChar
instance GHC.Enum.Bounded Foreign.C.Types.CSChar
instance GHC.Real.Real Foreign.C.Types.CSChar
instance Foreign.Storable.Storable Foreign.C.Types.CSChar
instance GHC.Enum.Enum Foreign.C.Types.CSChar
instance GHC.Num.Num Foreign.C.Types.CSChar
instance GHC.Classes.Ord Foreign.C.Types.CSChar
instance GHC.Classes.Eq Foreign.C.Types.CSChar
instance Data.Bits.FiniteBits Foreign.C.Types.CChar
instance Data.Bits.Bits Foreign.C.Types.CChar
instance GHC.Real.Integral Foreign.C.Types.CChar
instance GHC.Enum.Bounded Foreign.C.Types.CChar
instance GHC.Real.Real Foreign.C.Types.CChar
instance Foreign.Storable.Storable Foreign.C.Types.CChar
instance GHC.Enum.Enum Foreign.C.Types.CChar
instance GHC.Num.Num Foreign.C.Types.CChar
instance GHC.Classes.Ord Foreign.C.Types.CChar
instance GHC.Classes.Eq Foreign.C.Types.CChar
instance GHC.Read.Read Foreign.C.Types.CChar
instance GHC.Show.Show Foreign.C.Types.CChar
instance GHC.Read.Read Foreign.C.Types.CSChar
instance GHC.Show.Show Foreign.C.Types.CSChar
instance GHC.Read.Read Foreign.C.Types.CUChar
instance GHC.Show.Show Foreign.C.Types.CUChar
instance GHC.Read.Read Foreign.C.Types.CShort
instance GHC.Show.Show Foreign.C.Types.CShort
instance GHC.Read.Read Foreign.C.Types.CUShort
instance GHC.Show.Show Foreign.C.Types.CUShort
instance GHC.Read.Read Foreign.C.Types.CInt
instance GHC.Show.Show Foreign.C.Types.CInt
instance GHC.Read.Read Foreign.C.Types.CUInt
instance GHC.Show.Show Foreign.C.Types.CUInt
instance GHC.Read.Read Foreign.C.Types.CLong
instance GHC.Show.Show Foreign.C.Types.CLong
instance GHC.Read.Read Foreign.C.Types.CULong
instance GHC.Show.Show Foreign.C.Types.CULong
instance GHC.Read.Read Foreign.C.Types.CLLong
instance GHC.Show.Show Foreign.C.Types.CLLong
instance GHC.Read.Read Foreign.C.Types.CULLong
instance GHC.Show.Show Foreign.C.Types.CULLong
instance GHC.Read.Read Foreign.C.Types.CFloat
instance GHC.Show.Show Foreign.C.Types.CFloat
instance GHC.Read.Read Foreign.C.Types.CDouble
instance GHC.Show.Show Foreign.C.Types.CDouble
instance GHC.Read.Read Foreign.C.Types.CPtrdiff
instance GHC.Show.Show Foreign.C.Types.CPtrdiff
instance GHC.Read.Read Foreign.C.Types.CSize
instance GHC.Show.Show Foreign.C.Types.CSize
instance GHC.Read.Read Foreign.C.Types.CWchar
instance GHC.Show.Show Foreign.C.Types.CWchar
instance GHC.Read.Read Foreign.C.Types.CSigAtomic
instance GHC.Show.Show Foreign.C.Types.CSigAtomic
instance GHC.Read.Read Foreign.C.Types.CClock
instance GHC.Show.Show Foreign.C.Types.CClock
instance GHC.Read.Read Foreign.C.Types.CTime
instance GHC.Show.Show Foreign.C.Types.CTime
instance GHC.Read.Read Foreign.C.Types.CUSeconds
instance GHC.Show.Show Foreign.C.Types.CUSeconds
instance GHC.Read.Read Foreign.C.Types.CSUSeconds
instance GHC.Show.Show Foreign.C.Types.CSUSeconds
instance GHC.Read.Read Foreign.C.Types.CIntPtr
instance GHC.Show.Show Foreign.C.Types.CIntPtr
instance GHC.Read.Read Foreign.C.Types.CUIntPtr
instance GHC.Show.Show Foreign.C.Types.CUIntPtr
instance GHC.Read.Read Foreign.C.Types.CIntMax
instance GHC.Show.Show Foreign.C.Types.CIntMax
instance GHC.Read.Read Foreign.C.Types.CUIntMax
instance GHC.Show.Show Foreign.C.Types.CUIntMax


-- | FFI datatypes and operations that use or require concurrency (GHC
--   only).
module Foreign.Concurrent

-- | Turns a plain memory reference into a foreign object by associating a
--   finalizer - given by the monadic operation - with the reference. The
--   finalizer will be executed after the last reference to the foreign
--   object is dropped. There is no guarantee of promptness, and in fact
--   there is no guarantee that the finalizer will eventually run at all.
newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given <a>ForeignPtr</a>. The
--   finalizer will run after the last reference to the foreign object is
--   dropped, but <i>before</i> all previously registered finalizers for
--   the same object.
addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()


-- | This module provides typed pointers to foreign data. It is part of the
--   Foreign Function Interface (FFI) and will normally be imported via the
--   <a>Foreign</a> module.
module Foreign.Ptr

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a

-- | The constant <a>nullPtr</a> contains a distinguished value of
--   <a>Ptr</a> that is not associated with a valid memory location.
nullPtr :: Ptr a

-- | The <a>castPtr</a> function casts a pointer from one type to another.
castPtr :: Ptr a -> Ptr b

-- | Advances the given address by the given offset in bytes.
plusPtr :: Ptr a -> Int -> Ptr b

-- | Given an arbitrary address and an alignment constraint,
--   <a>alignPtr</a> yields the next higher address that fulfills the
--   alignment constraint. An alignment constraint <tt>x</tt> is fulfilled
--   by any address divisible by <tt>x</tt>. This operation is idempotent.
alignPtr :: Ptr a -> Int -> Ptr a

-- | Computes the offset required to get from the second to the first
--   argument. We have
--   
--   <pre>
--   p2 == p1 `plusPtr` (p2 `minusPtr` p1)
--   </pre>
minusPtr :: Ptr a -> Ptr b -> Int

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a

-- | The constant <a>nullFunPtr</a> contains a distinguished value of
--   <a>FunPtr</a> that is not associated with a valid memory location.
nullFunPtr :: FunPtr a

-- | Casts a <a>FunPtr</a> to a <a>FunPtr</a> of a different type.
castFunPtr :: FunPtr a -> FunPtr b

-- | Casts a <a>FunPtr</a> to a <a>Ptr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castFunPtrToPtr :: FunPtr a -> Ptr b

-- | Casts a <a>Ptr</a> to a <a>FunPtr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castPtrToFunPtr :: Ptr a -> FunPtr b

-- | Release the storage associated with the given <a>FunPtr</a>, which
--   must have been obtained from a wrapper stub. This should be called
--   whenever the return value from a foreign import wrapper function is no
--   longer required; otherwise, the storage it uses will leak.
freeHaskellFunPtr :: FunPtr a -> IO ()

-- | A signed integral type that can be losslessly converted to and from
--   <tt>Ptr</tt>. This type is also compatible with the C99 type
--   <tt>intptr_t</tt>, and can be marshalled to and from that type safely.
data IntPtr

-- | casts a <tt>Ptr</tt> to an <tt>IntPtr</tt>
ptrToIntPtr :: Ptr a -> IntPtr

-- | casts an <tt>IntPtr</tt> to a <tt>Ptr</tt>
intPtrToPtr :: IntPtr -> Ptr a

-- | An unsigned integral type that can be losslessly converted to and from
--   <tt>Ptr</tt>. This type is also compatible with the C99 type
--   <tt>uintptr_t</tt>, and can be marshalled to and from that type
--   safely.
data WordPtr

-- | casts a <tt>Ptr</tt> to a <tt>WordPtr</tt>
ptrToWordPtr :: Ptr a -> WordPtr

-- | casts a <tt>WordPtr</tt> to a <tt>Ptr</tt>
wordPtrToPtr :: WordPtr -> Ptr a
instance Data.Bits.FiniteBits Foreign.Ptr.IntPtr
instance Data.Bits.Bits Foreign.Ptr.IntPtr
instance GHC.Real.Integral Foreign.Ptr.IntPtr
instance GHC.Enum.Bounded Foreign.Ptr.IntPtr
instance GHC.Real.Real Foreign.Ptr.IntPtr
instance Foreign.Storable.Storable Foreign.Ptr.IntPtr
instance GHC.Enum.Enum Foreign.Ptr.IntPtr
instance GHC.Num.Num Foreign.Ptr.IntPtr
instance GHC.Classes.Ord Foreign.Ptr.IntPtr
instance GHC.Classes.Eq Foreign.Ptr.IntPtr
instance Data.Bits.FiniteBits Foreign.Ptr.WordPtr
instance Data.Bits.Bits Foreign.Ptr.WordPtr
instance GHC.Real.Integral Foreign.Ptr.WordPtr
instance GHC.Enum.Bounded Foreign.Ptr.WordPtr
instance GHC.Real.Real Foreign.Ptr.WordPtr
instance Foreign.Storable.Storable Foreign.Ptr.WordPtr
instance GHC.Enum.Enum Foreign.Ptr.WordPtr
instance GHC.Num.Num Foreign.Ptr.WordPtr
instance GHC.Classes.Ord Foreign.Ptr.WordPtr
instance GHC.Classes.Eq Foreign.Ptr.WordPtr
instance GHC.Read.Read Foreign.Ptr.WordPtr
instance GHC.Show.Show Foreign.Ptr.WordPtr
instance GHC.Read.Read Foreign.Ptr.IntPtr
instance GHC.Show.Show Foreign.Ptr.IntPtr


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
module Foreign.ForeignPtr

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> use the <tt>ccall</tt>
--   calling convention.
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())

-- | Turns a plain memory reference into a foreign pointer, and associates
--   a finalizer with the reference. The finalizer will be executed after
--   the last reference to the foreign object is dropped. There is no
--   guarantee of promptness, however the finalizer will be executed before
--   the program exits.
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | This variant of <a>newForeignPtr</a> adds a finalizer that expects an
--   environment in addition to the finalized pointer. The environment that
--   will be passed to the finalizer is fixed by the second argument to
--   <a>newForeignPtrEnv</a>.
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)

-- | Like <a>addForeignPtrFinalizerEnv</a> but allows the finalizer to be
--   passed an additional environment parameter to be passed to the
--   finalizer. The environment passed to the finalizer is fixed by the
--   second argument to <a>addForeignPtrFinalizerEnv</a>
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately.
finalizeForeignPtr :: ForeignPtr a -> IO ()

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. In particular
--   <a>withForeignPtr</a> does a <a>touchForeignPtr</a> after it executes
--   the user action.
--   
--   Note that this function should not be used to express dependencies
--   between finalizers on <a>ForeignPtr</a>s. For example, if the
--   finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <tt>newForeignPtr</tt> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray0</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Foreign.ForeignPtr
--   instead</i>
module Foreign.ForeignPtr.Safe

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> use the <tt>ccall</tt>
--   calling convention.
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())

-- | Turns a plain memory reference into a foreign pointer, and associates
--   a finalizer with the reference. The finalizer will be executed after
--   the last reference to the foreign object is dropped. There is no
--   guarantee of promptness, however the finalizer will be executed before
--   the program exits.
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | This variant of <a>newForeignPtr</a> adds a finalizer that expects an
--   environment in addition to the finalized pointer. The environment that
--   will be passed to the finalizer is fixed by the second argument to
--   <a>newForeignPtrEnv</a>.
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)

-- | Like <a>addForeignPtrFinalizerEnv</a> but allows the finalizer to be
--   passed an additional environment parameter to be passed to the
--   finalizer. The environment passed to the finalizer is fixed by the
--   second argument to <a>addForeignPtrFinalizerEnv</a>
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately.
finalizeForeignPtr :: ForeignPtr a -> IO ()

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. In particular
--   <a>withForeignPtr</a> does a <a>touchForeignPtr</a> after it executes
--   the user action.
--   
--   Note that this function should not be used to express dependencies
--   between finalizers on <a>ForeignPtr</a>s. For example, if the
--   finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <tt>newForeignPtr</tt> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray0</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
--   
--   Unsafe API Only.
module Foreign.ForeignPtr.Unsafe

-- | This function extracts the pointer component of a foreign pointer.
--   This is a potentially dangerous operations, as if the argument to
--   <a>unsafeForeignPtrToPtr</a> is the last usage occurrence of the given
--   foreign pointer, then its finalizer(s) will be run, which potentially
--   invalidates the plain pointer just obtained. Hence,
--   <a>touchForeignPtr</a> must be used wherever it has to be guaranteed
--   that the pointer lives on - i.e., has another usage occurrence.
--   
--   To avoid subtle coding errors, hand written marshalling code should
--   preferably use <a>withForeignPtr</a> rather than combinations of
--   <a>unsafeForeignPtrToPtr</a> and <a>touchForeignPtr</a>. However, the
--   latter routines are occasionally preferred in tool generated
--   marshalling code.
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a


-- | Buffers used in the IO system
module GHC.IO.Buffer

-- | A mutable array of bytes that can be passed to foreign functions.
--   
--   The buffer is represented by a record, where the record contains the
--   raw buffer and the start/end points of the filled portion. The buffer
--   contents itself is mutable, but the rest of the record is immutable.
--   This is a slightly odd mix, but it turns out to be quite practical: by
--   making all the buffer metadata immutable, we can have operations on
--   buffer metadata outside of the IO monad.
--   
--   The "live" elements of the buffer are those between the <a>bufL</a>
--   and <a>bufR</a> offsets. In an empty buffer, <a>bufL</a> is equal to
--   <a>bufR</a>, but they might not be zero: for exmaple, the buffer might
--   correspond to a memory-mapped file and in which case <a>bufL</a> will
--   point to the next location to be written, which is not necessarily the
--   beginning of the file.
data Buffer e
Buffer :: !(RawBuffer e) -> BufferState -> !Int -> !Int -> !Int -> Buffer e
[bufRaw] :: Buffer e -> !(RawBuffer e)
[bufState] :: Buffer e -> BufferState
[bufSize] :: Buffer e -> !Int
[bufL] :: Buffer e -> !Int
[bufR] :: Buffer e -> !Int
data BufferState
ReadBuffer :: BufferState
WriteBuffer :: BufferState
type CharBuffer = Buffer Char
type CharBufElem = Char
newByteBuffer :: Int -> BufferState -> IO (Buffer Word8)
newCharBuffer :: Int -> BufferState -> IO CharBuffer
newBuffer :: Int -> Int -> BufferState -> IO (Buffer e)
emptyBuffer :: RawBuffer e -> Int -> BufferState -> Buffer e
bufferRemove :: Int -> Buffer e -> Buffer e
bufferAdd :: Int -> Buffer e -> Buffer e

-- | slides the contents of the buffer to the beginning
slideContents :: Buffer Word8 -> IO (Buffer Word8)
bufferAdjustL :: Int -> Buffer e -> Buffer e
isEmptyBuffer :: Buffer e -> Bool
isFullBuffer :: Buffer e -> Bool
isFullCharBuffer :: Buffer e -> Bool
isWriteBuffer :: Buffer e -> Bool
bufferElems :: Buffer e -> Int
bufferAvailable :: Buffer e -> Int
summaryBuffer :: Buffer a -> String
withBuffer :: Buffer e -> (Ptr e -> IO a) -> IO a
withRawBuffer :: RawBuffer e -> (Ptr e -> IO a) -> IO a
checkBuffer :: Buffer a -> IO ()
type RawBuffer e = ForeignPtr e
readWord8Buf :: RawBuffer Word8 -> Int -> IO Word8
writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
type RawCharBuffer = RawBuffer CharBufElem
peekCharBuf :: RawCharBuffer -> Int -> IO Char
readCharBuf :: RawCharBuffer -> Int -> IO (Char, Int)
writeCharBuf :: RawCharBuffer -> Int -> Char -> IO Int
readCharBufPtr :: Ptr CharBufElem -> Int -> IO (Char, Int)
writeCharBufPtr :: Ptr CharBufElem -> Int -> Char -> IO Int
charSize :: Int
instance GHC.Classes.Eq GHC.IO.Buffer.BufferState


-- | Types for text encoding/decoding
module GHC.IO.Encoding.Types
data BufferCodec from to state
BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | The <tt>encode</tt> function translates elements of the buffer
--   <tt>from</tt> to the buffer <tt>to</tt>. It should translate as many
--   elements as possible given the sizes of the buffers, including
--   translating zero elements if there is either not enough room in
--   <tt>to</tt>, or <tt>from</tt> does not contain a complete multibyte
--   sequence.
--   
--   If multiple CodingProgress returns are possible, OutputUnderflow must
--   be preferred to InvalidSequence. This allows GHC's IO library to
--   assume that if we observe InvalidSequence there is at least a single
--   element available in the output buffer.
--   
--   The fact that as many elements as possible are translated is used by
--   the IO library in order to report translation errors at the point they
--   actually occur, rather than when the buffer is translated.
[encode] :: BufferCodec from to state -> CodeBuffer from to

-- | The <tt>recover</tt> function is used to continue decoding in the
--   presence of invalid or unrepresentable sequences. This includes both
--   those detected by <tt>encode</tt> returning <tt>InvalidSequence</tt>
--   and those that occur because the input byte sequence appears to be
--   truncated.
--   
--   Progress will usually be made by skipping the first element of the
--   <tt>from</tt> buffer. This function should only be called if you are
--   certain that you wish to do this skipping and if the <tt>to</tt>
--   buffer has at least one element of free space. Because this function
--   deals with decoding failure, it assumes that the from buffer has at
--   least one element.
--   
--   <tt>recover</tt> may raise an exception rather than skipping anything.
--   
--   Currently, some implementations of <tt>recover</tt> may mutate the
--   input buffer. In particular, this feature is used to implement
--   transliteration.
[recover] :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)

-- | Resources associated with the encoding may now be released. The
--   <tt>encode</tt> function may not be called again after calling
--   <tt>close</tt>.
[close] :: BufferCodec from to state -> IO ()

-- | Return the current state of the codec.
--   
--   Many codecs are not stateful, and in these case the state can be
--   represented as '()'. Other codecs maintain a state. For example,
--   UTF-16 recognises a BOM (byte-order-mark) character at the beginning
--   of the input, and remembers thereafter whether to use big-endian or
--   little-endian mode. In this case, the state of the codec would include
--   two pieces of information: whether we are at the beginning of the
--   stream (the BOM only occurs at the beginning), and if not, whether to
--   use the big or little-endian encoding.
[getState] :: BufferCodec from to state -> IO state
[setState] :: BufferCodec from to state -> state -> IO ()

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <tt>utf8</tt>.
data TextEncoding
TextEncoding :: String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding

-- | a string that can be passed to <tt>mkTextEncoding</tt> to create an
--   equivalent <a>TextEncoding</a>.
[textEncodingName] :: TextEncoding -> String

-- | Creates a means of decoding bytes into characters: the result must not
--   be shared between several byte sequences or simultaneously across
--   threads
[mkTextDecoder] :: TextEncoding -> IO (TextDecoder dstate)

-- | Creates a means of encode characters into bytes: the result must not
--   be shared between several character sequences or simultaneously across
--   threads
[mkTextEncoder] :: TextEncoding -> IO (TextEncoder estate)
type TextEncoder state = BufferCodec CharBufElem Word8 state
type TextDecoder state = BufferCodec Word8 CharBufElem state
type CodeBuffer from to = Buffer from -> Buffer to -> IO (CodingProgress, Buffer from, Buffer to)
type EncodeBuffer = CodeBuffer Char Word8
type DecodeBuffer = CodeBuffer Word8 Char

data CodingProgress

-- | Stopped because the input contains insufficient available elements, or
--   all of the input sequence has been sucessfully translated.
InputUnderflow :: CodingProgress

-- | Stopped because the output contains insufficient free elements
OutputUnderflow :: CodingProgress

-- | Stopped because there are sufficient free elements in the output to
--   output at least one encoded ASCII character, but the input contains an
--   invalid or unrepresentable sequence
InvalidSequence :: CodingProgress
instance GHC.Show.Show GHC.IO.Encoding.Types.CodingProgress
instance GHC.Classes.Eq GHC.IO.Encoding.Types.CodingProgress
instance GHC.Show.Show GHC.IO.Encoding.Types.TextEncoding


-- | Type classes for I/O providers.
module GHC.IO.Device

-- | A low-level I/O provider where the data is bytes in memory.
class RawIO a

-- | Read up to the specified number of bytes, returning the number of
--   bytes actually read. This function should only block if there is no
--   data available. If there is not enough data available, then the
--   function should just return the available data. A return value of zero
--   indicates that the end of the data stream (e.g. end of file) has been
--   reached.
read :: RawIO a => a -> Ptr Word8 -> Int -> IO Int

-- | Read up to the specified number of bytes, returning the number of
--   bytes actually read, or <a>Nothing</a> if the end of the stream has
--   been reached.
readNonBlocking :: RawIO a => a -> Ptr Word8 -> Int -> IO (Maybe Int)

-- | Write the specified number of bytes.
write :: RawIO a => a -> Ptr Word8 -> Int -> IO ()

-- | Write up to the specified number of bytes without blocking. Returns
--   the actual number of bytes written.
writeNonBlocking :: RawIO a => a -> Ptr Word8 -> Int -> IO Int

-- | I/O operations required for implementing a <tt>Handle</tt>.
class IODevice a where isTerminal _ = return False isSeekable _ = return False seek _ _ _ = ioe_unsupportedOperation tell _ = ioe_unsupportedOperation getSize _ = ioe_unsupportedOperation setSize _ _ = ioe_unsupportedOperation setEcho _ _ = ioe_unsupportedOperation getEcho _ = ioe_unsupportedOperation setRaw _ _ = ioe_unsupportedOperation dup _ = ioe_unsupportedOperation dup2 _ _ = ioe_unsupportedOperation

-- | <tt>ready dev write msecs</tt> returns <a>True</a> if the device has
--   data to read (if <tt>write</tt> is <a>False</a>) or space to write new
--   data (if <tt>write</tt> is <a>True</a>). <tt>msecs</tt> specifies how
--   long to wait, in milliseconds.
ready :: IODevice a => a -> Bool -> Int -> IO Bool

-- | closes the device. Further operations on the device should produce
--   exceptions.
close :: IODevice a => a -> IO ()

-- | returns <a>True</a> if the device is a terminal or console.
isTerminal :: IODevice a => a -> IO Bool

-- | returns <a>True</a> if the device supports <a>seek</a> operations.
isSeekable :: IODevice a => a -> IO Bool

-- | seek to the specified position in the data.
seek :: IODevice a => a -> SeekMode -> Integer -> IO ()

-- | return the current position in the data.
tell :: IODevice a => a -> IO Integer

-- | return the size of the data.
getSize :: IODevice a => a -> IO Integer

-- | change the size of the data.
setSize :: IODevice a => a -> Integer -> IO ()

-- | for terminal devices, changes whether characters are echoed on the
--   device.
setEcho :: IODevice a => a -> Bool -> IO ()

-- | returns the current echoing status.
getEcho :: IODevice a => a -> IO Bool

-- | some devices (e.g. terminals) support a "raw" mode where characters
--   entered are immediately made available to the program. If available,
--   this operations enables raw mode.
setRaw :: IODevice a => a -> Bool -> IO ()

-- | returns the <a>IODeviceType</a> corresponding to this device.
devType :: IODevice a => a -> IO IODeviceType

-- | duplicates the device, if possible. The new device is expected to
--   share a file pointer with the original device (like Unix
--   <tt>dup</tt>).
dup :: IODevice a => a -> IO a

-- | <tt>dup2 source target</tt> replaces the target device with the source
--   device. The target device is closed first, if necessary, and then it
--   is made into a duplicate of the first device (like Unix
--   <tt>dup2</tt>).
dup2 :: IODevice a => a -> a -> IO a

-- | Type of a device that can be used to back a <a>Handle</a> (see also
--   <a>mkFileHandle</a>). The standard libraries provide creation of
--   <a>Handle</a>s via Posix file operations with file descriptors (see
--   <a>mkHandleFromFD</a>) with FD being the underlying <a>IODevice</a>
--   instance.
--   
--   Users may provide custom instances of <a>IODevice</a> which are
--   expected to conform the following rules:
data IODeviceType

-- | The standard libraries do not have direct support for this device
--   type, but a user implementation is expected to provide a list of file
--   names in the directory, in any order, separated by <tt>'\0'</tt>
--   characters, excluding the <tt>"."</tt> and <tt>".."</tt> names. See
--   also <a>getDirectoryContents</a>. Seek operations are not supported on
--   directories (other than to the zero position).
Directory :: IODeviceType

-- | A duplex communications channel (results in creation of a duplex
--   <a>Handle</a>). The standard libraries use this device type when
--   creating <a>Handle</a>s for open sockets.
Stream :: IODeviceType

-- | A file that may be read or written, and also may be seekable.
RegularFile :: IODeviceType

-- | A "raw" (disk) device which supports block binary read and write
--   operations and may be seekable only to positions of certain
--   granularity (block- aligned).
RawDevice :: IODeviceType

-- | A mode that determines the effect of <tt>hSeek</tt> <tt>hdl mode
--   i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode
instance GHC.Show.Show GHC.IO.Device.SeekMode
instance GHC.Read.Read GHC.IO.Device.SeekMode
instance GHC.Enum.Enum GHC.IO.Device.SeekMode
instance GHC.Arr.Ix GHC.IO.Device.SeekMode
instance GHC.Classes.Ord GHC.IO.Device.SeekMode
instance GHC.Classes.Eq GHC.IO.Device.SeekMode
instance GHC.Classes.Eq GHC.IO.Device.IODeviceType


-- | Class of buffered IO devices
module GHC.IO.BufferedIO

-- | The purpose of <a>BufferedIO</a> is to provide a common interface for
--   I/O devices that can read and write data through a buffer. Devices
--   that implement <a>BufferedIO</a> include ordinary files, memory-mapped
--   files, and bytestrings. The underlying device implementing a
--   <tt>Handle</tt> must provide <a>BufferedIO</a>.
class BufferedIO dev where emptyWriteBuffer _dev buf = return (buf {bufL = 0, bufR = 0, bufState = WriteBuffer})

-- | allocate a new buffer. The size of the buffer is at the discretion of
--   the device; e.g. for a memory-mapped file the buffer will probably
--   cover the entire file.
newBuffer :: BufferedIO dev => dev -> BufferState -> IO (Buffer Word8)

-- | reads bytes into the buffer, blocking if there are no bytes available.
--   Returns the number of bytes read (zero indicates end-of-file), and the
--   new buffer.
fillReadBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)

-- | reads bytes into the buffer without blocking. Returns the number of
--   bytes read (Nothing indicates end-of-file), and the new buffer.
fillReadBuffer0 :: BufferedIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)

-- | Prepares an empty write buffer. This lets the device decide how to set
--   up a write buffer: the buffer may need to point to a specific location
--   in memory, for example. This is typically used by the client when
--   switching from reading to writing on a buffered read/write device.
--   
--   There is no corresponding operation for read buffers, because before
--   reading the client will always call <a>fillReadBuffer</a>.
emptyWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)

-- | Flush all the data from the supplied write buffer out to the device.
--   The returned buffer should be empty, and ready for writing.
flushWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)

-- | Flush data from the supplied write buffer out to the device without
--   blocking. Returns the number of bytes written and the remaining
--   buffer.
flushWriteBuffer0 :: BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
readBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
readBufNonBlocking :: RawIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)
writeBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)
writeBufNonBlocking :: RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)


-- | The module <a>Foreign.Marshal.Alloc</a> provides operations to
--   allocate and deallocate blocks of raw memory (i.e., unstructured
--   chunks of memory outside of the area maintained by the Haskell storage
--   manager). These memory blocks are commonly used to pass compound data
--   structures to foreign functions or to provide space in which compound
--   result values are obtained from foreign functions.
--   
--   If any of the allocation functions fails, an exception is thrown. In
--   some cases, memory exhaustion may mean the process is terminated. If
--   <a>free</a> or <a>reallocBytes</a> is applied to a memory area that
--   has been allocated with <a>alloca</a> or <a>allocaBytes</a>, the
--   behaviour is undefined. Any further access to memory areas allocated
--   with <a>alloca</a> or <a>allocaBytes</a>, after the computation that
--   was passed to the allocation function has terminated, leads to
--   undefined behaviour. Any further access to the memory area referenced
--   by a pointer passed to <a>realloc</a>, <a>reallocBytes</a>, or
--   <a>free</a> entails undefined behaviour.
--   
--   All storage allocated by functions that allocate based on a <i>size in
--   bytes</i> must be sufficiently aligned for any of the basic foreign
--   types that fits into the newly allocated storage. All storage
--   allocated by functions that allocate based on a specific type must be
--   sufficiently aligned for that type. Array allocation routines need to
--   obey the same alignment constraints for each array element.
module Foreign.Marshal.Alloc

-- | <tt><a>alloca</a> f</tt> executes the computation <tt>f</tt>, passing
--   as argument a pointer to a temporarily allocated block of memory
--   sufficient to hold values of type <tt>a</tt>.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
alloca :: Storable a => (Ptr a -> IO b) -> IO b

-- | <tt><a>allocaBytes</a> n f</tt> executes the computation <tt>f</tt>,
--   passing as argument a pointer to a temporarily allocated block of
--   memory of <tt>n</tt> bytes. The block of memory is sufficiently
--   aligned for any of the basic foreign types that fits into a memory
--   block of the allocated size.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
allocaBytesAligned :: Int -> Int -> (Ptr a -> IO b) -> IO b

-- | Allocate a block of memory that is sufficient to hold values of type
--   <tt>a</tt>. The size of the area allocated is determined by the
--   <a>sizeOf</a> method from the instance of <a>Storable</a> for the
--   appropriate type.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
malloc :: Storable a => IO (Ptr a)

-- | Allocate a block of memory of the given number of bytes. The block of
--   memory is sufficiently aligned for any of the basic foreign types that
--   fits into a memory block of the allocated size.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
mallocBytes :: Int -> IO (Ptr a)

-- | Like <a>malloc</a> but memory is filled with bytes of value zero.
calloc :: Storable a => IO (Ptr a)

-- | Llike <a>mallocBytes</a> but memory is filled with bytes of value
--   zero.
callocBytes :: Int -> IO (Ptr a)

-- | Resize a memory area that was allocated with <a>malloc</a> or
--   <a>mallocBytes</a> to the size needed to store values of type
--   <tt>b</tt>. The returned pointer may refer to an entirely different
--   memory area, but will be suitably aligned to hold values of type
--   <tt>b</tt>. The contents of the referenced memory area will be the
--   same as of the original pointer up to the minimum of the original size
--   and the size of values of type <tt>b</tt>.
--   
--   If the argument to <a>realloc</a> is <a>nullPtr</a>, <a>realloc</a>
--   behaves like <a>malloc</a>.
realloc :: Storable b => Ptr a -> IO (Ptr b)

-- | Resize a memory area that was allocated with <a>malloc</a> or
--   <a>mallocBytes</a> to the given size. The returned pointer may refer
--   to an entirely different memory area, but will be sufficiently aligned
--   for any of the basic foreign types that fits into a memory block of
--   the given size. The contents of the referenced memory area will be the
--   same as of the original pointer up to the minimum of the original size
--   and the given size.
--   
--   If the pointer argument to <a>reallocBytes</a> is <a>nullPtr</a>,
--   <a>reallocBytes</a> behaves like <a>malloc</a>. If the requested size
--   is 0, <a>reallocBytes</a> behaves like <a>free</a>.
reallocBytes :: Ptr a -> Int -> IO (Ptr a)

-- | Free a block of memory that was allocated with <a>malloc</a>,
--   <a>mallocBytes</a>, <a>realloc</a>, <a>reallocBytes</a>, <a>new</a> or
--   any of the <tt>new</tt><i>X</i> functions in
--   <a>Foreign.Marshal.Array</a> or <a>Foreign.C.String</a>.
free :: Ptr a -> IO ()

-- | A pointer to a foreign function equivalent to <a>free</a>, which may
--   be used as a finalizer (cf <a>ForeignPtr</a>) for storage allocated
--   with <a>malloc</a>, <a>mallocBytes</a>, <a>realloc</a> or
--   <a>reallocBytes</a>.
finalizerFree :: FinalizerPtr a


-- | Utilities for primitive marshaling
module Foreign.Marshal.Utils

-- | <tt><a>with</a> val f</tt> executes the computation <tt>f</tt>,
--   passing as argument a pointer to a temporarily allocated block of
--   memory into which <tt>val</tt> has been marshalled (the combination of
--   <a>alloca</a> and <a>poke</a>).
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
with :: Storable a => a -> (Ptr a -> IO b) -> IO b

-- | Allocate a block of memory and marshal a value into it (the
--   combination of <a>malloc</a> and <a>poke</a>). The size of the area
--   allocated is determined by the <a>sizeOf</a> method from the instance
--   of <a>Storable</a> for the appropriate type.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
new :: Storable a => a -> IO (Ptr a)

-- | Convert a Haskell <a>Bool</a> to its numeric representation
fromBool :: Num a => Bool -> a

-- | Convert a Boolean in numeric representation to a Haskell value
toBool :: (Eq a, Num a) => a -> Bool

-- | Allocate storage and marshal a storable value wrapped into a
--   <a>Maybe</a>
--   
--   <ul>
--   <li>the <a>nullPtr</a> is used to represent <a>Nothing</a></li>
--   </ul>
maybeNew :: (a -> IO (Ptr b)) -> (Maybe a -> IO (Ptr b))

-- | Converts a <tt>withXXX</tt> combinator into one marshalling a value
--   wrapped into a <a>Maybe</a>, using <a>nullPtr</a> to represent
--   <a>Nothing</a>.
maybeWith :: (a -> (Ptr b -> IO c) -> IO c) -> (Maybe a -> (Ptr b -> IO c) -> IO c)

-- | Convert a peek combinator into a one returning <a>Nothing</a> if
--   applied to a <a>nullPtr</a>
maybePeek :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)

-- | Replicates a <tt>withXXX</tt> combinator over a list of objects,
--   yielding a list of marshalled objects
withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res

-- | Copies the given number of bytes from the second area (source) into
--   the first (destination); the copied areas may <i>not</i> overlap
copyBytes :: Ptr a -> Ptr a -> Int -> IO ()

-- | Copies the given number of bytes from the second area (source) into
--   the first (destination); the copied areas <i>may</i> overlap
moveBytes :: Ptr a -> Ptr a -> Int -> IO ()

-- | Fill a given number of bytes in memory area with a byte value.
fillBytes :: Ptr a -> Word8 -> Int -> IO ()


-- | Marshalling support: routines allocating, storing, and retrieving
--   Haskell lists that are represented as arrays in the foreign language
module Foreign.Marshal.Array

-- | Allocate storage for the given number of elements of a storable type
--   (like <a>malloc</a>, but for multiple elements).
mallocArray :: Storable a => Int -> IO (Ptr a)

-- | Like <a>mallocArray</a>, but add an extra position to hold a special
--   termination element.
mallocArray0 :: Storable a => Int -> IO (Ptr a)

-- | Temporarily allocate space for the given number of elements (like
--   <a>alloca</a>, but for multiple elements).
allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b

-- | Like <a>allocaArray</a>, but add an extra position to hold a special
--   termination element.
allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b

-- | Adjust the size of an array
reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)

-- | Adjust the size of an array including an extra position for the end
--   marker.
reallocArray0 :: Storable a => Ptr a -> Int -> IO (Ptr a)

-- | Like <a>mallocArray</a>, but allocated memory is filled with bytes of
--   value zero.
callocArray :: Storable a => Int -> IO (Ptr a)

-- | Like <a>callocArray0</a>, but allocated memory is filled with bytes of
--   value zero.
callocArray0 :: Storable a => Int -> IO (Ptr a)

-- | Convert an array of given length into a Haskell list. The
--   implementation is tail-recursive and so uses constant stack space.
peekArray :: Storable a => Int -> Ptr a -> IO [a]

-- | Convert an array terminated by the given end marker into a Haskell
--   list
peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]

-- | Write the list elements consecutive into memory
pokeArray :: Storable a => Ptr a -> [a] -> IO ()

-- | Write the list elements consecutive into memory and terminate them
--   with the given marker element
pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()

-- | Write a list of storable elements into a newly allocated, consecutive
--   sequence of storable values (like <a>new</a>, but for multiple
--   elements).
newArray :: Storable a => [a] -> IO (Ptr a)

-- | Write a list of storable elements into a newly allocated, consecutive
--   sequence of storable values, where the end is fixed by the given end
--   marker
newArray0 :: Storable a => a -> [a] -> IO (Ptr a)

-- | Temporarily store a list of storable values in memory (like
--   <a>with</a>, but for multiple elements).
withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b

-- | Like <a>withArray</a>, but a terminator indicates where the array ends
withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b

-- | Like <a>withArray</a>, but the action gets the number of values as an
--   additional parameter
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b

-- | Like <a>withArrayLen</a>, but a terminator indicates where the array
--   ends
withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b

-- | Copy the given number of elements from the second array (source) into
--   the first array (destination); the copied areas may <i>not</i> overlap
copyArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()

-- | Copy the given number of elements from the second array (source) into
--   the first array (destination); the copied areas <i>may</i> overlap
moveArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()

-- | Return the number of elements in an array, excluding the terminator
lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int

-- | Advance a pointer into an array by the given number of elements
advancePtr :: Storable a => Ptr a -> Int -> Ptr a


-- | Foreign marshalling support for CStrings with configurable encodings
module GHC.Foreign

-- | Marshal a NUL terminated C string into a Haskell string.
peekCString :: TextEncoding -> CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCStringLen :: TextEncoding -> CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCString :: TextEncoding -> String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCStringLen :: TextEncoding -> String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCString :: TextEncoding -> String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringLen :: TextEncoding -> String -> (CStringLen -> IO a) -> IO a

-- | Determines whether a character can be accurately encoded in a
--   <a>CString</a>.
--   
--   Pretty much anyone who uses this function is in a state of sin because
--   whether or not a character is encodable will, in general, depend on
--   the context in which it occurs.
charIsRepresentable :: TextEncoding -> Char -> IO Bool


-- | Utilities for primitive marshalling of C strings.
--   
--   The marshalling converts each Haskell character, representing a
--   Unicode code point, to one or more bytes in a manner that, by default,
--   is determined by the current locale. As a consequence, no guarantees
--   can be made about the relative length of a Haskell string and its
--   corresponding C string, and therefore all the marshalling routines
--   include memory allocation. The translation between Unicode and the
--   encoding of the current locale may be lossy.
module Foreign.C.String

-- | A C string is a reference to an array of C characters terminated by
--   NUL.
type CString = Ptr CChar

-- | A string with explicit length information in bytes instead of a
--   terminating NUL (allowing NUL characters in the middle of the string).
type CStringLen = (Ptr CChar, Int)

-- | Marshal a NUL terminated C string into a Haskell string.
peekCString :: CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCStringLen :: CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCString :: String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCStringLen :: String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCString :: String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringLen :: String -> (CStringLen -> IO a) -> IO a
charIsRepresentable :: Char -> IO Bool

-- | Convert a Haskell character to a C character. This function is only
--   safe on the first 256 characters.
castCharToCChar :: Char -> CChar

-- | Convert a C byte, representing a Latin-1 character, to the
--   corresponding Haskell character.
castCCharToChar :: CChar -> Char

-- | Convert a Haskell character to a C <tt>unsigned char</tt>. This
--   function is only safe on the first 256 characters.
castCharToCUChar :: Char -> CUChar

-- | Convert a C <tt>unsigned char</tt>, representing a Latin-1 character,
--   to the corresponding Haskell character.
castCUCharToChar :: CUChar -> Char

-- | Convert a Haskell character to a C <tt>signed char</tt>. This function
--   is only safe on the first 256 characters.
castCharToCSChar :: Char -> CSChar

-- | Convert a C <tt>signed char</tt>, representing a Latin-1 character, to
--   the corresponding Haskell character.
castCSCharToChar :: CSChar -> Char

-- | Marshal a NUL terminated C string into a Haskell string.
peekCAString :: CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCAStringLen :: CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCAString :: String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCAStringLen :: String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCAString :: String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCAStringLen :: String -> (CStringLen -> IO a) -> IO a

-- | A C wide string is a reference to an array of C wide characters
--   terminated by NUL.
type CWString = Ptr CWchar

-- | A wide character string with explicit length information in
--   <a>CWchar</a>s instead of a terminating NUL (allowing NUL characters
--   in the middle of the string).
type CWStringLen = (Ptr CWchar, Int)

-- | Marshal a NUL terminated C wide string into a Haskell string.
peekCWString :: CWString -> IO String

-- | Marshal a C wide string with explicit length into a Haskell string.
peekCWStringLen :: CWStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C wide string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C wide string and must be
--   explicitly freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCWString :: String -> IO CWString

-- | Marshal a Haskell string into a C wide string (ie, wide character
--   array) with explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C wide string and must be
--   explicitly freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCWStringLen :: String -> IO CWStringLen

-- | Marshal a Haskell string into a NUL terminated C wide string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCWString :: String -> (CWString -> IO a) -> IO a

-- | Marshal a Haskell string into a C wide string (i.e. wide character
--   array) in temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCWStringLen :: String -> (CWStringLen -> IO a) -> IO a


-- | Routines for testing return values and raising a <a>userError</a>
--   exception in case of values indicating an error state.
module Foreign.Marshal.Error

-- | Execute an <a>IO</a> action, throwing a <a>userError</a> if the
--   predicate yields <a>True</a> when applied to the result returned by
--   the <a>IO</a> action. If no exception is raised, return the result of
--   the computation.
throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a

-- | Like <a>throwIf</a>, but discarding the result
throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()

-- | Guards against negative result values
throwIfNeg :: (Ord a, Num a) => (a -> String) -> IO a -> IO a

-- | Like <a>throwIfNeg</a>, but discarding the result
throwIfNeg_ :: (Ord a, Num a) => (a -> String) -> IO a -> IO ()

-- | Guards against null pointers
throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)

-- | Discard the return value of an <a>IO</a> action

-- | <i>Deprecated: use <a>void</a> instead</i>
void :: IO a -> IO ()


-- | This module contains support for pooled memory management. Under this
--   scheme, (re-)allocations belong to a given pool, and everything in a
--   pool is deallocated when the pool itself is deallocated. This is
--   useful when <a>alloca</a> with its implicit allocation and
--   deallocation is not flexible enough, but explicit uses of
--   <a>malloc</a> and <a>free</a> are too awkward.
module Foreign.Marshal.Pool

-- | A memory pool.
data Pool

-- | Allocate a fresh memory pool.
newPool :: IO Pool

-- | Deallocate a memory pool and everything which has been allocated in
--   the pool itself.
freePool :: Pool -> IO ()

-- | Execute an action with a fresh memory pool, which gets automatically
--   deallocated (including its contents) after the action has finished.
withPool :: (Pool -> IO b) -> IO b

-- | Allocate space for storable type in the given pool. The size of the
--   area allocated is determined by the <a>sizeOf</a> method from the
--   instance of <a>Storable</a> for the appropriate type.
pooledMalloc :: Storable a => Pool -> IO (Ptr a)

-- | Allocate the given number of bytes of storage in the pool.
pooledMallocBytes :: Pool -> Int -> IO (Ptr a)

-- | Adjust the storage area for an element in the pool to the given size
--   of the required type.
pooledRealloc :: Storable a => Pool -> Ptr a -> IO (Ptr a)

-- | Adjust the storage area for an element in the pool to the given size.
pooledReallocBytes :: Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Allocate storage for the given number of elements of a storable type
--   in the pool.
pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)

-- | Allocate storage for the given number of elements of a storable type
--   in the pool, but leave room for an extra element to signal the end of
--   the array.
pooledMallocArray0 :: Storable a => Pool -> Int -> IO (Ptr a)

-- | Adjust the size of an array in the given pool.
pooledReallocArray :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Adjust the size of an array with an end marker in the given pool.
pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Allocate storage for a value in the given pool and marshal the value
--   into this storage.
pooledNew :: Storable a => Pool -> a -> IO (Ptr a)

-- | Allocate consecutive storage for a list of values in the given pool
--   and marshal these values into it.
pooledNewArray :: Storable a => Pool -> [a] -> IO (Ptr a)

-- | Allocate consecutive storage for a list of values in the given pool
--   and marshal these values into it, terminating the end with the given
--   marker.
pooledNewArray0 :: Storable a => Pool -> a -> [a] -> IO (Ptr a)


-- | Marshalling support
module Foreign.Marshal


-- | A collection of data types, classes, and functions for interfacing
--   with another programming language.
module Foreign


-- | A collection of data types, classes, and functions for interfacing
--   with another programming language.
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Foreign instead</i>
module Foreign.Safe


-- | Marshalling support
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Foreign.Marshal
--   instead</i>
module Foreign.Marshal.Safe


-- | C-specific Marshalling support: Handling of C "errno" error codes.
module Foreign.C.Error

-- | Haskell representation for <tt>errno</tt> values. The implementation
--   is deliberately exposed, to allow users to add their own definitions
--   of <a>Errno</a> values.
newtype Errno
Errno :: CInt -> Errno
eOK :: Errno
e2BIG :: Errno
eACCES :: Errno
eADDRINUSE :: Errno
eADDRNOTAVAIL :: Errno
eADV :: Errno
eAFNOSUPPORT :: Errno
eAGAIN :: Errno
eALREADY :: Errno
eBADF :: Errno
eBADMSG :: Errno
eBADRPC :: Errno
eBUSY :: Errno
eCHILD :: Errno
eCOMM :: Errno
eCONNABORTED :: Errno
eCONNREFUSED :: Errno
eCONNRESET :: Errno
eDEADLK :: Errno
eDESTADDRREQ :: Errno
eDIRTY :: Errno
eDOM :: Errno
eDQUOT :: Errno
eEXIST :: Errno
eFAULT :: Errno
eFBIG :: Errno
eFTYPE :: Errno
eHOSTDOWN :: Errno
eHOSTUNREACH :: Errno
eIDRM :: Errno
eILSEQ :: Errno
eINPROGRESS :: Errno
eINTR :: Errno
eINVAL :: Errno
eIO :: Errno
eISCONN :: Errno
eISDIR :: Errno
eLOOP :: Errno
eMFILE :: Errno
eMLINK :: Errno
eMSGSIZE :: Errno
eMULTIHOP :: Errno
eNAMETOOLONG :: Errno
eNETDOWN :: Errno
eNETRESET :: Errno
eNETUNREACH :: Errno
eNFILE :: Errno
eNOBUFS :: Errno
eNODATA :: Errno
eNODEV :: Errno
eNOENT :: Errno
eNOEXEC :: Errno
eNOLCK :: Errno
eNOLINK :: Errno
eNOMEM :: Errno
eNOMSG :: Errno
eNONET :: Errno
eNOPROTOOPT :: Errno
eNOSPC :: Errno
eNOSR :: Errno
eNOSTR :: Errno
eNOSYS :: Errno
eNOTBLK :: Errno
eNOTCONN :: Errno
eNOTDIR :: Errno
eNOTEMPTY :: Errno
eNOTSOCK :: Errno

eNOTSUP :: Errno
eNOTTY :: Errno
eNXIO :: Errno
eOPNOTSUPP :: Errno
ePERM :: Errno
ePFNOSUPPORT :: Errno
ePIPE :: Errno
ePROCLIM :: Errno
ePROCUNAVAIL :: Errno
ePROGMISMATCH :: Errno
ePROGUNAVAIL :: Errno
ePROTO :: Errno
ePROTONOSUPPORT :: Errno
ePROTOTYPE :: Errno
eRANGE :: Errno
eREMCHG :: Errno
eREMOTE :: Errno
eROFS :: Errno
eRPCMISMATCH :: Errno
eRREMOTE :: Errno
eSHUTDOWN :: Errno
eSOCKTNOSUPPORT :: Errno
eSPIPE :: Errno
eSRCH :: Errno
eSRMNT :: Errno
eSTALE :: Errno
eTIME :: Errno
eTIMEDOUT :: Errno
eTOOMANYREFS :: Errno
eTXTBSY :: Errno
eUSERS :: Errno
eWOULDBLOCK :: Errno
eXDEV :: Errno

-- | Yield <a>True</a> if the given <a>Errno</a> value is valid on the
--   system. This implies that the <a>Eq</a> instance of <a>Errno</a> is
--   also system dependent as it is only defined for valid values of
--   <a>Errno</a>.
isValidErrno :: Errno -> Bool

-- | Get the current value of <tt>errno</tt> in the current thread.
getErrno :: IO Errno

-- | Reset the current thread's <tt>errno</tt> value to <a>eOK</a>.
resetErrno :: IO ()

-- | Construct an <a>IOError</a> based on the given <a>Errno</a> value. The
--   optional information can be used to improve the accuracy of error
--   messages.
errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a>.
throwErrno :: String -> IO a

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a> if the result value of the <a>IO</a> action meets the
--   given predicate.
throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a

-- | as <a>throwErrnoIf</a>, but discards the result of the <a>IO</a>
--   action after error handling.
throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()

-- | as <a>throwErrnoIf</a>, but retry the <a>IO</a> action when it yields
--   the error code <a>eINTR</a> - this amounts to the standard retry loop
--   for interrupted POSIX system calls.
throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a

-- | as <a>throwErrnoIfRetry</a>, but discards the result.
throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns a result of
--   <tt>-1</tt>.
throwErrnoIfMinus1 :: (Eq a, Num a) => String -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1</a>, but discards the result.
throwErrnoIfMinus1_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns a result of
--   <tt>-1</tt>, but retries in case of an interrupted operation.
throwErrnoIfMinus1Retry :: (Eq a, Num a) => String -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1</a>, but discards the result.
throwErrnoIfMinus1Retry_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns <a>nullPtr</a>.
throwErrnoIfNull :: String -> IO (Ptr a) -> IO (Ptr a)

-- | Throw an <a>IOError</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns <a>nullPtr</a>, but
--   retry in case of an interrupted operation.
throwErrnoIfNullRetry :: String -> IO (Ptr a) -> IO (Ptr a)

-- | as <a>throwErrnoIfRetry</a>, but additionally if the operation yields
--   the error code <a>eAGAIN</a> or <a>eWOULDBLOCK</a>, an alternative
--   action is executed before retrying.
throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a

-- | as <a>throwErrnoIfRetryMayBlock</a>, but discards the result.
throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()

-- | as <a>throwErrnoIfMinus1Retry</a>, but checks for operations that
--   would block.
throwErrnoIfMinus1RetryMayBlock :: (Eq a, Num a) => String -> IO a -> IO b -> IO a

-- | as <a>throwErrnoIfMinus1RetryMayBlock</a>, but discards the result.
throwErrnoIfMinus1RetryMayBlock_ :: (Eq a, Num a) => String -> IO a -> IO b -> IO ()

-- | as <a>throwErrnoIfNullRetry</a>, but checks for operations that would
--   block.
throwErrnoIfNullRetryMayBlock :: String -> IO (Ptr a) -> IO b -> IO (Ptr a)

-- | as <a>throwErrno</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPath :: String -> FilePath -> IO a

-- | as <a>throwErrnoIf</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a

-- | as <a>throwErrnoIf_</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIf_ :: (a -> Bool) -> String -> FilePath -> IO a -> IO ()

-- | as <a>throwErrnoIfNull</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIfNull :: String -> FilePath -> IO (Ptr a) -> IO (Ptr a)

-- | as <a>throwErrnoIfMinus1</a>, but exceptions include the given path
--   when appropriate.
throwErrnoPathIfMinus1 :: (Eq a, Num a) => String -> FilePath -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1_</a>, but exceptions include the given path
--   when appropriate.
throwErrnoPathIfMinus1_ :: (Eq a, Num a) => String -> FilePath -> IO a -> IO ()
instance GHC.Classes.Eq Foreign.C.Error.Errno


-- | Bundles the C specific FFI library functionality
module Foreign.C


-- | POSIX data types: Haskell equivalents of the types defined by the
--   <tt>&lt;sys/types.h&gt;</tt> C header on a POSIX system.
module System.Posix.Types
newtype CDev
CDev :: Int32 -> CDev
newtype CIno
CIno :: Word64 -> CIno
newtype CMode
CMode :: Word16 -> CMode
newtype COff
COff :: Int64 -> COff
newtype CPid
CPid :: Int32 -> CPid
newtype CSsize
CSsize :: Int64 -> CSsize
newtype CGid
CGid :: Word32 -> CGid
newtype CNlink
CNlink :: Word16 -> CNlink
newtype CUid
CUid :: Word32 -> CUid
newtype CCc
CCc :: Word8 -> CCc
newtype CSpeed
CSpeed :: Word64 -> CSpeed
newtype CTcflag
CTcflag :: Word64 -> CTcflag
newtype CRLim
CRLim :: Word64 -> CRLim
newtype Fd
Fd :: CInt -> Fd
type LinkCount = CNlink
type UserID = CUid
type GroupID = CGid
type ByteCount = CSize
type ClockTick = CClock
type EpochTime = CTime
type FileOffset = COff
type ProcessID = CPid
type ProcessGroupID = CPid
type DeviceID = CDev
type FileID = CIno
type FileMode = CMode
type Limit = CLong
instance Data.Bits.FiniteBits System.Posix.Types.Fd
instance Data.Bits.Bits System.Posix.Types.Fd
instance GHC.Real.Integral System.Posix.Types.Fd
instance GHC.Enum.Bounded System.Posix.Types.Fd
instance GHC.Real.Real System.Posix.Types.Fd
instance Foreign.Storable.Storable System.Posix.Types.Fd
instance GHC.Enum.Enum System.Posix.Types.Fd
instance GHC.Num.Num System.Posix.Types.Fd
instance GHC.Classes.Ord System.Posix.Types.Fd
instance GHC.Classes.Eq System.Posix.Types.Fd
instance Data.Bits.FiniteBits System.Posix.Types.CRLim
instance Data.Bits.Bits System.Posix.Types.CRLim
instance GHC.Real.Integral System.Posix.Types.CRLim
instance GHC.Enum.Bounded System.Posix.Types.CRLim
instance GHC.Real.Real System.Posix.Types.CRLim
instance Foreign.Storable.Storable System.Posix.Types.CRLim
instance GHC.Enum.Enum System.Posix.Types.CRLim
instance GHC.Num.Num System.Posix.Types.CRLim
instance GHC.Classes.Ord System.Posix.Types.CRLim
instance GHC.Classes.Eq System.Posix.Types.CRLim
instance Data.Bits.FiniteBits System.Posix.Types.CTcflag
instance Data.Bits.Bits System.Posix.Types.CTcflag
instance GHC.Real.Integral System.Posix.Types.CTcflag
instance GHC.Enum.Bounded System.Posix.Types.CTcflag
instance GHC.Real.Real System.Posix.Types.CTcflag
instance Foreign.Storable.Storable System.Posix.Types.CTcflag
instance GHC.Enum.Enum System.Posix.Types.CTcflag
instance GHC.Num.Num System.Posix.Types.CTcflag
instance GHC.Classes.Ord System.Posix.Types.CTcflag
instance GHC.Classes.Eq System.Posix.Types.CTcflag
instance GHC.Real.Real System.Posix.Types.CSpeed
instance Foreign.Storable.Storable System.Posix.Types.CSpeed
instance GHC.Enum.Enum System.Posix.Types.CSpeed
instance GHC.Num.Num System.Posix.Types.CSpeed
instance GHC.Classes.Ord System.Posix.Types.CSpeed
instance GHC.Classes.Eq System.Posix.Types.CSpeed
instance GHC.Real.Real System.Posix.Types.CCc
instance Foreign.Storable.Storable System.Posix.Types.CCc
instance GHC.Enum.Enum System.Posix.Types.CCc
instance GHC.Num.Num System.Posix.Types.CCc
instance GHC.Classes.Ord System.Posix.Types.CCc
instance GHC.Classes.Eq System.Posix.Types.CCc
instance Data.Bits.FiniteBits System.Posix.Types.CUid
instance Data.Bits.Bits System.Posix.Types.CUid
instance GHC.Real.Integral System.Posix.Types.CUid
instance GHC.Enum.Bounded System.Posix.Types.CUid
instance GHC.Real.Real System.Posix.Types.CUid
instance Foreign.Storable.Storable System.Posix.Types.CUid
instance GHC.Enum.Enum System.Posix.Types.CUid
instance GHC.Num.Num System.Posix.Types.CUid
instance GHC.Classes.Ord System.Posix.Types.CUid
instance GHC.Classes.Eq System.Posix.Types.CUid
instance Data.Bits.FiniteBits System.Posix.Types.CNlink
instance Data.Bits.Bits System.Posix.Types.CNlink
instance GHC.Real.Integral System.Posix.Types.CNlink
instance GHC.Enum.Bounded System.Posix.Types.CNlink
instance GHC.Real.Real System.Posix.Types.CNlink
instance Foreign.Storable.Storable System.Posix.Types.CNlink
instance GHC.Enum.Enum System.Posix.Types.CNlink
instance GHC.Num.Num System.Posix.Types.CNlink
instance GHC.Classes.Ord System.Posix.Types.CNlink
instance GHC.Classes.Eq System.Posix.Types.CNlink
instance Data.Bits.FiniteBits System.Posix.Types.CGid
instance Data.Bits.Bits System.Posix.Types.CGid
instance GHC.Real.Integral System.Posix.Types.CGid
instance GHC.Enum.Bounded System.Posix.Types.CGid
instance GHC.Real.Real System.Posix.Types.CGid
instance Foreign.Storable.Storable System.Posix.Types.CGid
instance GHC.Enum.Enum System.Posix.Types.CGid
instance GHC.Num.Num System.Posix.Types.CGid
instance GHC.Classes.Ord System.Posix.Types.CGid
instance GHC.Classes.Eq System.Posix.Types.CGid
instance Data.Bits.FiniteBits System.Posix.Types.CSsize
instance Data.Bits.Bits System.Posix.Types.CSsize
instance GHC.Real.Integral System.Posix.Types.CSsize
instance GHC.Enum.Bounded System.Posix.Types.CSsize
instance GHC.Real.Real System.Posix.Types.CSsize
instance Foreign.Storable.Storable System.Posix.Types.CSsize
instance GHC.Enum.Enum System.Posix.Types.CSsize
instance GHC.Num.Num System.Posix.Types.CSsize
instance GHC.Classes.Ord System.Posix.Types.CSsize
instance GHC.Classes.Eq System.Posix.Types.CSsize
instance Data.Bits.FiniteBits System.Posix.Types.CPid
instance Data.Bits.Bits System.Posix.Types.CPid
instance GHC.Real.Integral System.Posix.Types.CPid
instance GHC.Enum.Bounded System.Posix.Types.CPid
instance GHC.Real.Real System.Posix.Types.CPid
instance Foreign.Storable.Storable System.Posix.Types.CPid
instance GHC.Enum.Enum System.Posix.Types.CPid
instance GHC.Num.Num System.Posix.Types.CPid
instance GHC.Classes.Ord System.Posix.Types.CPid
instance GHC.Classes.Eq System.Posix.Types.CPid
instance Data.Bits.FiniteBits System.Posix.Types.COff
instance Data.Bits.Bits System.Posix.Types.COff
instance GHC.Real.Integral System.Posix.Types.COff
instance GHC.Enum.Bounded System.Posix.Types.COff
instance GHC.Real.Real System.Posix.Types.COff
instance Foreign.Storable.Storable System.Posix.Types.COff
instance GHC.Enum.Enum System.Posix.Types.COff
instance GHC.Num.Num System.Posix.Types.COff
instance GHC.Classes.Ord System.Posix.Types.COff
instance GHC.Classes.Eq System.Posix.Types.COff
instance Data.Bits.FiniteBits System.Posix.Types.CMode
instance Data.Bits.Bits System.Posix.Types.CMode
instance GHC.Real.Integral System.Posix.Types.CMode
instance GHC.Enum.Bounded System.Posix.Types.CMode
instance GHC.Real.Real System.Posix.Types.CMode
instance Foreign.Storable.Storable System.Posix.Types.CMode
instance GHC.Enum.Enum System.Posix.Types.CMode
instance GHC.Num.Num System.Posix.Types.CMode
instance GHC.Classes.Ord System.Posix.Types.CMode
instance GHC.Classes.Eq System.Posix.Types.CMode
instance Data.Bits.FiniteBits System.Posix.Types.CIno
instance Data.Bits.Bits System.Posix.Types.CIno
instance GHC.Real.Integral System.Posix.Types.CIno
instance GHC.Enum.Bounded System.Posix.Types.CIno
instance GHC.Real.Real System.Posix.Types.CIno
instance Foreign.Storable.Storable System.Posix.Types.CIno
instance GHC.Enum.Enum System.Posix.Types.CIno
instance GHC.Num.Num System.Posix.Types.CIno
instance GHC.Classes.Ord System.Posix.Types.CIno
instance GHC.Classes.Eq System.Posix.Types.CIno
instance Data.Bits.FiniteBits System.Posix.Types.CDev
instance Data.Bits.Bits System.Posix.Types.CDev
instance GHC.Real.Integral System.Posix.Types.CDev
instance GHC.Enum.Bounded System.Posix.Types.CDev
instance GHC.Real.Real System.Posix.Types.CDev
instance Foreign.Storable.Storable System.Posix.Types.CDev
instance GHC.Enum.Enum System.Posix.Types.CDev
instance GHC.Num.Num System.Posix.Types.CDev
instance GHC.Classes.Ord System.Posix.Types.CDev
instance GHC.Classes.Eq System.Posix.Types.CDev
instance GHC.Read.Read System.Posix.Types.CDev
instance GHC.Show.Show System.Posix.Types.CDev
instance GHC.Read.Read System.Posix.Types.CIno
instance GHC.Show.Show System.Posix.Types.CIno
instance GHC.Read.Read System.Posix.Types.CMode
instance GHC.Show.Show System.Posix.Types.CMode
instance GHC.Read.Read System.Posix.Types.COff
instance GHC.Show.Show System.Posix.Types.COff
instance GHC.Read.Read System.Posix.Types.CPid
instance GHC.Show.Show System.Posix.Types.CPid
instance GHC.Read.Read System.Posix.Types.CSsize
instance GHC.Show.Show System.Posix.Types.CSsize
instance GHC.Read.Read System.Posix.Types.CGid
instance GHC.Show.Show System.Posix.Types.CGid
instance GHC.Read.Read System.Posix.Types.CNlink
instance GHC.Show.Show System.Posix.Types.CNlink
instance GHC.Read.Read System.Posix.Types.CUid
instance GHC.Show.Show System.Posix.Types.CUid
instance GHC.Read.Read System.Posix.Types.CCc
instance GHC.Show.Show System.Posix.Types.CCc
instance GHC.Read.Read System.Posix.Types.CSpeed
instance GHC.Show.Show System.Posix.Types.CSpeed
instance GHC.Read.Read System.Posix.Types.CTcflag
instance GHC.Show.Show System.Posix.Types.CTcflag
instance GHC.Read.Read System.Posix.Types.CRLim
instance GHC.Show.Show System.Posix.Types.CRLim
instance GHC.Read.Read System.Posix.Types.Fd
instance GHC.Show.Show System.Posix.Types.Fd


-- | Types for specifying how text encoding/decoding fails
module GHC.IO.Encoding.Failure

-- | The <a>CodingFailureMode</a> is used to construct
--   <tt>TextEncoding</tt>s, and specifies how they handle illegal
--   sequences.
data CodingFailureMode

-- | Throw an error when an illegal sequence is encountered
ErrorOnCodingFailure :: CodingFailureMode

-- | Attempt to ignore and recover if an illegal sequence is encountered
IgnoreCodingFailure :: CodingFailureMode

-- | Replace with the closest visual match upon an illegal sequence
TransliterateCodingFailure :: CodingFailureMode

-- | Use the private-use escape mechanism to attempt to allow illegal
--   sequences to be roundtripped.
RoundtripFailure :: CodingFailureMode
codingFailureModeSuffix :: CodingFailureMode -> String

-- | Some characters are actually "surrogate" codepoints defined for use in
--   UTF-16. We need to signal an invalid character if we detect them when
--   encoding a sequence of <a>Char</a>s into <a>Word8</a>s because they
--   won't give valid Unicode.
--   
--   We may also need to signal an invalid character if we detect them when
--   encoding a sequence of <a>Char</a>s into <a>Word8</a>s because the
--   <a>RoundtripFailure</a> mode creates these to round-trip bytes through
--   our internal UTF-16 encoding.
isSurrogate :: Char -> Bool
recoverDecode :: CodingFailureMode -> Buffer Word8 -> Buffer Char -> IO (Buffer Word8, Buffer Char)
recoverEncode :: CodingFailureMode -> Buffer Char -> Buffer Word8 -> IO (Buffer Char, Buffer Word8)
instance GHC.Show.Show GHC.IO.Encoding.Failure.CodingFailureMode


-- | UTF-8 Codec for the IO library
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.UTF8
utf8 :: TextEncoding

mkUTF8 :: CodingFailureMode -> TextEncoding
utf8_bom :: TextEncoding
mkUTF8_bom :: CodingFailureMode -> TextEncoding


-- | Basic concurrency stuff.
module GHC.Conc.Sync

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId
ThreadId :: ThreadId# -> ThreadId

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
forkIO :: IO () -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | the value passed to the <tt>+RTS -N</tt> flag. This is the number of
--   Haskell threads that can run truly simultaneously at any given time,
--   and is typically set to the number of physical processor cores on the
--   machine.
--   
--   Strictly speaking it is better to use <a>getNumCapabilities</a>,
--   because the number of capabilities might vary at runtime.
numCapabilities :: Int

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
setNumCapabilities :: Int -> IO ()

-- | Returns the number of CPUs that the machine has
getNumProcessors :: IO Int

-- | Returns the number of sparks currently in the local spark pool
numSparks :: IO Int
childHandler :: SomeException -> IO ()

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()
par :: a -> b -> b
pseq :: a -> b -> b

-- | Internal function used by the RTS to run sparks.
runSparks :: IO ()

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | <a>labelThread</a> stores a string as identifier for this thread if
--   you built a RTS with debugging support. This identifier will be used
--   in the debugging output to make distinction of different threads
--   easier (otherwise you only have the thread state object's address in
--   the heap).
--   
--   Other applications like the graphical Concurrent Haskell Debugger
--   (<a>http://www.informatik.uni-kiel.de/~fhu/chd/</a>) may choose to
--   overload <a>labelThread</a> for their purposes as well.
labelThread :: ThreadId -> String -> IO ()

-- | make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)

-- | The current status of a thread
data ThreadStatus

-- | the thread is currently runnable or running
ThreadRunning :: ThreadStatus

-- | the thread has finished
ThreadFinished :: ThreadStatus

-- | the thread is blocked on some resource
ThreadBlocked :: BlockReason -> ThreadStatus

-- | the thread received an uncaught exception
ThreadDied :: ThreadStatus
data BlockReason

-- | blocked on <a>MVar</a>
BlockedOnMVar :: BlockReason

-- | blocked on a computation in progress by another thread
BlockedOnBlackHole :: BlockReason

-- | blocked in <a>throwTo</a>
BlockedOnException :: BlockReason

-- | blocked in <a>retry</a> in an STM transaction
BlockedOnSTM :: BlockReason

-- | currently in a foreign call
BlockedOnForeignCall :: BlockReason

-- | blocked on some other resource. Without <tt>-threaded</tt>, I/O and
--   <tt>threadDelay</tt> show up as <a>BlockedOnOther</a>, with
--   <tt>-threaded</tt> they show up as <a>BlockedOnMVar</a>.
BlockedOnOther :: BlockReason
threadStatus :: ThreadId -> IO ThreadStatus

-- | returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
threadCapability :: ThreadId -> IO (Int, Bool)

-- | Every thread has an allocation counter that tracks how much memory has
--   been allocated by the thread. The counter is initialized to zero, and
--   <a>setAllocationCounter</a> sets the current value. The allocation
--   counter counts *down*, so in the absence of a call to
--   <a>setAllocationCounter</a> its value is the negation of the number of
--   bytes of memory allocated by the thread.
--   
--   There are two things that you can do with this counter:
--   
--   <ul>
--   <li>Use it as a simple profiling mechanism, with
--   <a>getAllocationCounter</a>.</li>
--   <li>Use it as a resource limit. See <a>enableAllocationLimit</a>.</li>
--   </ul>
--   
--   Allocation accounting is accurate only to about 4Kbytes.
setAllocationCounter :: Int64 -> IO ()

-- | Return the current value of the allocation counter for the current
--   thread.
getAllocationCounter :: IO Int64

-- | Enables the allocation counter to be treated as a limit for the
--   current thread. When the allocation limit is enabled, if the
--   allocation counter counts down below zero, the thread will be sent the
--   <a>AllocationLimitExceeded</a> asynchronous exception. When this
--   happens, the counter is reinitialised (by default to 100K, but tunable
--   with the <tt>+RTS -xq</tt> option) so that it can handle the exception
--   and perform any necessary clean up. If it exhausts this additional
--   allowance, another <a>AllocationLimitExceeded</a> exception is sent,
--   and so forth.
--   
--   Note that memory allocation is unrelated to <i>live memory</i>, also
--   known as <i>heap residency</i>. A thread can allocate a large amount
--   of memory and retain anything between none and all of it. It is better
--   to think of the allocation limit as a limit on <i>CPU time</i>, rather
--   than a limit on memory.
--   
--   Compared to using timeouts, allocation limits don't count time spent
--   blocked or in foreign calls.
enableAllocationLimit :: IO ()

-- | Disable allocation limit processing for the current thread.
disableAllocationLimit :: IO ()

-- | A monad supporting atomic memory transactions.
newtype STM a
STM :: (State# RealWorld -> (# State# RealWorld, a #)) -> STM a

-- | Perform a series of STM actions atomically.
--   
--   You cannot use <a>atomically</a> inside an <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>. Any attempt to do so will result in a
--   runtime error. (Reason: allowing this would effectively allow a
--   transaction inside a transaction, depending on exactly when the thunk
--   is evaluated.)
--   
--   However, see <a>newTVarIO</a>, which can be called inside
--   <a>unsafePerformIO</a>, and which allows top-level TVars to be
--   allocated.
atomically :: STM a -> IO a

-- | Retry execution of the current memory transaction because it has seen
--   values in TVars which mean that it should not continue (e.g. the TVars
--   represent a shared buffer that is now empty). The implementation may
--   block the thread until one of the TVars that it has read from has been
--   udpated. (GHC only)
retry :: STM a

-- | Compose two alternative STM actions (GHC only). If the first action
--   completes without retrying then it forms the result of the orElse.
--   Otherwise, if the first action retries, then the second action is
--   tried in its place. If both actions retry then the orElse as a whole
--   retries.
orElse :: STM a -> STM a -> STM a

-- | A variant of <a>throw</a> that can only be used within the <a>STM</a>
--   monad.
--   
--   Throwing an exception in <tt>STM</tt> aborts the transaction and
--   propagates the exception.
--   
--   Although <a>throwSTM</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e    `seq` x  ===&gt; throw e
--   throwSTM e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwSTM</a> will only cause
--   an exception to be raised when it is used within the <a>STM</a> monad.
--   The <a>throwSTM</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>STM</a> monad because
--   it guarantees ordering with respect to other <a>STM</a> operations,
--   whereas <a>throw</a> does not.
throwSTM :: Exception e => e -> STM a

-- | Exception handling within STM actions.
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a

-- | alwaysSucceeds adds a new invariant that must be true when passed to
--   alwaysSucceeds, at the end of the current transaction, and at the end
--   of every subsequent transaction. If it fails at any of those points
--   then the transaction violating it is aborted and the exception raised
--   by the invariant is propagated.
alwaysSucceeds :: STM a -> STM ()

-- | always is a variant of alwaysSucceeds in which the invariant is
--   expressed as an STM Bool action that must return True. Returning False
--   or raising an exception are both treated as invariant failures.
always :: STM Bool -> STM ()

-- | Shared memory locations that support atomic memory transactions.
data TVar a
TVar :: (TVar# RealWorld a) -> TVar a

-- | Create a new TVar holding a value supplied
newTVar :: a -> STM (TVar a)

-- | <tt>IO</tt> version of <a>newTVar</a>. This is useful for creating
--   top-level <a>TVar</a>s using <a>unsafePerformIO</a>, because using
--   <a>atomically</a> inside <a>unsafePerformIO</a> isn't possible.
newTVarIO :: a -> IO (TVar a)

-- | Return the current value stored in a TVar
readTVar :: TVar a -> STM a

-- | Return the current value stored in a TVar. This is equivalent to
--   
--   <pre>
--   readTVarIO = atomically . readTVar
--   </pre>
--   
--   but works much faster, because it doesn't perform a complete
--   transaction, it just reads the current value of the <a>TVar</a>.
readTVarIO :: TVar a -> IO a

-- | Write the supplied value into a TVar
writeTVar :: TVar a -> a -> STM ()

-- | Unsafely performs IO in the STM monad. Beware: this is a highly
--   dangerous thing to do.
--   
--   <ul>
--   <li>The STM implementation will often run transactions multiple times,
--   so you need to be prepared for this if your IO has any side
--   effects.</li>
--   <li>The STM implementation will abort transactions that are known to
--   be invalid and need to be restarted. This may happen in the middle of
--   <a>unsafeIOToSTM</a>, so make sure you don't acquire any resources
--   that need releasing (exception handlers are ignored when aborting the
--   transaction). That includes doing any IO using Handles, for example.
--   Getting this wrong will probably lead to random deadlocks.</li>
--   <li>The transaction may have seen an inconsistent view of memory when
--   the IO runs. Invariants that you expect to be true throughout your
--   program may not be true inside a transaction, due to the way
--   transactions are implemented. Normally this wouldn't be visible to the
--   programmer, but using <a>unsafeIOToSTM</a> can expose it.</li>
--   </ul>
unsafeIOToSTM :: IO a -> STM a
withMVar :: MVar a -> (a -> IO b) -> IO b
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
setUncaughtExceptionHandler :: (SomeException -> IO ()) -> IO ()
getUncaughtExceptionHandler :: IO (SomeException -> IO ())
reportError :: SomeException -> IO ()
reportStackOverflow :: IO ()
sharedCAF :: a -> (Ptr a -> IO (Ptr a)) -> IO a
instance GHC.Show.Show GHC.Conc.Sync.ThreadStatus
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadStatus
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadStatus
instance GHC.Show.Show GHC.Conc.Sync.BlockReason
instance GHC.Classes.Ord GHC.Conc.Sync.BlockReason
instance GHC.Classes.Eq GHC.Conc.Sync.BlockReason
instance GHC.Show.Show GHC.Conc.Sync.ThreadId
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadId
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadId
instance GHC.Base.Functor GHC.Conc.Sync.STM
instance GHC.Base.Applicative GHC.Conc.Sync.STM
instance GHC.Base.Monad GHC.Conc.Sync.STM
instance GHC.Base.Alternative GHC.Conc.Sync.STM
instance GHC.Base.MonadPlus GHC.Conc.Sync.STM
instance GHC.Classes.Eq (GHC.Conc.Sync.TVar a)


-- | Extensible exceptions, except for multiple handlers.
module Control.Exception.Base

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e where toException = SomeException fromException (SomeException e) = cast e displayException = show
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException

-- | Exceptions generated by array operations
data ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | <a>assert</a> was applied to <a>False</a>.
data AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Asynchronous exceptions.
data AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception.</li>
--   <li>GHC currently does not throw <a>HeapOverflow</a> exceptions.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
data NonTermination
NonTermination :: NonTermination

-- | Thrown when the program attempts to call <tt>atomically</tt>, from the
--   <tt>stm</tt> package, inside another call to <tt>atomically</tt>.
data NestedAtomically
NestedAtomically :: NestedAtomically

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock
Deadlock :: Deadlock

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called. The
--   <tt>String</tt> gives information about which method it was.
data NoMethodError
NoMethodError :: String -> NoMethodError

-- | A pattern match failed. The <tt>String</tt> gives information about
--   the source location of the pattern.
data PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail

-- | An uninitialised record field was used. The <tt>String</tt> gives
--   information about the source location where the record was
--   constructed.
data RecConError
RecConError :: String -> RecConError

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record selector.
data RecSelError
RecSelError :: String -> RecSelError

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record update.
data RecUpdError
RecUpdError :: String -> RecUpdError

-- | This is thrown when the user calls <a>error</a>. The <tt>String</tt>
--   is the argument given to <a>error</a>.
newtype ErrorCall
ErrorCall :: String -> ErrorCall

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` x  ===&gt; throw e
--   throwIO e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other <a>IO</a> operations,
--   whereas <a>throw</a> does not.
throwIO :: Exception e => e -> IO a

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
throw :: Exception e => e -> a

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propogated further up. If
--   you call it again, you might get a the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | The function <a>catchJust</a> is like <a>catch</a>, but it takes an
--   extra argument which is an <i>exception predicate</i>, a function
--   which selects which type of exceptions we're interested in.
--   
--   <pre>
--   catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
--             (readFile f)
--             (\_ -&gt; do hPutStrLn stderr ("No such file: " ++ show f)
--                       return "")
--   </pre>
--   
--   Any other exceptions which are not matched by the predicate are
--   re-raised, and may be caught by an enclosing <a>catch</a>,
--   <a>catchJust</a>, etc.
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: Exception e => (e -> IO a) -> IO a -> IO a

-- | A version of <a>catchJust</a> with the arguments swapped around (see
--   <a>handle</a>).
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised than it will be propogated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught (c.f. <a>catchJust</a>). If the exception
--   does not match the predicate, it is re-thrown.
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the computation.
onException :: IO a -> IO b -> IO a

-- | Forces its argument to be evaluated to weak head normal form when the
--   resultant <a>IO</a> action is executed. It can be used to order
--   evaluation with respect to other <a>IO</a> operations; its semantics
--   are given by
--   
--   <pre>
--   evaluate x `seq` y    ==&gt;  y
--   evaluate x `catch` f  ==&gt;  (return $! x) `catch` f
--   evaluate x &gt;&gt;= f      ==&gt;  (return $! x) &gt;&gt;= f
--   </pre>
--   
--   <i>Note:</i> the first equation implies that <tt>(evaluate x)</tt> is
--   <i>not</i> the same as <tt>(return $! x)</tt>. A correct definition is
--   
--   <pre>
--   evaluate x = (return $! x) &gt;&gt;= return
--   </pre>
evaluate :: a -> IO a

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a a new thread in an unmasked state use
--   <a>forkIOUnmasked</a>.
mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <tt>AssertionFailed</tt> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: IO a -> IO b -> IO c -> IO c

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: IO a -> IO b -> IO a
recSelError :: Addr# -> a
recConError :: Addr# -> a
irrefutPatError :: Addr# -> a
runtimeError :: Addr# -> a
nonExhaustiveGuardsError :: Addr# -> a
patError :: Addr# -> a
noMethodBindingError :: Addr# -> a
absentError :: Addr# -> a
nonTermination :: SomeException
nestedAtomically :: SomeException
instance GHC.Show.Show Control.Exception.Base.PatternMatchFail
instance GHC.Exception.Exception Control.Exception.Base.PatternMatchFail
instance GHC.Show.Show Control.Exception.Base.RecSelError
instance GHC.Exception.Exception Control.Exception.Base.RecSelError
instance GHC.Show.Show Control.Exception.Base.RecConError
instance GHC.Exception.Exception Control.Exception.Base.RecConError
instance GHC.Show.Show Control.Exception.Base.RecUpdError
instance GHC.Exception.Exception Control.Exception.Base.RecUpdError
instance GHC.Show.Show Control.Exception.Base.NoMethodError
instance GHC.Exception.Exception Control.Exception.Base.NoMethodError
instance GHC.Show.Show Control.Exception.Base.NonTermination
instance GHC.Exception.Exception Control.Exception.Base.NonTermination
instance GHC.Show.Show Control.Exception.Base.NestedAtomically
instance GHC.Exception.Exception Control.Exception.Base.NestedAtomically


-- | An <tt><a>MVar</a> t</tt> is mutable location that is either empty or
--   contains a value of type <tt>t</tt>. It has two fundamental
--   operations: <a>putMVar</a> which fills an <a>MVar</a> if it is empty
--   and blocks otherwise, and <a>takeMVar</a> which empties an <a>MVar</a>
--   if it is full and blocks otherwise. They can be used in multiple
--   different ways:
--   
--   <ol>
--   <li>As synchronized mutable variables,</li>
--   <li>As channels, with <a>takeMVar</a> and <a>putMVar</a> as receive
--   and send, and</li>
--   <li>As a binary semaphore <tt><a>MVar</a> ()</tt>, with
--   <a>takeMVar</a> and <a>putMVar</a> as wait and signal.</li>
--   </ol>
--   
--   They were introduced in the paper <a>"Concurrent Haskell"</a> by Simon
--   Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of
--   their implementation have since then changed (in particular, a put on
--   a full <a>MVar</a> used to error, but now merely blocks.)
--   
--   <h3>Applicability</h3>
--   
--   <a>MVar</a>s offer more flexibility than <tt>IORef</tt>s, but less
--   flexibility than <tt>STM</tt>. They are appropriate for building
--   synchronization primitives and performing simple interthread
--   communication; however they are very simple and susceptible to race
--   conditions, deadlocks or uncaught exceptions. Do not use them if you
--   need perform larger atomic operations such as reading from multiple
--   variables: use <tt>STM</tt> instead.
--   
--   In particular, the "bigger" functions in this module (<a>readMVar</a>,
--   <a>swapMVar</a>, <a>withMVar</a>, <a>modifyMVar_</a> and
--   <a>modifyMVar</a>) are simply the composition of a <a>takeMVar</a>
--   followed by a <a>putMVar</a> with exception safety. These only have
--   atomicity guarantees if all other threads perform a <a>takeMVar</a>
--   before a <a>putMVar</a> as well; otherwise, they may block.
--   
--   <h3>Fairness</h3>
--   
--   No thread can be blocked indefinitely on an <a>MVar</a> unless another
--   thread holds that <a>MVar</a> indefinitely. One usual implementation
--   of this fairness guarantee is that threads blocked on an <a>MVar</a>
--   are served in a first-in-first-out fashion, but this is not guaranteed
--   in the semantics.
--   
--   <h3>Gotchas</h3>
--   
--   Like many other Haskell data structures, <a>MVar</a>s are lazy. This
--   means that if you place an expensive unevaluated thunk inside an
--   <a>MVar</a>, it will be evaluated by the thread that consumes it, not
--   the thread that produced it. Be sure to <a>evaluate</a> values to be
--   placed in an <a>MVar</a> to the appropriate normal form, or utilize a
--   strict MVar provided by the strict-concurrency package.
--   
--   <h3>Ordering</h3>
--   
--   <a>MVar</a> operations are always observed to take place in the order
--   they are written in the program, regardless of the memory model of the
--   underlying machine. This is in contrast to <tt>IORef</tt> operations
--   which may appear out-of-order to another thread in some cases.
--   
--   <h3>Example</h3>
--   
--   Consider the following concurrent data structure, a skip channel. This
--   is a channel for an intermittent source of high bandwidth information
--   (for example, mouse movement events.) Writing to the channel never
--   blocks, and reading from the channel only returns the most recent
--   value, or blocks if there are no new values. Multiple readers are
--   supported with a <tt>dupSkipChan</tt> operation.
--   
--   A skip channel is a pair of <a>MVar</a>s. The first <a>MVar</a>
--   contains the current value, and a list of semaphores that need to be
--   notified when it changes. The second <a>MVar</a> is a semaphore for
--   this particular reader: it is full if there is a value in the channel
--   that this reader has not read yet, and empty otherwise.
--   
--   <pre>
--   data SkipChan a = SkipChan (MVar (a, [MVar ()])) (MVar ())
--   
--   newSkipChan :: IO (SkipChan a)
--   newSkipChan = do
--       sem &lt;- newEmptyMVar
--       main &lt;- newMVar (undefined, [sem])
--       return (SkipChan main sem)
--   
--   putSkipChan :: SkipChan a -&gt; a -&gt; IO ()
--   putSkipChan (SkipChan main _) v = do
--       (_, sems) &lt;- takeMVar main
--       putMVar main (v, [])
--       mapM_ (sem -&gt; putMVar sem ()) sems
--   
--   getSkipChan :: SkipChan a -&gt; IO a
--   getSkipChan (SkipChan main sem) = do
--       takeMVar sem
--       (v, sems) &lt;- takeMVar main
--       putMVar main (v, sem:sems)
--       return v
--   
--   dupSkipChan :: SkipChan a -&gt; IO (SkipChan a)
--   dupSkipChan (SkipChan main _) = do
--       sem &lt;- newEmptyMVar
--       (v, sems) &lt;- takeMVar main
--       putMVar main (v, sem:sems)
--       return (SkipChan main sem)
--   </pre>
--   
--   This example was adapted from the original Concurrent Haskell paper.
--   For more examples of <a>MVar</a>s being used to build higher-level
--   synchronization primitives, see <a>Chan</a> and <a>QSem</a>.
module Control.Concurrent.MVar

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a a box, which may be empty or full.
data MVar a

-- | Create an <a>MVar</a> which is initially empty.
newEmptyMVar :: IO (MVar a)

-- | Create an <a>MVar</a> which contains the supplied value.
newMVar :: a -> IO (MVar a)

-- | Return the contents of the <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>takeMVar</a> will wait until it is full. After a
--   <a>takeMVar</a>, the <a>MVar</a> is left empty.
--   
--   There are two further important properties of <a>takeMVar</a>:
--   
--   <ul>
--   <li><a>takeMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>takeMVar</a>, and the <a>MVar</a> becomes full,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>takeMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
takeMVar :: MVar a -> IO a

-- | Put a value into an <a>MVar</a>. If the <a>MVar</a> is currently full,
--   <a>putMVar</a> will wait until it becomes empty.
--   
--   There are two further important properties of <a>putMVar</a>:
--   
--   <ul>
--   <li><a>putMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>putMVar</a>, and the <a>MVar</a> becomes empty,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>putMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
putMVar :: MVar a -> a -> IO ()

-- | Atomically read the contents of an <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>readMVar</a> will wait until its full.
--   <a>readMVar</a> is guaranteed to receive the next <a>putMVar</a>.
--   
--   <a>readMVar</a> is multiple-wakeup, so when multiple readers are
--   blocked on an <a>MVar</a>, all of them are woken up at the same time.
--   
--   <i>Compatibility note:</i> Prior to base 4.7, <a>readMVar</a> was a
--   combination of <a>takeMVar</a> and <a>putMVar</a>. This mean that in
--   the presence of other threads attempting to <a>putMVar</a>,
--   <a>readMVar</a> could block. Furthermore, <a>readMVar</a> would not
--   receive the next <a>putMVar</a> if there was already a pending thread
--   blocked on <a>takeMVar</a>. The old behavior can be recovered by
--   implementing 'readMVar as follows:
--   
--   <pre>
--   readMVar :: MVar a -&gt; IO a
--   readMVar m =
--     mask_ $ do
--       a &lt;- takeMVar m
--       putMVar m a
--       return a
--   </pre>
readMVar :: MVar a -> IO a

-- | Take a value from an <a>MVar</a>, put a new value into the <a>MVar</a>
--   and return the value taken. This function is atomic only if there are
--   no other producers for this <a>MVar</a>.
swapMVar :: MVar a -> a -> IO a

-- | A non-blocking version of <a>takeMVar</a>. The <a>tryTakeMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>. After <a>tryTakeMVar</a>, the <a>MVar</a> is left
--   empty.
tryTakeMVar :: MVar a -> IO (Maybe a)

-- | A non-blocking version of <a>putMVar</a>. The <a>tryPutMVar</a>
--   function attempts to put the value <tt>a</tt> into the <a>MVar</a>,
--   returning <a>True</a> if it was successful, or <a>False</a> otherwise.
tryPutMVar :: MVar a -> a -> IO Bool

-- | Check whether a given <a>MVar</a> is empty.
--   
--   Notice that the boolean value returned is just a snapshot of the state
--   of the MVar. By the time you get to react on its result, the MVar may
--   have been filled (or emptied) - so be extremely careful when using
--   this operation. Use <a>tryTakeMVar</a> instead if possible.
isEmptyMVar :: MVar a -> IO Bool

-- | <a>withMVar</a> is an exception-safe wrapper for operating on the
--   contents of an <a>MVar</a>. This operation is exception-safe: it will
--   replace the original contents of the <a>MVar</a> if an exception is
--   raised (see <a>Control.Exception</a>). However, it is only atomic if
--   there are no other producers for this <a>MVar</a>.
withMVar :: MVar a -> (a -> IO b) -> IO b

-- | Like <a>withMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
withMVarMasked :: MVar a -> (a -> IO b) -> IO b

-- | An exception-safe wrapper for modifying the contents of an
--   <a>MVar</a>. Like <a>withMVar</a>, <a>modifyMVar</a> will replace the
--   original contents of the <a>MVar</a> if an exception is raised during
--   the operation. This function is only atomic if there are no other
--   producers for this <a>MVar</a>.
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()

-- | A slight variation on <a>modifyMVar_</a> that allows a value to be
--   returned (<tt>b</tt>) in addition to the modified value of the
--   <a>MVar</a>.
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b

-- | Like <a>modifyMVar_</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
modifyMVarMasked_ :: MVar a -> (a -> IO a) -> IO ()

-- | Like <a>modifyMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
modifyMVarMasked :: MVar a -> (a -> IO (a, b)) -> IO b

-- | A non-blocking version of <a>readMVar</a>. The <a>tryReadMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>.
tryReadMVar :: MVar a -> IO (Maybe a)

-- | Make a <a>Weak</a> pointer to an <a>MVar</a>, using the second
--   argument as a finalizer to run when <a>MVar</a> is garbage-collected
mkWeakMVar :: MVar a -> IO () -> IO (Weak (MVar a))

-- | <i>Deprecated: use <a>mkWeakMVar</a> instead</i>
addMVarFinalizer :: MVar a -> IO () -> IO ()


-- | This module provides support for raising and catching both built-in
--   and user-defined exceptions.
--   
--   In addition to exceptions thrown by <a>IO</a> operations, exceptions
--   may be thrown by pure code (imprecise exceptions) or by external
--   events (asynchronous exceptions), but may only be caught in the
--   <a>IO</a> monad. For more details, see:
--   
--   <ul>
--   <li><i>A semantics for imprecise exceptions</i>, by Simon Peyton
--   Jones, Alastair Reid, Tony Hoare, Simon Marlow, Fergus Henderson, in
--   <i>PLDI'99</i>.</li>
--   <li><i>Asynchronous exceptions in Haskell</i>, by Simon Marlow, Simon
--   Peyton Jones, Andy Moran and John Reppy, in <i>PLDI'01</i>.</li>
--   <li><i>An Extensible Dynamically-Typed Hierarchy of Exceptions</i>, by
--   Simon Marlow, in <i>Haskell '06</i>.</li>
--   </ul>
module Control.Exception

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e where toException = SomeException fromException (SomeException e) = cast e displayException = show
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException

-- | Exceptions generated by array operations
data ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | <a>assert</a> was applied to <a>False</a>.
data AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Asynchronous exceptions.
data AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception.</li>
--   <li>GHC currently does not throw <a>HeapOverflow</a> exceptions.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
data NonTermination
NonTermination :: NonTermination

-- | Thrown when the program attempts to call <tt>atomically</tt>, from the
--   <tt>stm</tt> package, inside another call to <tt>atomically</tt>.
data NestedAtomically
NestedAtomically :: NestedAtomically

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock
Deadlock :: Deadlock

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called. The
--   <tt>String</tt> gives information about which method it was.
data NoMethodError
NoMethodError :: String -> NoMethodError

-- | A pattern match failed. The <tt>String</tt> gives information about
--   the source location of the pattern.
data PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail

-- | An uninitialised record field was used. The <tt>String</tt> gives
--   information about the source location where the record was
--   constructed.
data RecConError
RecConError :: String -> RecConError

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record selector.
data RecSelError
RecSelError :: String -> RecSelError

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record update.
data RecUpdError
RecUpdError :: String -> RecUpdError

-- | This is thrown when the user calls <a>error</a>. The <tt>String</tt>
--   is the argument given to <a>error</a>.
newtype ErrorCall
ErrorCall :: String -> ErrorCall

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
throw :: Exception e => e -> a

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` x  ===&gt; throw e
--   throwIO e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other <a>IO</a> operations,
--   whereas <a>throw</a> does not.
throwIO :: Exception e => e -> IO a

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propogated further up. If
--   you call it again, you might get a the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | Sometimes you want to catch two different sorts of exception. You
--   could do something like
--   
--   <pre>
--   f = expr `catch` \ (ex :: ArithException) -&gt; handleArith ex
--            `catch` \ (ex :: IOException)    -&gt; handleIO    ex
--   </pre>
--   
--   However, there are a couple of problems with this approach. The first
--   is that having two exception handlers is inefficient. However, the
--   more serious issue is that the second exception handler will catch
--   exceptions in the first, e.g. in the example above, if
--   <tt>handleArith</tt> throws an <tt>IOException</tt> then the second
--   exception handler will catch it.
--   
--   Instead, we provide a function <a>catches</a>, which would be used
--   thus:
--   
--   <pre>
--   f = expr `catches` [Handler (\ (ex :: ArithException) -&gt; handleArith ex),
--                       Handler (\ (ex :: IOException)    -&gt; handleIO    ex)]
--   </pre>
catches :: IO a -> [Handler a] -> IO a

-- | You need this when using <a>catches</a>.
data Handler a
Handler :: (e -> IO a) -> Handler a

-- | The function <a>catchJust</a> is like <a>catch</a>, but it takes an
--   extra argument which is an <i>exception predicate</i>, a function
--   which selects which type of exceptions we're interested in.
--   
--   <pre>
--   catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
--             (readFile f)
--             (\_ -&gt; do hPutStrLn stderr ("No such file: " ++ show f)
--                       return "")
--   </pre>
--   
--   Any other exceptions which are not matched by the predicate are
--   re-raised, and may be caught by an enclosing <a>catch</a>,
--   <a>catchJust</a>, etc.
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: Exception e => (e -> IO a) -> IO a -> IO a

-- | A version of <a>catchJust</a> with the arguments swapped around (see
--   <a>handle</a>).
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised than it will be propogated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught (c.f. <a>catchJust</a>). If the exception
--   does not match the predicate, it is re-thrown.
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)

-- | Forces its argument to be evaluated to weak head normal form when the
--   resultant <a>IO</a> action is executed. It can be used to order
--   evaluation with respect to other <a>IO</a> operations; its semantics
--   are given by
--   
--   <pre>
--   evaluate x `seq` y    ==&gt;  y
--   evaluate x `catch` f  ==&gt;  (return $! x) `catch` f
--   evaluate x &gt;&gt;= f      ==&gt;  (return $! x) &gt;&gt;= f
--   </pre>
--   
--   <i>Note:</i> the first equation implies that <tt>(evaluate x)</tt> is
--   <i>not</i> the same as <tt>(return $! x)</tt>. A correct definition is
--   
--   <pre>
--   evaluate x = (return $! x) &gt;&gt;= return
--   </pre>
evaluate :: a -> IO a

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a a new thread in an unmasked state use
--   <a>forkIOUnmasked</a>.
mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState

-- | When invoked inside <a>mask</a>, this function allows a masked
--   asynchronous exception to be raised, if one exists. It is equivalent
--   to performing an interruptible operation (see ), but does not involve
--   any actual blocking.
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
allowInterrupt :: IO ()

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <tt>AssertionFailed</tt> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: IO a -> IO b -> IO c -> IO c

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: IO a -> IO b -> IO a

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the computation.
onException :: IO a -> IO b -> IO a
instance GHC.Base.Functor Control.Exception.Handler


-- | "Unsafe" IO operations.
module System.IO.Unsafe

-- | This is the "back door" into the <a>IO</a> monad, allowing <a>IO</a>
--   computation to be performed at any time. For this to be safe, the
--   <a>IO</a> computation should be free of side effects and independent
--   of its environment.
--   
--   If the I/O computation wrapped in <a>unsafePerformIO</a> performs side
--   effects, then the relative order in which those side effects take
--   place (relative to the main I/O trunk, or other calls to
--   <a>unsafePerformIO</a>) is indeterminate. Furthermore, when using
--   <a>unsafePerformIO</a> to cause side-effects, you should take the
--   following precautions to ensure the side effects are performed as many
--   times as you expect them to be. Note that these precautions are
--   necessary for GHC, but may not be sufficient, and other compilers may
--   require different precautions:
--   
--   <ul>
--   <li>Use <tt>{-# NOINLINE foo #-}</tt> as a pragma on any function
--   <tt>foo</tt> that calls <a>unsafePerformIO</a>. If the call is
--   inlined, the I/O may be performed more than once.</li>
--   <li>Use the compiler flag <tt>-fno-cse</tt> to prevent common
--   sub-expression elimination being performed on the module, which might
--   combine two side effects that were meant to be separate. A good
--   example is using multiple global variables (like <tt>test</tt> in the
--   example below).</li>
--   <li>Make sure that the either you switch off let-floating
--   (<tt>-fno-full-laziness</tt>), or that the call to
--   <a>unsafePerformIO</a> cannot float outside a lambda. For example, if
--   you say: <tt> f x = unsafePerformIO (newIORef []) </tt> you may get
--   only one reference cell shared between all calls to <tt>f</tt>. Better
--   would be <tt> f x = unsafePerformIO (newIORef [x]) </tt> because now
--   it can't float outside the lambda.</li>
--   </ul>
--   
--   It is less well known that <a>unsafePerformIO</a> is not type safe.
--   For example:
--   
--   <pre>
--   test :: IORef [a]
--   test = unsafePerformIO $ newIORef []
--   
--   main = do
--           writeIORef test [42]
--           bang &lt;- readIORef test
--           print (bang :: [Char])
--   </pre>
--   
--   This program will core dump. This problem with polymorphic references
--   is well known in the ML community, and does not arise with normal
--   monadic use of references. There is no easy way to make it impossible
--   once you use <a>unsafePerformIO</a>. Indeed, it is possible to write
--   <tt>coerce :: a -&gt; b</tt> with the help of <a>unsafePerformIO</a>.
--   So be careful!
unsafePerformIO :: IO a -> a

-- | This version of <a>unsafePerformIO</a> is more efficient because it
--   omits the check that the IO is only being performed by a single
--   thread. Hence, when you use <a>unsafeDupablePerformIO</a>, there is a
--   possibility that the IO action may be performed multiple times (on a
--   multiprocessor), and you should therefore ensure that it gives the
--   same results each time. It may even happen that one of the duplicated
--   IO actions is only run partially, and then interrupted in the middle
--   without an exception being raised. Therefore, functions like
--   <a>bracket</a> cannot be used safely within
--   <a>unsafeDupablePerformIO</a>.
unsafeDupablePerformIO :: IO a -> a

-- | <a>unsafeInterleaveIO</a> allows <a>IO</a> computation to be deferred
--   lazily. When passed a value of type <tt>IO a</tt>, the <a>IO</a> will
--   only be performed when the value of the <tt>a</tt> is demanded. This
--   is used to implement lazy file reading, see <a>hGetContents</a>.
unsafeInterleaveIO :: IO a -> IO a

-- | A slightly faster version of <a>fixIO</a> that may not be safe to use
--   with multiple threads. The unsafety arises when used like this:
--   
--   <pre>
--   unsafeFixIO $ \r -&gt; do
--      forkIO (print r)
--      return (...)
--   </pre>
--   
--   In this case, the child thread will receive a <tt>NonTermination</tt>
--   exception instead of waiting for the value of <tt>r</tt> to be
--   computed.
unsafeFixIO :: (a -> IO a) -> IO a

module GHC.Conc.Signal
type Signal = CInt
type HandlerFun = ForeignPtr Word8 -> IO ()
setHandler :: Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))
runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
runHandlersPtr :: Ptr Word8 -> Signal -> IO ()


-- | Single-byte encodings that map directly to Unicode code points.
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.Latin1
latin1 :: TextEncoding

mkLatin1 :: CodingFailureMode -> TextEncoding
latin1_checked :: TextEncoding

mkLatin1_checked :: CodingFailureMode -> TextEncoding

ascii :: TextEncoding

mkAscii :: CodingFailureMode -> TextEncoding
latin1_decode :: DecodeBuffer
ascii_decode :: DecodeBuffer
latin1_encode :: EncodeBuffer
latin1_checked_encode :: EncodeBuffer
ascii_encode :: EncodeBuffer


-- | UTF-16 Codecs for the IO library
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.UTF16
utf16 :: TextEncoding

mkUTF16 :: CodingFailureMode -> TextEncoding
utf16_decode :: IORef (Maybe DecodeBuffer) -> DecodeBuffer
utf16_encode :: IORef Bool -> EncodeBuffer
utf16be :: TextEncoding

mkUTF16be :: CodingFailureMode -> TextEncoding
utf16be_decode :: DecodeBuffer
utf16be_encode :: EncodeBuffer
utf16le :: TextEncoding

mkUTF16le :: CodingFailureMode -> TextEncoding
utf16le_decode :: DecodeBuffer
utf16le_encode :: EncodeBuffer


-- | UTF-32 Codecs for the IO library
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.UTF32
utf32 :: TextEncoding

mkUTF32 :: CodingFailureMode -> TextEncoding
utf32_decode :: IORef (Maybe DecodeBuffer) -> DecodeBuffer
utf32_encode :: IORef Bool -> EncodeBuffer
utf32be :: TextEncoding

mkUTF32be :: CodingFailureMode -> TextEncoding
utf32be_decode :: DecodeBuffer
utf32be_encode :: EncodeBuffer
utf32le :: TextEncoding

mkUTF32le :: CodingFailureMode -> TextEncoding
utf32le_decode :: DecodeBuffer
utf32le_encode :: EncodeBuffer

module GHC.IO.Encoding.CodePage


-- | Text codecs for I/O
module GHC.IO.Encoding
data BufferCodec from to state
BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | The <tt>encode</tt> function translates elements of the buffer
--   <tt>from</tt> to the buffer <tt>to</tt>. It should translate as many
--   elements as possible given the sizes of the buffers, including
--   translating zero elements if there is either not enough room in
--   <tt>to</tt>, or <tt>from</tt> does not contain a complete multibyte
--   sequence.
--   
--   If multiple CodingProgress returns are possible, OutputUnderflow must
--   be preferred to InvalidSequence. This allows GHC's IO library to
--   assume that if we observe InvalidSequence there is at least a single
--   element available in the output buffer.
--   
--   The fact that as many elements as possible are translated is used by
--   the IO library in order to report translation errors at the point they
--   actually occur, rather than when the buffer is translated.
[encode] :: BufferCodec from to state -> CodeBuffer from to

-- | The <tt>recover</tt> function is used to continue decoding in the
--   presence of invalid or unrepresentable sequences. This includes both
--   those detected by <tt>encode</tt> returning <tt>InvalidSequence</tt>
--   and those that occur because the input byte sequence appears to be
--   truncated.
--   
--   Progress will usually be made by skipping the first element of the
--   <tt>from</tt> buffer. This function should only be called if you are
--   certain that you wish to do this skipping and if the <tt>to</tt>
--   buffer has at least one element of free space. Because this function
--   deals with decoding failure, it assumes that the from buffer has at
--   least one element.
--   
--   <tt>recover</tt> may raise an exception rather than skipping anything.
--   
--   Currently, some implementations of <tt>recover</tt> may mutate the
--   input buffer. In particular, this feature is used to implement
--   transliteration.
[recover] :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)

-- | Resources associated with the encoding may now be released. The
--   <tt>encode</tt> function may not be called again after calling
--   <tt>close</tt>.
[close] :: BufferCodec from to state -> IO ()

-- | Return the current state of the codec.
--   
--   Many codecs are not stateful, and in these case the state can be
--   represented as '()'. Other codecs maintain a state. For example,
--   UTF-16 recognises a BOM (byte-order-mark) character at the beginning
--   of the input, and remembers thereafter whether to use big-endian or
--   little-endian mode. In this case, the state of the codec would include
--   two pieces of information: whether we are at the beginning of the
--   stream (the BOM only occurs at the beginning), and if not, whether to
--   use the big or little-endian encoding.
[getState] :: BufferCodec from to state -> IO state
[setState] :: BufferCodec from to state -> state -> IO ()

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <tt>utf8</tt>.
data TextEncoding
TextEncoding :: String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding

-- | a string that can be passed to <tt>mkTextEncoding</tt> to create an
--   equivalent <a>TextEncoding</a>.
[textEncodingName] :: TextEncoding -> String

-- | Creates a means of decoding bytes into characters: the result must not
--   be shared between several byte sequences or simultaneously across
--   threads
[mkTextDecoder] :: TextEncoding -> IO (TextDecoder dstate)

-- | Creates a means of encode characters into bytes: the result must not
--   be shared between several character sequences or simultaneously across
--   threads
[mkTextEncoder] :: TextEncoding -> IO (TextEncoder estate)
type TextEncoder state = BufferCodec CharBufElem Word8 state
type TextDecoder state = BufferCodec Word8 CharBufElem state

data CodingProgress

-- | Stopped because the input contains insufficient available elements, or
--   all of the input sequence has been sucessfully translated.
InputUnderflow :: CodingProgress

-- | Stopped because the output contains insufficient free elements
OutputUnderflow :: CodingProgress

-- | Stopped because there are sufficient free elements in the output to
--   output at least one encoded ASCII character, but the input contains an
--   invalid or unrepresentable sequence
InvalidSequence :: CodingProgress

-- | The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to
--   the first 256 Unicode code points, and is thus not a complete Unicode
--   encoding. An attempt to write a character greater than '\255' to a
--   <tt>Handle</tt> using the <a>latin1</a> encoding will result in an
--   error.
latin1 :: TextEncoding
latin1_encode :: CharBuffer -> Buffer Word8 -> IO (CharBuffer, Buffer Word8)
latin1_decode :: Buffer Word8 -> CharBuffer -> IO (Buffer Word8, CharBuffer)

-- | The UTF-8 Unicode encoding
utf8 :: TextEncoding

-- | The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte
--   sequence 0xEF 0xBB 0xBF). This encoding behaves like <a>utf8</a>,
--   except that on input, the BOM sequence is ignored at the beginning of
--   the stream, and on output, the BOM sequence is prepended.
--   
--   The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes
--   used to identify the encoding of a file.
utf8_bom :: TextEncoding

-- | The UTF-16 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf16 :: TextEncoding

-- | The UTF-16 Unicode encoding (litte-endian)
utf16le :: TextEncoding

-- | The UTF-16 Unicode encoding (big-endian)
utf16be :: TextEncoding

-- | The UTF-32 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf32 :: TextEncoding

-- | The UTF-32 Unicode encoding (litte-endian)
utf32le :: TextEncoding

-- | The UTF-32 Unicode encoding (big-endian)
utf32be :: TextEncoding

initLocaleEncoding :: TextEncoding

-- | The Unicode encoding of the current locale
getLocaleEncoding :: IO TextEncoding

-- | The Unicode encoding of the current locale, but allowing arbitrary
--   undecodable bytes to be round-tripped through it.
--   
--   This <a>TextEncoding</a> is used to decode and encode command line
--   arguments and environment variables on non-Windows platforms.
--   
--   On Windows, this encoding *should not* be used if possible because the
--   use of code pages is deprecated: Strings should be retrieved via the
--   "wide" W-family of UTF-16 APIs instead
getFileSystemEncoding :: IO TextEncoding

-- | The Unicode encoding of the current locale, but where undecodable
--   bytes are replaced with their closest visual match. Used for the
--   <tt>CString</tt> marshalling functions in <a>Foreign.C.String</a>
getForeignEncoding :: IO TextEncoding

setLocaleEncoding :: TextEncoding -> IO ()

setFileSystemEncoding :: TextEncoding -> IO ()

setForeignEncoding :: TextEncoding -> IO ()

-- | An encoding in which Unicode code points are translated to bytes by
--   taking the code point modulo 256. When decoding, bytes are translated
--   directly into the equivalent code point.
--   
--   This encoding never fails in either direction. However, encoding
--   discards information, so encode followed by decode is not the
--   identity.
char8 :: TextEncoding

-- | Look up the named Unicode encoding. May fail with
--   
--   <ul>
--   <li><tt>isDoesNotExistError</tt> if the encoding is unknown</li>
--   </ul>
--   
--   The set of known encodings is system-dependent, but includes at least:
--   
--   <ul>
--   <li><pre>UTF-8</pre></li>
--   <li><tt>UTF-16</tt>, <tt>UTF-16BE</tt>, <tt>UTF-16LE</tt></li>
--   <li><tt>UTF-32</tt>, <tt>UTF-32BE</tt>, <tt>UTF-32LE</tt></li>
--   </ul>
--   
--   There is additional notation (borrowed from GNU iconv) for specifying
--   how illegal characters are handled:
--   
--   <ul>
--   <li>a suffix of <tt>//IGNORE</tt>, e.g. <tt>UTF-8//IGNORE</tt>, will
--   cause all illegal sequences on input to be ignored, and on output will
--   drop all code points that have no representation in the target
--   encoding.</li>
--   <li>a suffix of <tt>//TRANSLIT</tt> will choose a replacement
--   character for illegal sequences or code points.</li>
--   <li>a suffix of <tt>//ROUNDTRIP</tt> will use a PEP383-style escape
--   mechanism to represent any invalid bytes in the input as Unicode
--   codepoints (specifically, as lone surrogates, which are normally
--   invalid in UTF-32). Upon output, these special codepoints are detected
--   and turned back into the corresponding original byte.</li>
--   </ul>
--   
--   In theory, this mechanism allows arbitrary data to be roundtripped via
--   a <a>String</a> with no loss of data. In practice, there are two
--   limitations to be aware of:
--   
--   <ol>
--   <li>This only stands a chance of working for an encoding which is an
--   ASCII superset, as for security reasons we refuse to escape any bytes
--   smaller than 128. Many encodings of interest are ASCII supersets (in
--   particular, you can assume that the locale encoding is an ASCII
--   superset) but many (such as UTF-16) are not.</li>
--   <li>If the underlying encoding is not itself roundtrippable, this
--   mechanism can fail. Roundtrippable encodings are those which have an
--   injective mapping into Unicode. Almost all encodings meet this
--   criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain
--   several different encodings of the same Unicode codepoint.</li>
--   </ol>
--   
--   On Windows, you can access supported code pages with the prefix
--   <tt>CP</tt>; for example, <tt>"CP1250"</tt>.
mkTextEncoding :: String -> IO TextEncoding

module GHC.Environment
getFullArgs :: IO [String]


-- | Standard IO Errors.
module System.IO.Error

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Control.Exception.Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Construct an <a>IOError</a> value with a string describing the error.
--   The <a>fail</a> method of the <a>IO</a> instance of the <a>Monad</a>
--   class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | Construct an <a>IOError</a> of the given type where the second
--   argument describes the error location and the third and fourth
--   argument contain the file handle and file path of the file involved in
--   the error if applicable.
mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError

-- | Adds a location description and maybe a file path and file handle to
--   an <a>IOError</a>. If any of the file handle or file path is not given
--   the corresponding value in the <a>IOError</a> remains unaltered.
annotateIOError :: IOError -> String -> Maybe Handle -> Maybe FilePath -> IOError

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments already exists.
isAlreadyExistsError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments does not exist.
isDoesNotExistError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments is a single-use resource, which is already being used
--   (for example, opening the same file twice for writing might give this
--   error).
isAlreadyInUseError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   device is full.
isFullError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the end
--   of file has been reached.
isEOFError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   operation was not possible. Any computation which returns an <a>IO</a>
--   result may fail with <a>isIllegalOperation</a>. In some cases, an
--   implementation will not be able to distinguish between the possible
--   error causes. In this case it should fail with
--   <a>isIllegalOperation</a>.
isIllegalOperation :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   user does not have sufficient operating system privilege to perform
--   that operation.
isPermissionError :: IOError -> Bool

-- | A programmer-defined error value constructed using <a>userError</a>.
isUserError :: IOError -> Bool
ioeGetErrorType :: IOError -> IOErrorType
ioeGetLocation :: IOError -> String
ioeGetErrorString :: IOError -> String
ioeGetHandle :: IOError -> Maybe Handle
ioeGetFileName :: IOError -> Maybe FilePath
ioeSetErrorType :: IOError -> IOErrorType -> IOError
ioeSetErrorString :: IOError -> String -> IOError
ioeSetLocation :: IOError -> String -> IOError
ioeSetHandle :: IOError -> Handle -> IOError
ioeSetFileName :: IOError -> FilePath -> IOError

-- | An abstract type that contains a value for each variant of
--   <a>IOError</a>.
data IOErrorType

-- | I/O error where the operation failed because one of its arguments
--   already exists.
alreadyExistsErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments does
--   not exist.
doesNotExistErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments is a
--   single-use resource, which is already being used.
alreadyInUseErrorType :: IOErrorType

-- | I/O error where the operation failed because the device is full.
fullErrorType :: IOErrorType

-- | I/O error where the operation failed because the end of file has been
--   reached.
eofErrorType :: IOErrorType

-- | I/O error where the operation is not possible.
illegalOperationErrorType :: IOErrorType

-- | I/O error where the operation failed because the user does not have
--   sufficient operating system privilege to perform that operation.
permissionErrorType :: IOErrorType

-- | I/O error that is programmer-defined.
userErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments
--   already exists.
isAlreadyExistsErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because one of its arguments does
--   not exist.
isDoesNotExistErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because one of its arguments is a
--   single-use resource, which is already being used.
isAlreadyInUseErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the device is full.
isFullErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the end of file has been
--   reached.
isEOFErrorType :: IOErrorType -> Bool

-- | I/O error where the operation is not possible.
isIllegalOperationErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the user does not have
--   sufficient operating system privilege to perform that operation.
isPermissionErrorType :: IOErrorType -> Bool

-- | I/O error that is programmer-defined.
isUserErrorType :: IOErrorType -> Bool

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | The <a>catchIOError</a> function establishes a handler that receives
--   any <a>IOError</a> raised in the action protected by
--   <a>catchIOError</a>. An <a>IOError</a> is caught by the most recent
--   handler established by one of the exception handling functions. These
--   handlers are not selective: all <a>IOError</a>s are caught. Exception
--   propagation must be explicitly provided in a handler by re-raising any
--   unwanted exceptions. For example, in
--   
--   <pre>
--   f = catchIOError g (\e -&gt; if IO.isEOFError e then return [] else ioError e)
--   </pre>
--   
--   the function <tt>f</tt> returns <tt>[]</tt> when an end-of-file
--   exception (cf. <a>isEOFError</a>) occurs in <tt>g</tt>; otherwise, the
--   exception is propagated to the next outer handler.
--   
--   When an exception propagates outside the main program, the Haskell
--   system prints the associated <a>IOError</a> value and exits the
--   program.
--   
--   Non-I/O exceptions are not caught by this variant; to catch all
--   exceptions, use <a>catch</a> from <a>Control.Exception</a>.
catchIOError :: IO a -> (IOError -> IO a) -> IO a

-- | The construct <a>tryIOError</a> <tt>comp</tt> exposes IO errors which
--   occur within a computation, and which are not fully handled.
--   
--   Non-I/O exceptions are not caught by this variant; to catch all
--   exceptions, use <a>try</a> from <a>Control.Exception</a>.
tryIOError :: IO a -> IO (Either IOError a)

-- | Catch any <a>IOError</a> that occurs in the computation and throw a
--   modified version.
modifyIOError :: (IOError -> IOError) -> IO a -> IO a


module GHC.Profiling
startProfTimer :: IO ()
stopProfTimer :: IO ()


-- | Basic concurrency stuff.
module GHC.Conc.IO
ensureIOManagerIsRunning :: IO ()
ioManagerCapabilitiesChanged :: IO ()

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
threadDelay :: Int -> IO ()

-- | Set the value of returned TVar to True after a given number of
--   microseconds. The caveats associated with threadDelay also apply.
registerDelay :: Int -> IO (TVar Bool)

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <tt>IOError</tt> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <tt>IOError</tt> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | Close a file descriptor in a concurrency-safe way (GHC only). If you
--   are using <a>threadWaitRead</a> or <a>threadWaitWrite</a> to perform
--   blocking I/O, you <i>must</i> use this function to close file
--   descriptors, or blocked threads may not be woken.
--   
--   Any threads that are blocked on the file descriptor via
--   <a>threadWaitRead</a> or <a>threadWaitWrite</a> will be unblocked by
--   having IO exceptions thrown.
closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()


-- | Basic concurrency stuff.
module GHC.Conc

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId
ThreadId :: ThreadId# -> ThreadId

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
forkIO :: IO () -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | the value passed to the <tt>+RTS -N</tt> flag. This is the number of
--   Haskell threads that can run truly simultaneously at any given time,
--   and is typically set to the number of physical processor cores on the
--   machine.
--   
--   Strictly speaking it is better to use <a>getNumCapabilities</a>,
--   because the number of capabilities might vary at runtime.
numCapabilities :: Int

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
setNumCapabilities :: Int -> IO ()

-- | Returns the number of CPUs that the machine has
getNumProcessors :: IO Int

-- | Returns the number of sparks currently in the local spark pool
numSparks :: IO Int
childHandler :: SomeException -> IO ()

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()
par :: a -> b -> b
pseq :: a -> b -> b

-- | Internal function used by the RTS to run sparks.
runSparks :: IO ()

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | <a>labelThread</a> stores a string as identifier for this thread if
--   you built a RTS with debugging support. This identifier will be used
--   in the debugging output to make distinction of different threads
--   easier (otherwise you only have the thread state object's address in
--   the heap).
--   
--   Other applications like the graphical Concurrent Haskell Debugger
--   (<a>http://www.informatik.uni-kiel.de/~fhu/chd/</a>) may choose to
--   overload <a>labelThread</a> for their purposes as well.
labelThread :: ThreadId -> String -> IO ()

-- | make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)

-- | The current status of a thread
data ThreadStatus

-- | the thread is currently runnable or running
ThreadRunning :: ThreadStatus

-- | the thread has finished
ThreadFinished :: ThreadStatus

-- | the thread is blocked on some resource
ThreadBlocked :: BlockReason -> ThreadStatus

-- | the thread received an uncaught exception
ThreadDied :: ThreadStatus
data BlockReason

-- | blocked on <a>MVar</a>
BlockedOnMVar :: BlockReason

-- | blocked on a computation in progress by another thread
BlockedOnBlackHole :: BlockReason

-- | blocked in <a>throwTo</a>
BlockedOnException :: BlockReason

-- | blocked in <a>retry</a> in an STM transaction
BlockedOnSTM :: BlockReason

-- | currently in a foreign call
BlockedOnForeignCall :: BlockReason

-- | blocked on some other resource. Without <tt>-threaded</tt>, I/O and
--   <tt>threadDelay</tt> show up as <a>BlockedOnOther</a>, with
--   <tt>-threaded</tt> they show up as <a>BlockedOnMVar</a>.
BlockedOnOther :: BlockReason
threadStatus :: ThreadId -> IO ThreadStatus

-- | returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
threadCapability :: ThreadId -> IO (Int, Bool)

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
threadDelay :: Int -> IO ()

-- | Set the value of returned TVar to True after a given number of
--   microseconds. The caveats associated with threadDelay also apply.
registerDelay :: Int -> IO (TVar Bool)

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <tt>IOError</tt> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <tt>IOError</tt> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | Close a file descriptor in a concurrency-safe way (GHC only). If you
--   are using <a>threadWaitRead</a> or <a>threadWaitWrite</a> to perform
--   blocking I/O, you <i>must</i> use this function to close file
--   descriptors, or blocked threads may not be woken.
--   
--   Any threads that are blocked on the file descriptor via
--   <a>threadWaitRead</a> or <a>threadWaitWrite</a> will be unblocked by
--   having IO exceptions thrown.
closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()

-- | Every thread has an allocation counter that tracks how much memory has
--   been allocated by the thread. The counter is initialized to zero, and
--   <a>setAllocationCounter</a> sets the current value. The allocation
--   counter counts *down*, so in the absence of a call to
--   <a>setAllocationCounter</a> its value is the negation of the number of
--   bytes of memory allocated by the thread.
--   
--   There are two things that you can do with this counter:
--   
--   <ul>
--   <li>Use it as a simple profiling mechanism, with
--   <a>getAllocationCounter</a>.</li>
--   <li>Use it as a resource limit. See <a>enableAllocationLimit</a>.</li>
--   </ul>
--   
--   Allocation accounting is accurate only to about 4Kbytes.
setAllocationCounter :: Int64 -> IO ()

-- | Return the current value of the allocation counter for the current
--   thread.
getAllocationCounter :: IO Int64

-- | Enables the allocation counter to be treated as a limit for the
--   current thread. When the allocation limit is enabled, if the
--   allocation counter counts down below zero, the thread will be sent the
--   <a>AllocationLimitExceeded</a> asynchronous exception. When this
--   happens, the counter is reinitialised (by default to 100K, but tunable
--   with the <tt>+RTS -xq</tt> option) so that it can handle the exception
--   and perform any necessary clean up. If it exhausts this additional
--   allowance, another <a>AllocationLimitExceeded</a> exception is sent,
--   and so forth.
--   
--   Note that memory allocation is unrelated to <i>live memory</i>, also
--   known as <i>heap residency</i>. A thread can allocate a large amount
--   of memory and retain anything between none and all of it. It is better
--   to think of the allocation limit as a limit on <i>CPU time</i>, rather
--   than a limit on memory.
--   
--   Compared to using timeouts, allocation limits don't count time spent
--   blocked or in foreign calls.
enableAllocationLimit :: IO ()

-- | Disable allocation limit processing for the current thread.
disableAllocationLimit :: IO ()

-- | A monad supporting atomic memory transactions.
newtype STM a
STM :: (State# RealWorld -> (# State# RealWorld, a #)) -> STM a

-- | Perform a series of STM actions atomically.
--   
--   You cannot use <a>atomically</a> inside an <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>. Any attempt to do so will result in a
--   runtime error. (Reason: allowing this would effectively allow a
--   transaction inside a transaction, depending on exactly when the thunk
--   is evaluated.)
--   
--   However, see <a>newTVarIO</a>, which can be called inside
--   <a>unsafePerformIO</a>, and which allows top-level TVars to be
--   allocated.
atomically :: STM a -> IO a

-- | Retry execution of the current memory transaction because it has seen
--   values in TVars which mean that it should not continue (e.g. the TVars
--   represent a shared buffer that is now empty). The implementation may
--   block the thread until one of the TVars that it has read from has been
--   udpated. (GHC only)
retry :: STM a

-- | Compose two alternative STM actions (GHC only). If the first action
--   completes without retrying then it forms the result of the orElse.
--   Otherwise, if the first action retries, then the second action is
--   tried in its place. If both actions retry then the orElse as a whole
--   retries.
orElse :: STM a -> STM a -> STM a

-- | A variant of <a>throw</a> that can only be used within the <a>STM</a>
--   monad.
--   
--   Throwing an exception in <tt>STM</tt> aborts the transaction and
--   propagates the exception.
--   
--   Although <a>throwSTM</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e    `seq` x  ===&gt; throw e
--   throwSTM e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwSTM</a> will only cause
--   an exception to be raised when it is used within the <a>STM</a> monad.
--   The <a>throwSTM</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>STM</a> monad because
--   it guarantees ordering with respect to other <a>STM</a> operations,
--   whereas <a>throw</a> does not.
throwSTM :: Exception e => e -> STM a

-- | Exception handling within STM actions.
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a

-- | alwaysSucceeds adds a new invariant that must be true when passed to
--   alwaysSucceeds, at the end of the current transaction, and at the end
--   of every subsequent transaction. If it fails at any of those points
--   then the transaction violating it is aborted and the exception raised
--   by the invariant is propagated.
alwaysSucceeds :: STM a -> STM ()

-- | always is a variant of alwaysSucceeds in which the invariant is
--   expressed as an STM Bool action that must return True. Returning False
--   or raising an exception are both treated as invariant failures.
always :: STM Bool -> STM ()

-- | Shared memory locations that support atomic memory transactions.
data TVar a
TVar :: (TVar# RealWorld a) -> TVar a

-- | Create a new TVar holding a value supplied
newTVar :: a -> STM (TVar a)

-- | <tt>IO</tt> version of <a>newTVar</a>. This is useful for creating
--   top-level <a>TVar</a>s using <a>unsafePerformIO</a>, because using
--   <a>atomically</a> inside <a>unsafePerformIO</a> isn't possible.
newTVarIO :: a -> IO (TVar a)

-- | Return the current value stored in a TVar
readTVar :: TVar a -> STM a

-- | Return the current value stored in a TVar. This is equivalent to
--   
--   <pre>
--   readTVarIO = atomically . readTVar
--   </pre>
--   
--   but works much faster, because it doesn't perform a complete
--   transaction, it just reads the current value of the <a>TVar</a>.
readTVarIO :: TVar a -> IO a

-- | Write the supplied value into a TVar
writeTVar :: TVar a -> a -> STM ()

-- | Unsafely performs IO in the STM monad. Beware: this is a highly
--   dangerous thing to do.
--   
--   <ul>
--   <li>The STM implementation will often run transactions multiple times,
--   so you need to be prepared for this if your IO has any side
--   effects.</li>
--   <li>The STM implementation will abort transactions that are known to
--   be invalid and need to be restarted. This may happen in the middle of
--   <a>unsafeIOToSTM</a>, so make sure you don't acquire any resources
--   that need releasing (exception handlers are ignored when aborting the
--   transaction). That includes doing any IO using Handles, for example.
--   Getting this wrong will probably lead to random deadlocks.</li>
--   <li>The transaction may have seen an inconsistent view of memory when
--   the IO runs. Invariants that you expect to be true throughout your
--   program may not be true inside a transaction, due to the way
--   transactions are implemented. Normally this wouldn't be visible to the
--   programmer, but using <a>unsafeIOToSTM</a> can expose it.</li>
--   </ul>
unsafeIOToSTM :: IO a -> STM a
withMVar :: MVar a -> (a -> IO b) -> IO b
type Signal = CInt
type HandlerFun = ForeignPtr Word8 -> IO ()
setHandler :: Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))
runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
ensureIOManagerIsRunning :: IO ()
ioManagerCapabilitiesChanged :: IO ()
setUncaughtExceptionHandler :: (SomeException -> IO ()) -> IO ()
getUncaughtExceptionHandler :: IO (SomeException -> IO ())
reportError :: SomeException -> IO ()
reportStackOverflow :: IO ()


-- | External API for GHC's Handle implementation
module GHC.IO.Handle

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: (Maybe Int) -> BufferMode

-- | makes a new <a>Handle</a>
mkFileHandle :: (IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | like <a>mkFileHandle</a>, except that a <a>Handle</a> is created with
--   two independent buffers, one for reading and one for writing. Used for
--   full-duplex streams, such as network sockets.
mkDuplexHandle :: (IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | For a handle <tt>hdl</tt> which attached to a physical file,
--   <a>hFileSize</a> <tt>hdl</tt> returns the size of that file in 8-bit
--   bytes.
hFileSize :: Handle -> IO Integer

-- | <a>hSetFileSize</a> <tt>hdl</tt> <tt>size</tt> truncates the physical
--   file with handle <tt>hdl</tt> to <tt>size</tt> bytes.
hSetFileSize :: Handle -> Integer -> IO ()

-- | For a readable handle <tt>hdl</tt>, <a>hIsEOF</a> <tt>hdl</tt> returns
--   <a>True</a> if no further input can be taken from <tt>hdl</tt> or for
--   a physical file, if the current I/O position is equal to the length of
--   the file. Otherwise, it returns <a>False</a>.
--   
--   NOTE: <a>hIsEOF</a> may block, because it has to attempt to read from
--   the stream to determine whether there is any more data to be read.
hIsEOF :: Handle -> IO Bool

-- | Computation <a>hLookAhead</a> returns the next character from the
--   handle without removing it from the input buffer, blocking until a
--   character is available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isEOFError</tt> if the end of file has been reached.</li>
--   </ul>
hLookAhead :: Handle -> IO Char

-- | Computation <a>hSetBuffering</a> <tt>hdl mode</tt> sets the mode of
--   buffering for handle <tt>hdl</tt> on subsequent reads and writes.
--   
--   If the buffer mode is changed from <a>BlockBuffering</a> or
--   <a>LineBuffering</a> to <a>NoBuffering</a>, then
--   
--   <ul>
--   <li>if <tt>hdl</tt> is writable, the buffer is flushed as for
--   <a>hFlush</a>;</li>
--   <li>if <tt>hdl</tt> is not writable, the contents of the buffer is
--   discarded.</li>
--   </ul>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if the handle has already been used for
--   reading or writing and the implementation does not allow the buffering
--   mode to be changed.</li>
--   </ul>
hSetBuffering :: Handle -> BufferMode -> IO ()

-- | Select binary mode (<a>True</a>) or text mode (<a>False</a>) on a open
--   handle. (See also <tt>openBinaryFile</tt>.)
--   
--   This has the same effect as calling <a>hSetEncoding</a> with
--   <a>char8</a>, together with <a>hSetNewlineMode</a> with
--   <a>noNewlineTranslation</a>.
hSetBinaryMode :: Handle -> Bool -> IO ()

-- | The action <a>hSetEncoding</a> <tt>hdl</tt> <tt>encoding</tt> changes
--   the text encoding for the handle <tt>hdl</tt> to <tt>encoding</tt>.
--   The default encoding when a <a>Handle</a> is created is
--   <tt>localeEncoding</tt>, namely the default encoding for the current
--   locale.
--   
--   To create a <a>Handle</a> with no encoding at all, use
--   <tt>openBinaryFile</tt>. To stop further encoding or decoding on an
--   existing <a>Handle</a>, use <a>hSetBinaryMode</a>.
--   
--   <a>hSetEncoding</a> may need to flush buffered data in order to change
--   the encoding.
hSetEncoding :: Handle -> TextEncoding -> IO ()

-- | Return the current <a>TextEncoding</a> for the specified
--   <a>Handle</a>, or <a>Nothing</a> if the <a>Handle</a> is in binary
--   mode.
--   
--   Note that the <a>TextEncoding</a> remembers nothing about the state of
--   the encoder/decoder in use on this <a>Handle</a>. For example, if the
--   encoding in use is UTF-16, then using <a>hGetEncoding</a> and
--   <a>hSetEncoding</a> to save and restore the encoding may result in an
--   extra byte-order-mark being written to the file.
hGetEncoding :: Handle -> IO (Maybe TextEncoding)

-- | The action <a>hFlush</a> <tt>hdl</tt> causes any items buffered for
--   output in handle <tt>hdl</tt> to be sent immediately to the operating
--   system.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isFullError</tt> if the device is full;</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances.</li>
--   </ul>
hFlush :: Handle -> IO ()

-- | The action <a>hFlushAll</a> <tt>hdl</tt> flushes all buffered data in
--   <tt>hdl</tt>, including any buffered read data. Buffered read data is
--   flushed by seeking the file position back to the point before the
--   bufferred data was read, and hence only works if <tt>hdl</tt> is
--   seekable (see <a>hIsSeekable</a>).
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isFullError</tt> if the device is full;</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances;</li>
--   <li><tt>isIllegalOperation</tt> if <tt>hdl</tt> has buffered read
--   data, and is not seekable.</li>
--   </ul>
hFlushAll :: Handle -> IO ()

-- | Returns a duplicate of the original handle, with its own buffer. The
--   two Handles will share a file pointer, however. The original handle's
--   buffer is flushed, including discarding any input data, before the
--   handle is duplicated.
hDuplicate :: Handle -> IO Handle

-- | Makes the second handle a duplicate of the first handle. The second
--   handle will be closed first, if it is not already.
--   
--   This can be used to retarget the standard Handles, for example:
--   
--   <pre>
--   do h &lt;- openFile "mystdout" WriteMode
--      hDuplicateTo h stdout
--   </pre>
hDuplicateTo :: Handle -> Handle -> IO ()

-- | Computation <a>hClose</a> <tt>hdl</tt> makes handle <tt>hdl</tt>
--   closed. Before the computation finishes, if <tt>hdl</tt> is writable
--   its buffer is flushed as for <a>hFlush</a>. Performing <a>hClose</a>
--   on a handle that has already been closed has no effect; doing so is
--   not an error. All other operations on a closed handle will fail. If
--   <a>hClose</a> fails for any reason, any further operations (apart from
--   <a>hClose</a>) on the handle will still fail as if <tt>hdl</tt> had
--   been successfully closed.
hClose :: Handle -> IO ()
hClose_help :: Handle__ -> IO (Handle__, Maybe SomeException)
type HandlePosition = Integer
data HandlePosn
HandlePosn :: Handle -> HandlePosition -> HandlePosn

-- | Computation <a>hGetPosn</a> <tt>hdl</tt> returns the current I/O
--   position of <tt>hdl</tt> as a value of the abstract type
--   <a>HandlePosn</a>.
hGetPosn :: Handle -> IO HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSetPosn :: HandlePosn -> IO ()

-- | A mode that determines the effect of <tt>hSeek</tt> <tt>hdl mode
--   i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Computation <a>hSeek</a> <tt>hdl mode i</tt> sets the position of
--   handle <tt>hdl</tt> depending on <tt>mode</tt>. The offset <tt>i</tt>
--   is given in terms of 8-bit bytes.
--   
--   If <tt>hdl</tt> is block- or line-buffered, then seeking to a position
--   which is not in the current buffer will first cause any items in the
--   output buffer to be written to the device, and then cause the input
--   buffer to be discarded. Some handles may not be seekable (see
--   <a>hIsSeekable</a>), or only support a subset of the possible
--   positioning operations (for instance, it may only be possible to seek
--   to the end of a tape, or to a positive offset from the beginning or
--   current position). It is not possible to set a negative I/O position,
--   or for a physical file, an I/O position beyond the current
--   end-of-file.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isIllegalOperationError</tt> if the Handle is not seekable, or
--   does not support the requested seek mode.</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSeek :: Handle -> SeekMode -> Integer -> IO ()

-- | Computation <a>hTell</a> <tt>hdl</tt> returns the current position of
--   the handle <tt>hdl</tt>, as the number of bytes from the beginning of
--   the file. The value returned may be subsequently passed to
--   <a>hSeek</a> to reposition the handle to the current position.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isIllegalOperationError</tt> if the Handle is not
--   seekable.</li>
--   </ul>
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool

-- | Computation <a>hGetBuffering</a> <tt>hdl</tt> returns the current
--   buffering mode for <tt>hdl</tt>.
hGetBuffering :: Handle -> IO BufferMode
hIsSeekable :: Handle -> IO Bool

-- | Set the echoing status of a handle connected to a terminal.
hSetEcho :: Handle -> Bool -> IO ()

-- | Get the echoing status of a handle connected to a terminal.
hGetEcho :: Handle -> IO Bool

-- | Is the handle connected to a terminal?
hIsTerminalDevice :: Handle -> IO Bool

-- | Set the <a>NewlineMode</a> on the specified <a>Handle</a>. All
--   buffered data is flushed first.
hSetNewlineMode :: Handle -> NewlineMode -> IO ()

-- | The representation of a newline in the external file or stream.
data Newline

-- | '\n'
LF :: Newline

-- | '\r\n'
CRLF :: Newline

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the '\n' character; the newline
--   mode specifies how to translate '\n' on output, and what to translate
--   into '\n' on input.
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
[inputNL] :: NewlineMode -> Newline

-- | the representation of newlines on output
[outputNL] :: NewlineMode -> Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Map '\r\n' into '\n' on input, and '\n' to the native newline
--   represetnation on output. This mode can be used on any platform, and
--   works with text files using any newline convention. The downside is
--   that <tt>readFile &gt;&gt;= writeFile</tt> might yield a different
--   file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF,
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode

-- | <a>hShow</a> is in the <a>IO</a> monad, and gives more comprehensive
--   output than the (pure) instance of <a>Show</a> for <a>Handle</a>.
hShow :: Handle -> IO String

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   If <a>hGetLine</a> encounters end-of-file at any other point while
--   reading in a line, it is treated as a line terminator and the
--   (partial) line is returned.
hGetLine :: Handle -> IO String

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <tt>hClose</tt>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <tt>hClose</tt> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <tt>TextEncoding</tt>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
instance GHC.Classes.Eq GHC.IO.Handle.HandlePosn
instance GHC.Show.Show GHC.IO.Handle.HandlePosn


-- | Handle operations implemented by file descriptors (FDs)
module GHC.IO.Handle.FD

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | Computation <a>openFile</a> <tt>file mode</tt> allocates and returns a
--   new, open handle to manage the file <tt>file</tt>. It manages input if
--   <tt>mode</tt> is <a>ReadMode</a>, output if <tt>mode</tt> is
--   <a>WriteMode</a> or <a>AppendMode</a>, and both input and output if
--   mode is <a>ReadWriteMode</a>.
--   
--   If the file does not exist and it is opened for output, it should be
--   created as a new file. If <tt>mode</tt> is <a>WriteMode</a> and the
--   file already exists, then it should be truncated to zero length. Some
--   operating systems delete empty files, so there is no guarantee that
--   the file will exist following an <a>openFile</a> with <tt>mode</tt>
--   <a>WriteMode</a> unless it is subsequently written to successfully.
--   The handle is positioned at the end of the file if <tt>mode</tt> is
--   <a>AppendMode</a>, and otherwise at the beginning (in which case its
--   internal position is 0). The initial buffer mode is
--   implementation-dependent.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isAlreadyInUseError</tt> if the file is already open and
--   cannot be reopened;</li>
--   <li><tt>isDoesNotExistError</tt> if the file does not exist; or</li>
--   <li><tt>isPermissionError</tt> if the user does not have permission to
--   open the file.</li>
--   </ul>
--   
--   Note: if you will be working with files containing binary data, you'll
--   want to be using <a>openBinaryFile</a>.
openFile :: FilePath -> IOMode -> IO Handle

-- | Like <a>openFile</a>, but open the file in binary mode. On Windows,
--   reading a file in text mode (which is the default) will translate CRLF
--   to LF, and writing will translate LF to CRLF. This is usually what you
--   want with text files. With binary files this is undesirable; also, as
--   usual under Microsoft operating systems, text mode treats control-Z as
--   EOF. Binary mode turns off all special treatment of end-of-line and
--   end-of-file characters. (See also <a>hSetBinaryMode</a>.)
openBinaryFile :: FilePath -> IOMode -> IO Handle

-- | Like <a>openFile</a>, but opens the file in ordinary blocking mode.
--   This can be useful for opening a FIFO for reading: if we open in
--   non-blocking mode then the open will fail if there are no writers,
--   whereas a blocking open will block until a writer appears.
openFileBlocking :: FilePath -> IOMode -> IO Handle
mkHandleFromFD :: FD -> IODeviceType -> FilePath -> IOMode -> Bool -> Maybe TextEncoding -> IO Handle

-- | Turn an existing file descriptor into a Handle. This is used by
--   various external libraries to make Handles.
--   
--   Makes a binary Handle. This is for historical reasons; it should
--   probably be a text Handle with the default encoding and newline
--   translation instead.
fdToHandle :: FD -> IO Handle

-- | Old API kept to avoid breaking clients
fdToHandle' :: CInt -> Maybe IODeviceType -> Bool -> FilePath -> IOMode -> Bool -> IO Handle

-- | The computation <a>isEOF</a> is identical to <a>hIsEOF</a>, except
--   that it works only on <a>stdin</a>.
isEOF :: IO Bool


-- | The standard IO library.
module System.IO

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a :: * -> *
fixIO :: (a -> IO a) -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | <tt><a>withFile</a> name mode act</tt> opens a file using
--   <a>openFile</a> and passes the resulting handle to the computation
--   <tt>act</tt>. The handle will be closed on exit from <a>withFile</a>,
--   whether by normal termination or by raising an exception. If closing
--   the handle raises an exception, then this exception will be raised by
--   <a>withFile</a> rather than any exception raised by <tt>act</tt>.
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | Computation <a>openFile</a> <tt>file mode</tt> allocates and returns a
--   new, open handle to manage the file <tt>file</tt>. It manages input if
--   <tt>mode</tt> is <a>ReadMode</a>, output if <tt>mode</tt> is
--   <a>WriteMode</a> or <a>AppendMode</a>, and both input and output if
--   mode is <a>ReadWriteMode</a>.
--   
--   If the file does not exist and it is opened for output, it should be
--   created as a new file. If <tt>mode</tt> is <a>WriteMode</a> and the
--   file already exists, then it should be truncated to zero length. Some
--   operating systems delete empty files, so there is no guarantee that
--   the file will exist following an <a>openFile</a> with <tt>mode</tt>
--   <a>WriteMode</a> unless it is subsequently written to successfully.
--   The handle is positioned at the end of the file if <tt>mode</tt> is
--   <a>AppendMode</a>, and otherwise at the beginning (in which case its
--   internal position is 0). The initial buffer mode is
--   implementation-dependent.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isAlreadyInUseError</tt> if the file is already open and
--   cannot be reopened;</li>
--   <li><tt>isDoesNotExistError</tt> if the file does not exist; or</li>
--   <li><tt>isPermissionError</tt> if the user does not have permission to
--   open the file.</li>
--   </ul>
--   
--   Note: if you will be working with files containing binary data, you'll
--   want to be using <a>openBinaryFile</a>.
openFile :: FilePath -> IOMode -> IO Handle

-- | See <a>openFile</a>
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Computation <a>hClose</a> <tt>hdl</tt> makes handle <tt>hdl</tt>
--   closed. Before the computation finishes, if <tt>hdl</tt> is writable
--   its buffer is flushed as for <a>hFlush</a>. Performing <a>hClose</a>
--   on a handle that has already been closed has no effect; doing so is
--   not an error. All other operations on a closed handle will fail. If
--   <a>hClose</a> fails for any reason, any further operations (apart from
--   <a>hClose</a>) on the handle will still fail as if <tt>hdl</tt> had
--   been successfully closed.
hClose :: Handle -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | For a handle <tt>hdl</tt> which attached to a physical file,
--   <a>hFileSize</a> <tt>hdl</tt> returns the size of that file in 8-bit
--   bytes.
hFileSize :: Handle -> IO Integer

-- | <a>hSetFileSize</a> <tt>hdl</tt> <tt>size</tt> truncates the physical
--   file with handle <tt>hdl</tt> to <tt>size</tt> bytes.
hSetFileSize :: Handle -> Integer -> IO ()

-- | For a readable handle <tt>hdl</tt>, <a>hIsEOF</a> <tt>hdl</tt> returns
--   <a>True</a> if no further input can be taken from <tt>hdl</tt> or for
--   a physical file, if the current I/O position is equal to the length of
--   the file. Otherwise, it returns <a>False</a>.
--   
--   NOTE: <a>hIsEOF</a> may block, because it has to attempt to read from
--   the stream to determine whether there is any more data to be read.
hIsEOF :: Handle -> IO Bool

-- | The computation <a>isEOF</a> is identical to <a>hIsEOF</a>, except
--   that it works only on <a>stdin</a>.
isEOF :: IO Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: (Maybe Int) -> BufferMode

-- | Computation <a>hSetBuffering</a> <tt>hdl mode</tt> sets the mode of
--   buffering for handle <tt>hdl</tt> on subsequent reads and writes.
--   
--   If the buffer mode is changed from <a>BlockBuffering</a> or
--   <a>LineBuffering</a> to <a>NoBuffering</a>, then
--   
--   <ul>
--   <li>if <tt>hdl</tt> is writable, the buffer is flushed as for
--   <a>hFlush</a>;</li>
--   <li>if <tt>hdl</tt> is not writable, the contents of the buffer is
--   discarded.</li>
--   </ul>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if the handle has already been used for
--   reading or writing and the implementation does not allow the buffering
--   mode to be changed.</li>
--   </ul>
hSetBuffering :: Handle -> BufferMode -> IO ()

-- | Computation <a>hGetBuffering</a> <tt>hdl</tt> returns the current
--   buffering mode for <tt>hdl</tt>.
hGetBuffering :: Handle -> IO BufferMode

-- | The action <a>hFlush</a> <tt>hdl</tt> causes any items buffered for
--   output in handle <tt>hdl</tt> to be sent immediately to the operating
--   system.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isFullError</tt> if the device is full;</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances.</li>
--   </ul>
hFlush :: Handle -> IO ()

-- | Computation <a>hGetPosn</a> <tt>hdl</tt> returns the current I/O
--   position of <tt>hdl</tt> as a value of the abstract type
--   <a>HandlePosn</a>.
hGetPosn :: Handle -> IO HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSetPosn :: HandlePosn -> IO ()
data HandlePosn

-- | Computation <a>hSeek</a> <tt>hdl mode i</tt> sets the position of
--   handle <tt>hdl</tt> depending on <tt>mode</tt>. The offset <tt>i</tt>
--   is given in terms of 8-bit bytes.
--   
--   If <tt>hdl</tt> is block- or line-buffered, then seeking to a position
--   which is not in the current buffer will first cause any items in the
--   output buffer to be written to the device, and then cause the input
--   buffer to be discarded. Some handles may not be seekable (see
--   <a>hIsSeekable</a>), or only support a subset of the possible
--   positioning operations (for instance, it may only be possible to seek
--   to the end of a tape, or to a positive offset from the beginning or
--   current position). It is not possible to set a negative I/O position,
--   or for a physical file, an I/O position beyond the current
--   end-of-file.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isIllegalOperationError</tt> if the Handle is not seekable, or
--   does not support the requested seek mode.</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSeek :: Handle -> SeekMode -> Integer -> IO ()

-- | A mode that determines the effect of <tt>hSeek</tt> <tt>hdl mode
--   i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Computation <a>hTell</a> <tt>hdl</tt> returns the current position of
--   the handle <tt>hdl</tt>, as the number of bytes from the beginning of
--   the file. The value returned may be subsequently passed to
--   <a>hSeek</a> to reposition the handle to the current position.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isIllegalOperationError</tt> if the Handle is not
--   seekable.</li>
--   </ul>
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool
hIsSeekable :: Handle -> IO Bool

-- | Is the handle connected to a terminal?
hIsTerminalDevice :: Handle -> IO Bool

-- | Set the echoing status of a handle connected to a terminal.
hSetEcho :: Handle -> Bool -> IO ()

-- | Get the echoing status of a handle connected to a terminal.
hGetEcho :: Handle -> IO Bool

-- | <a>hShow</a> is in the <a>IO</a> monad, and gives more comprehensive
--   output than the (pure) instance of <a>Show</a> for <a>Handle</a>.
hShow :: Handle -> IO String

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hReady</a> <tt>hdl</tt> indicates whether at least one
--   item is available for input from handle <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hReady :: Handle -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   If <a>hGetLine</a> encounters end-of-file at any other point while
--   reading in a line, it is treated as a line terminator and the
--   (partial) line is returned.
hGetLine :: Handle -> IO String

-- | Computation <a>hLookAhead</a> returns the next character from the
--   handle without removing it from the input buffer, blocking until a
--   character is available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isEOFError</tt> if the end of file has been reached.</li>
--   </ul>
hLookAhead :: Handle -> IO Char

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <tt>hClose</tt>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <tt>hClose</tt> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | The same as <a>hPutStr</a>, but adds a newline character.
hPutStrLn :: Handle -> String -> IO ()

-- | Computation <a>hPrint</a> <tt>hdl t</tt> writes the string
--   representation of <tt>t</tt> given by the <a>shows</a> function to the
--   file or channel managed by <tt>hdl</tt> and appends a newline.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPrint :: Show a => Handle -> a -> IO ()

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | <tt><a>withBinaryFile</a> name mode act</tt> opens a file using
--   <a>openBinaryFile</a> and passes the resulting handle to the
--   computation <tt>act</tt>. The handle will be closed on exit from
--   <a>withBinaryFile</a>, whether by normal termination or by raising an
--   exception.
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | Like <a>openFile</a>, but open the file in binary mode. On Windows,
--   reading a file in text mode (which is the default) will translate CRLF
--   to LF, and writing will translate LF to CRLF. This is usually what you
--   want with text files. With binary files this is undesirable; also, as
--   usual under Microsoft operating systems, text mode treats control-Z as
--   EOF. Binary mode turns off all special treatment of end-of-line and
--   end-of-file characters. (See also <a>hSetBinaryMode</a>.)
openBinaryFile :: FilePath -> IOMode -> IO Handle

-- | Select binary mode (<a>True</a>) or text mode (<a>False</a>) on a open
--   handle. (See also <tt>openBinaryFile</tt>.)
--   
--   This has the same effect as calling <a>hSetEncoding</a> with
--   <a>char8</a>, together with <a>hSetNewlineMode</a> with
--   <a>noNewlineTranslation</a>.
hSetBinaryMode :: Handle -> Bool -> IO ()

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufSome</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt>. If there is any data
--   available to read, then <a>hGetBufSome</a> returns it immediately; it
--   only blocks if there is no data to be read.
--   
--   It returns the number of bytes actually read. This may be zero if EOF
--   was reached before any data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBufSome</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufSome</a> will behave as if EOF was reached.
--   
--   <a>hGetBufSome</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBufSome :: Handle -> Ptr a -> Int -> IO Int
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <tt>TextEncoding</tt>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | The function creates a temporary file in ReadWrite mode. The created
--   file isn't deleted automatically, so you need to delete it manually.
--   
--   The file is creates with permissions such that only the current user
--   can read/write it.
--   
--   With some exceptions (see below), the file will be created securely in
--   the sense that an attacker should not be able to cause openTempFile to
--   overwrite another file on the filesystem using your credentials, by
--   putting symbolic links (on Unix) in the place where the temporary file
--   is to be created. On Unix the <tt>O_CREAT</tt> and <tt>O_EXCL</tt>
--   flags are used to prevent this attack, but note that <tt>O_EXCL</tt>
--   is sometimes not supported on NFS filesystems, so if you rely on this
--   behaviour it is best to use local filesystems only.
openTempFile :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openTempFile</a>, but opens the file in binary mode. See
--   <a>openBinaryFile</a> for more comments.
openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openTempFile</a>, but uses the default file permissions
openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openBinaryTempFile</a>, but uses the default file permissions
openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)

-- | The action <a>hSetEncoding</a> <tt>hdl</tt> <tt>encoding</tt> changes
--   the text encoding for the handle <tt>hdl</tt> to <tt>encoding</tt>.
--   The default encoding when a <a>Handle</a> is created is
--   <tt>localeEncoding</tt>, namely the default encoding for the current
--   locale.
--   
--   To create a <a>Handle</a> with no encoding at all, use
--   <tt>openBinaryFile</tt>. To stop further encoding or decoding on an
--   existing <a>Handle</a>, use <a>hSetBinaryMode</a>.
--   
--   <a>hSetEncoding</a> may need to flush buffered data in order to change
--   the encoding.
hSetEncoding :: Handle -> TextEncoding -> IO ()

-- | Return the current <a>TextEncoding</a> for the specified
--   <a>Handle</a>, or <a>Nothing</a> if the <a>Handle</a> is in binary
--   mode.
--   
--   Note that the <a>TextEncoding</a> remembers nothing about the state of
--   the encoder/decoder in use on this <a>Handle</a>. For example, if the
--   encoding in use is UTF-16, then using <a>hGetEncoding</a> and
--   <a>hSetEncoding</a> to save and restore the encoding may result in an
--   extra byte-order-mark being written to the file.
hGetEncoding :: Handle -> IO (Maybe TextEncoding)

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <tt>utf8</tt>.
data TextEncoding

-- | The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to
--   the first 256 Unicode code points, and is thus not a complete Unicode
--   encoding. An attempt to write a character greater than '\255' to a
--   <tt>Handle</tt> using the <a>latin1</a> encoding will result in an
--   error.
latin1 :: TextEncoding

-- | The UTF-8 Unicode encoding
utf8 :: TextEncoding

-- | The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte
--   sequence 0xEF 0xBB 0xBF). This encoding behaves like <a>utf8</a>,
--   except that on input, the BOM sequence is ignored at the beginning of
--   the stream, and on output, the BOM sequence is prepended.
--   
--   The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes
--   used to identify the encoding of a file.
utf8_bom :: TextEncoding

-- | The UTF-16 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf16 :: TextEncoding

-- | The UTF-16 Unicode encoding (litte-endian)
utf16le :: TextEncoding

-- | The UTF-16 Unicode encoding (big-endian)
utf16be :: TextEncoding

-- | The UTF-32 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf32 :: TextEncoding

-- | The UTF-32 Unicode encoding (litte-endian)
utf32le :: TextEncoding

-- | The UTF-32 Unicode encoding (big-endian)
utf32be :: TextEncoding

-- | The Unicode encoding of the current locale
--   
--   This is the initial locale encoding: if it has been subsequently
--   changed by <a>setLocaleEncoding</a> this value will not reflect that
--   change.
localeEncoding :: TextEncoding

-- | An encoding in which Unicode code points are translated to bytes by
--   taking the code point modulo 256. When decoding, bytes are translated
--   directly into the equivalent code point.
--   
--   This encoding never fails in either direction. However, encoding
--   discards information, so encode followed by decode is not the
--   identity.
char8 :: TextEncoding

-- | Look up the named Unicode encoding. May fail with
--   
--   <ul>
--   <li><tt>isDoesNotExistError</tt> if the encoding is unknown</li>
--   </ul>
--   
--   The set of known encodings is system-dependent, but includes at least:
--   
--   <ul>
--   <li><pre>UTF-8</pre></li>
--   <li><tt>UTF-16</tt>, <tt>UTF-16BE</tt>, <tt>UTF-16LE</tt></li>
--   <li><tt>UTF-32</tt>, <tt>UTF-32BE</tt>, <tt>UTF-32LE</tt></li>
--   </ul>
--   
--   There is additional notation (borrowed from GNU iconv) for specifying
--   how illegal characters are handled:
--   
--   <ul>
--   <li>a suffix of <tt>//IGNORE</tt>, e.g. <tt>UTF-8//IGNORE</tt>, will
--   cause all illegal sequences on input to be ignored, and on output will
--   drop all code points that have no representation in the target
--   encoding.</li>
--   <li>a suffix of <tt>//TRANSLIT</tt> will choose a replacement
--   character for illegal sequences or code points.</li>
--   <li>a suffix of <tt>//ROUNDTRIP</tt> will use a PEP383-style escape
--   mechanism to represent any invalid bytes in the input as Unicode
--   codepoints (specifically, as lone surrogates, which are normally
--   invalid in UTF-32). Upon output, these special codepoints are detected
--   and turned back into the corresponding original byte.</li>
--   </ul>
--   
--   In theory, this mechanism allows arbitrary data to be roundtripped via
--   a <a>String</a> with no loss of data. In practice, there are two
--   limitations to be aware of:
--   
--   <ol>
--   <li>This only stands a chance of working for an encoding which is an
--   ASCII superset, as for security reasons we refuse to escape any bytes
--   smaller than 128. Many encodings of interest are ASCII supersets (in
--   particular, you can assume that the locale encoding is an ASCII
--   superset) but many (such as UTF-16) are not.</li>
--   <li>If the underlying encoding is not itself roundtrippable, this
--   mechanism can fail. Roundtrippable encodings are those which have an
--   injective mapping into Unicode. Almost all encodings meet this
--   criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain
--   several different encodings of the same Unicode codepoint.</li>
--   </ol>
--   
--   On Windows, you can access supported code pages with the prefix
--   <tt>CP</tt>; for example, <tt>"CP1250"</tt>.
mkTextEncoding :: String -> IO TextEncoding

-- | Set the <a>NewlineMode</a> on the specified <a>Handle</a>. All
--   buffered data is flushed first.
hSetNewlineMode :: Handle -> NewlineMode -> IO ()

-- | The representation of a newline in the external file or stream.
data Newline

-- | '\n'
LF :: Newline

-- | '\r\n'
CRLF :: Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the '\n' character; the newline
--   mode specifies how to translate '\n' on output, and what to translate
--   into '\n' on input.
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
[inputNL] :: NewlineMode -> Newline

-- | the representation of newlines on output
[outputNL] :: NewlineMode -> Newline

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Map '\r\n' into '\n' on input, and '\n' to the native newline
--   represetnation on output. This mode can be used on any platform, and
--   works with text files using any newline convention. The downside is
--   that <tt>readFile &gt;&gt;= writeFile</tt> might yield a different
--   file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF,
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode


-- | Monadic fixpoints.
--   
--   For a detailed discussion, see Levent Erkok's thesis, <i>Value
--   Recursion in Monadic Computations</i>, Oregon Graduate Institute,
--   2002.
module Control.Monad.Fix

-- | Monads having fixed points with a 'knot-tying' semantics. Instances of
--   <a>MonadFix</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i><i>purity</i></i> <tt><a>mfix</a> (<tt>return</tt> . h) =
--   <tt>return</tt> (<a>fix</a> h)</tt></li>
--   <li><i><i>left shrinking</i> (or <i>tightening</i>)</i>
--   <tt><a>mfix</a> (\x -&gt; a &gt;&gt;= \y -&gt; f x y) = a &gt;&gt;= \y
--   -&gt; <a>mfix</a> (\x -&gt; f x y)</tt></li>
--   <li><i><i>sliding</i></i> <tt><a>mfix</a> (<a>liftM</a> h . f) =
--   <a>liftM</a> h (<a>mfix</a> (f . h))</tt>, for strict <tt>h</tt>.</li>
--   <li><i><i>nesting</i></i> <tt><a>mfix</a> (\x -&gt; <a>mfix</a> (\y
--   -&gt; f x y)) = <a>mfix</a> (\x -&gt; f x x)</tt></li>
--   </ul>
--   
--   This class is used in the translation of the recursive <tt>do</tt>
--   notation supported by GHC and Hugs.
class (Monad m) => MonadFix m

-- | The fixed point of a monadic computation. <tt><a>mfix</a> f</tt>
--   executes the action <tt>f</tt> only once, with the eventual output fed
--   back as the input. Hence <tt>f</tt> should not be strict, for then
--   <tt><a>mfix</a> f</tt> would diverge.
mfix :: MonadFix m => (a -> m a) -> m a

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
fix :: (a -> a) -> a
instance Control.Monad.Fix.MonadFix GHC.Base.Maybe
instance Control.Monad.Fix.MonadFix []
instance Control.Monad.Fix.MonadFix GHC.Types.IO
instance Control.Monad.Fix.MonadFix ((->) r)
instance Control.Monad.Fix.MonadFix (Data.Either.Either e)
instance Control.Monad.Fix.MonadFix (GHC.ST.ST s)


-- | Basic arrow definitions, based on
--   
--   <ul>
--   <li><i>Generalising Monads to Arrows</i>, by John Hughes, <i>Science
--   of Computer Programming</i> 37, pp67-111, May 2000.</li>
--   </ul>
--   
--   plus a couple of definitions (<a>returnA</a> and <a>loop</a>) from
--   
--   <ul>
--   <li><i>A New Notation for Arrows</i>, by Ross Paterson, in <i>ICFP
--   2001</i>, Firenze, Italy, pp229-240.</li>
--   </ul>
--   
--   These papers and more information on arrows can be found at
--   <a>http://www.haskell.org/arrows/</a>.
module Control.Arrow

-- | The basic arrow class.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>arr</a> id = <a>id</a></pre></li>
--   <li><pre><a>arr</a> (f &gt;&gt;&gt; g) = <a>arr</a> f &gt;&gt;&gt;
--   <a>arr</a> g</pre></li>
--   <li><pre><a>first</a> (<a>arr</a> f) = <a>arr</a> (<a>first</a>
--   f)</pre></li>
--   <li><pre><a>first</a> (f &gt;&gt;&gt; g) = <a>first</a> f &gt;&gt;&gt;
--   <a>first</a> g</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> <a>fst</a> =
--   <a>arr</a> <a>fst</a> &gt;&gt;&gt; f</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> *** g) =
--   <a>arr</a> (<a>id</a> *** g) &gt;&gt;&gt; <a>first</a> f</pre></li>
--   <li><pre><a>first</a> (<a>first</a> f) &gt;&gt;&gt; <a>arr</a>
--   <tt>assoc</tt> = <a>arr</a> <tt>assoc</tt> &gt;&gt;&gt; <a>first</a>
--   f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Category a => Arrow a where second f = arr swap >>> first f >>> arr swap where swap :: (x, y) -> (y, x) swap ~(x, y) = (y, x) f *** g = first f >>> second g f &&& g = arr (\ b -> (b, b)) >>> f *** g

-- | Lift a function to an arrow.
arr :: Arrow a => (b -> c) -> a b c

-- | Send the first component of the input through the argument arrow, and
--   copy the rest unchanged to the output.
first :: Arrow a => a b c -> a (b, d) (c, d)

-- | A mirror image of <a>first</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
second :: Arrow a => a b c -> a (d, b) (d, c)

-- | Split the input between the two argument arrows and combine their
--   output. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')

-- | Kleisli arrows of a monad.
newtype Kleisli m a b
Kleisli :: (a -> m b) -> Kleisli m a b
[runKleisli] :: Kleisli m a b -> a -> m b

-- | The identity arrow, which plays the role of <a>return</a> in arrow
--   notation.
returnA :: Arrow a => a b b

-- | Precomposition with a pure function.
(^>>) :: Arrow a => (b -> c) -> a c d -> a b d

-- | Postcomposition with a pure function.
(>>^) :: Arrow a => a b c -> (c -> d) -> a b d

-- | Left-to-right composition
(>>>) :: Category cat => cat a b -> cat b c -> cat a c

-- | Right-to-left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c

-- | Precomposition with a pure function (right-to-left variant).
(<<^) :: Arrow a => a c d -> (b -> c) -> a b d

-- | Postcomposition with a pure function (right-to-left variant).
(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
class Arrow a => ArrowZero a
zeroArrow :: ArrowZero a => a b c

-- | A monoid on arrows.
class ArrowZero a => ArrowPlus a

-- | An associative operation with identity <a>zeroArrow</a>.
(<+>) :: ArrowPlus a => a b c -> a b c -> a b c

-- | Choice, for arrows that support it. This class underlies the
--   <tt>if</tt> and <tt>case</tt> constructs in arrow notation.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>left</a> (<a>arr</a> f) = <a>arr</a> (<a>left</a>
--   f)</pre></li>
--   <li><pre><a>left</a> (f &gt;&gt;&gt; g) = <a>left</a> f &gt;&gt;&gt;
--   <a>left</a> g</pre></li>
--   <li><pre>f &gt;&gt;&gt; <a>arr</a> <a>Left</a> = <a>arr</a>
--   <a>Left</a> &gt;&gt;&gt; <a>left</a> f</pre></li>
--   <li><pre><a>left</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> +++ g) =
--   <a>arr</a> (<a>id</a> +++ g) &gt;&gt;&gt; <a>left</a> f</pre></li>
--   <li><pre><a>left</a> (<a>left</a> f) &gt;&gt;&gt; <a>arr</a>
--   <tt>assocsum</tt> = <a>arr</a> <tt>assocsum</tt> &gt;&gt;&gt;
--   <a>left</a> f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assocsum (Left (Left x)) = Left x
--   assocsum (Left (Right y)) = Right (Left y)
--   assocsum (Right z) = Right (Right z)
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Arrow a => ArrowChoice a where right f = arr mirror >>> left f >>> arr mirror where mirror :: Either x y -> Either y x mirror (Left x) = Right x mirror (Right y) = Left y f +++ g = left f >>> right g f ||| g = f +++ g >>> arr untag where untag (Left x) = x untag (Right y) = y

-- | Feed marked inputs through the argument arrow, passing the rest
--   through unchanged to the output.
left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)

-- | A mirror image of <a>left</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)

-- | Split the input between the two argument arrows, retagging and merging
--   their outputs. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')

-- | Fanin: Split the input between the two argument arrows and merge their
--   outputs.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d

-- | Some arrows allow application of arrow inputs to other inputs.
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>first</a> (<a>arr</a> (\x -&gt; <a>arr</a> (\y -&gt;
--   (x,y)))) &gt;&gt;&gt; <a>app</a> = <a>id</a></pre></li>
--   <li><pre><a>first</a> (<a>arr</a> (g &gt;&gt;&gt;)) &gt;&gt;&gt;
--   <a>app</a> = <a>second</a> g &gt;&gt;&gt; <a>app</a></pre></li>
--   <li><pre><a>first</a> (<a>arr</a> (&gt;&gt;&gt; h)) &gt;&gt;&gt;
--   <a>app</a> = <a>app</a> &gt;&gt;&gt; h</pre></li>
--   </ul>
--   
--   Such arrows are equivalent to monads (see <a>ArrowMonad</a>).
class Arrow a => ArrowApply a
app :: ArrowApply a => a (a b c, b) c

-- | The <a>ArrowApply</a> class is equivalent to <a>Monad</a>: any monad
--   gives rise to a <a>Kleisli</a> arrow, and any instance of
--   <a>ArrowApply</a> defines a monad.
newtype ArrowMonad a b
ArrowMonad :: (a () b) -> ArrowMonad a b

-- | Any instance of <a>ArrowApply</a> can be made into an instance of
--   <a>ArrowChoice</a> by defining <a>left</a> = <a>leftApp</a>.
leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)

-- | The <a>loop</a> operator expresses computations in which an output
--   value is fed back as input, although the computation occurs only once.
--   It underlies the <tt>rec</tt> value recursion construct in arrow
--   notation. <a>loop</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i><i>extension</i></i> <tt><a>loop</a> (<a>arr</a> f) =
--   <a>arr</a> (\ b -&gt; <a>fst</a> (<a>fix</a> (\ (c,d) -&gt; f
--   (b,d))))</tt></li>
--   <li><i><i>left tightening</i></i> <tt><a>loop</a> (<a>first</a> h
--   &gt;&gt;&gt; f) = h &gt;&gt;&gt; <a>loop</a> f</tt></li>
--   <li><i><i>right tightening</i></i> <tt><a>loop</a> (f &gt;&gt;&gt;
--   <a>first</a> h) = <a>loop</a> f &gt;&gt;&gt; h</tt></li>
--   <li><i><i>sliding</i></i> <tt><a>loop</a> (f &gt;&gt;&gt; <a>arr</a>
--   (<a>id</a> *** k)) = <a>loop</a> (<a>arr</a> (<a>id</a> *** k)
--   &gt;&gt;&gt; f)</tt></li>
--   <li><i><i>vanishing</i></i> <tt><a>loop</a> (<a>loop</a> f) =
--   <a>loop</a> (<a>arr</a> unassoc &gt;&gt;&gt; f &gt;&gt;&gt; <a>arr</a>
--   assoc)</tt></li>
--   <li><i><i>superposing</i></i> <tt><a>second</a> (<a>loop</a> f) =
--   <a>loop</a> (<a>arr</a> assoc &gt;&gt;&gt; <a>second</a> f
--   &gt;&gt;&gt; <a>arr</a> unassoc)</tt></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   unassoc (a,(b,c)) = ((a,b),c)
--   </pre>
class Arrow a => ArrowLoop a
loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
instance Control.Arrow.Arrow (->)
instance GHC.Base.Monad m => Control.Category.Category (Control.Arrow.Kleisli m)
instance GHC.Base.Monad m => Control.Arrow.Arrow (Control.Arrow.Kleisli m)
instance GHC.Base.MonadPlus m => Control.Arrow.ArrowZero (Control.Arrow.Kleisli m)
instance GHC.Base.MonadPlus m => Control.Arrow.ArrowPlus (Control.Arrow.Kleisli m)
instance Control.Arrow.ArrowChoice (->)
instance GHC.Base.Monad m => Control.Arrow.ArrowChoice (Control.Arrow.Kleisli m)
instance Control.Arrow.ArrowApply (->)
instance GHC.Base.Monad m => Control.Arrow.ArrowApply (Control.Arrow.Kleisli m)
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Arrow.ArrowMonad a)
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowApply a => GHC.Base.Monad (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowPlus a => GHC.Base.Alternative (Control.Arrow.ArrowMonad a)
instance (Control.Arrow.ArrowApply a, Control.Arrow.ArrowPlus a) => GHC.Base.MonadPlus (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowLoop (->)
instance Control.Monad.Fix.MonadFix m => Control.Arrow.ArrowLoop (Control.Arrow.Kleisli m)


-- | This module describes a structure intermediate between a functor and a
--   monad (technically, a strong lax monoidal functor). Compared with
--   monads, this interface lacks the full power of the binding operation
--   <a>&gt;&gt;=</a>, but
--   
--   <ul>
--   <li>it has more instances.</li>
--   <li>it is sufficient for many uses, e.g. context-free parsing, or the
--   <a>Traversable</a> class.</li>
--   <li>instances can perform analysis of computations before they are
--   executed, and thus produce shared optimizations.</li>
--   </ul>
--   
--   This interface was introduced for parsers by Niklas Röjemo, because it
--   admits more sharing than the monadic interface. The names here are
--   mostly based on parsing work by Doaitse Swierstra.
--   
--   For more details, see <a>Applicative Programming with Effects</a>, by
--   Conor McBride and Ross Paterson.
module Control.Applicative

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results
--   (<a>&lt;*&gt;</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of these
--   functions satisfying the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = <a>pure</a> (<a>const</a> <a>id</a>)
--   <a>&lt;*&gt;</a> u <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>pure</a> <a>const</a> <a>&lt;*&gt;</a>
--   u <a>&lt;*&gt;</a> v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative f where a1 *> a2 = (id <$ a1) <*> a2 (<*) = liftA2 const

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre>some v = (:) <tt>&lt;$&gt;</tt> v <a>&lt;*&gt;</a> many
--   v</pre></li>
--   <li><pre>many v = some v <a>&lt;|&gt;</a> <a>pure</a> []</pre></li>
--   </ul>
class Applicative f => Alternative f where some v = some_v where many_v = some_v <|> pure [] some_v = (fmap (:) v) <*> many_v many v = many_v where many_v = some_v <|> pure [] some_v = (fmap (:) v) <*> many_v

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
newtype Const a b
Const :: a -> Const a b
[getConst] :: Const a b -> a
newtype WrappedMonad m a
WrapMonad :: m a -> WrappedMonad m a
[unwrapMonad] :: WrappedMonad m a -> m a
newtype WrappedArrow a b c
WrapArrow :: a b c -> WrappedArrow a b c
[unwrapArrow] :: WrappedArrow a b c -> a b c

-- | Lists, but with an <a>Applicative</a> functor based on zipping, so
--   that
--   
--   <pre>
--   f <a>&lt;$&gt;</a> <a>ZipList</a> xs1 <a>&lt;*&gt;</a> ... <a>&lt;*&gt;</a> <a>ZipList</a> xsn = <a>ZipList</a> (zipWithn f xs1 ... xsn)
--   </pre>
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]

-- | An infix synonym for <a>fmap</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b

-- | Lift a function to actions. This function may be used as a value for
--   <a>fmap</a> in a <a>Functor</a> instance.
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)
instance GHC.Generics.Selector Control.Applicative.S1_0_0ZipList
instance GHC.Generics.Constructor Control.Applicative.C1_0ZipList
instance GHC.Generics.Datatype Control.Applicative.D1ZipList
instance GHC.Generics.Selector Control.Applicative.S1_0_0WrappedArrow
instance GHC.Generics.Constructor Control.Applicative.C1_0WrappedArrow
instance GHC.Generics.Datatype Control.Applicative.D1WrappedArrow
instance GHC.Generics.Selector Control.Applicative.S1_0_0WrappedMonad
instance GHC.Generics.Constructor Control.Applicative.C1_0WrappedMonad
instance GHC.Generics.Datatype Control.Applicative.D1WrappedMonad
instance GHC.Generics.Selector Control.Applicative.S1_0_0Const
instance GHC.Generics.Constructor Control.Applicative.C1_0Const
instance GHC.Generics.Datatype Control.Applicative.D1Const
instance GHC.Generics.Generic1 Control.Applicative.ZipList
instance GHC.Generics.Generic (Control.Applicative.ZipList a)
instance GHC.Base.Functor Control.Applicative.ZipList
instance GHC.Read.Read a => GHC.Read.Read (Control.Applicative.ZipList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Applicative.ZipList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Applicative.ZipList a)
instance GHC.Show.Show a => GHC.Show.Show (Control.Applicative.ZipList a)
instance GHC.Generics.Generic1 (Control.Applicative.WrappedArrow a b)
instance GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Applicative.WrappedMonad m)
instance GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
instance GHC.Generics.Generic (Control.Applicative.WrappedMonad m a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Applicative.Const a b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Applicative.Const a b)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Control.Applicative.Const a b)
instance GHC.Generics.Generic1 (Control.Applicative.Const a)
instance GHC.Generics.Generic (Control.Applicative.Const a b)
instance GHC.Read.Read a => GHC.Read.Read (Control.Applicative.Const a b)
instance GHC.Show.Show a => GHC.Show.Show (Control.Applicative.Const a b)
instance Data.Foldable.Foldable (Control.Applicative.Const m)
instance GHC.Base.Functor (Control.Applicative.Const m)
instance GHC.Base.Monoid m => GHC.Base.Applicative (Control.Applicative.Const m)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Applicative.WrappedMonad m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (Control.Applicative.WrappedMonad m)
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Applicative.WrappedArrow a b)
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
instance (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) => GHC.Base.Alternative (Control.Applicative.WrappedArrow a b)
instance GHC.Base.Applicative Control.Applicative.ZipList


-- | Class of data structures that can be traversed from left to right,
--   performing an action on each element.
--   
--   See also
--   
--   <ul>
--   <li>"Applicative Programming with Effects", by Conor McBride and Ross
--   Paterson, <i>Journal of Functional Programming</i> 18:1 (2008) 1-13,
--   online at
--   <a>http://www.soi.city.ac.uk/~ross/papers/Applicative.html</a>.</li>
--   <li>"The Essence of the Iterator Pattern", by Jeremy Gibbons and Bruno
--   Oliveira, in <i>Mathematically-Structured Functional Programming</i>,
--   2006, online at
--   <a>http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/#iterator</a>.</li>
--   <li>"An Investigation of the Laws of Traversals", by Mauro Jaskelioff
--   and Ondrej Rypacek, in <i>Mathematically-Structured Functional
--   Programming</i>, 2012, online at
--   <a>http://arxiv.org/pdf/1202.2919</a>.</li>
--   </ul>
module Data.Traversable

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Indentity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable t where traverse f = sequenceA . fmap f sequenceA = traverse id mapM = traverse sequence = sequenceA

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and and
--   collect the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldl</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldr</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | This function may be used as a value for <a>fmap</a> in a
--   <a>Functor</a> instance, provided that <a>traverse</a> is defined.
--   (Using <a>fmapDefault</a> with a <a>Traversable</a> instance defined
--   only by <a>sequenceA</a> will result in infinite recursion.)
fmapDefault :: Traversable t => (a -> b) -> t a -> t b

-- | This function may be used as a value for <a>foldMap</a> in a
--   <a>Foldable</a> instance.
foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
instance Data.Traversable.Traversable GHC.Base.Maybe
instance Data.Traversable.Traversable []
instance Data.Traversable.Traversable (Data.Either.Either a)
instance Data.Traversable.Traversable ((,) a)
instance GHC.Arr.Ix i => Data.Traversable.Traversable (GHC.Arr.Array i)
instance Data.Traversable.Traversable Data.Proxy.Proxy
instance Data.Traversable.Traversable (Control.Applicative.Const m)
instance GHC.Base.Functor (Data.Traversable.StateL s)
instance GHC.Base.Applicative (Data.Traversable.StateL s)
instance GHC.Base.Functor (Data.Traversable.StateR s)
instance GHC.Base.Applicative (Data.Traversable.StateR s)
instance GHC.Base.Functor Data.Traversable.Id
instance GHC.Base.Applicative Data.Traversable.Id


-- | The <a>Functor</a>, <a>Monad</a> and <a>MonadPlus</a> classes, with
--   some useful operations on monads.
module Control.Monad

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor f where (<$) = fmap . const
fmap :: Functor f => (a -> b) -> f a -> f b

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m where m >> k = m >>= \ _ -> k return = pure fail s = error s

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
fail :: Monad m => String -> m a

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus m where mzero = empty mplus = (<|>)

-- | the identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
mzero :: MonadPlus m => m a

-- | an associative operation
mplus :: MonadPlus m => m a -> m a -> m a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)

-- | Right-to-left Kleisli composition of monads.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)

-- | <tt><a>forever</a> act</tt> repeats the action infinitely.
forever :: (Monad m) => m a -> m b

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
join :: (Monad m) => m (m a) -> m a

-- | The sum of a collection of actions, generalizing <a>concat</a>. As of
--   base 4.8.0.0, <a>msum</a> is just <a>asum</a>, specialized to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | Direct <a>MonadPlus</a> equivalent of <tt>filter</tt>
--   <tt><tt>filter</tt></tt> = <tt>(mfilter:: (a -&gt; Bool) -&gt; [a]
--   -&gt; [a]</tt> applicable to any <a>MonadPlus</a>, for example
--   <tt>mfilter odd (Just 1) == Just 1</tt> <tt>mfilter odd (Just 2) ==
--   Nothing</tt>
mfilter :: (MonadPlus m) => (a -> Bool) -> m a -> m a

-- | This generalizes the list-based <tt>filter</tt> function.
filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state-transforming monad.
mapAndUnzipM :: (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   monads.
zipWithM :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>foldM</a> function is analogous to <tt>foldl</tt>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   </pre>
--   
--   ==
--   
--   <pre>
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: (Monad m) => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: (Monad m) => Int -> m a -> m ()

-- | <tt><a>guard</a> b</tt> is <tt><a>pure</a> ()</tt> if <tt>b</tt> is
--   <a>True</a>, and <a>empty</a> if <tt>b</tt> is <a>False</a>.
guard :: (Alternative f) => Bool -> f ()

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: (Applicative f) => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: (Applicative f) => Bool -> f () -> f ()

-- | Promote a function to a monad.
liftM :: (Monad m) => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: (Monad m) => m (a -> b) -> m a -> m b

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b


-- | This module provides access to internal garbage collection and memory
--   usage statistics. These statistics are not available unless a program
--   is run with the <tt>-T</tt> RTS flag.
--   
--   This module is GHC-only and should not be considered portable.
module GHC.Stats

-- | Global garbage collection and memory statistics.
data GCStats
GCStats :: !Int64 -> !Int64 -> !Int64 -> !Int64 -> !Int64 -> !Int64 -> !Int64 -> !Int64 -> !Int64 -> !Int64 -> !Double -> !Double -> !Double -> !Double -> !Double -> !Double -> !Int64 -> !Int64 -> GCStats

-- | Total number of bytes allocated
[bytesAllocated] :: GCStats -> !Int64

-- | Number of garbage collections performed
[numGcs] :: GCStats -> !Int64

-- | Maximum number of live bytes seen so far
[maxBytesUsed] :: GCStats -> !Int64

-- | Number of byte usage samples taken | Sum of all byte usage samples,
--   can be used with <a>numByteUsageSamples</a> to calculate averages with
--   arbitrary weighting (if you are sampling this record multiple times).
[numByteUsageSamples] :: GCStats -> !Int64
[cumulativeBytesUsed] :: GCStats -> !Int64

-- | Number of bytes copied during GC
[bytesCopied] :: GCStats -> !Int64

-- | Current number of live bytes
[currentBytesUsed] :: GCStats -> !Int64

-- | Current number of bytes lost to slop
[currentBytesSlop] :: GCStats -> !Int64

-- | Maximum number of bytes lost to slop at any one time so far
[maxBytesSlop] :: GCStats -> !Int64

-- | Maximum number of megabytes allocated | CPU time spent running mutator
--   threads. This does not include any profiling overhead or
--   initialization.
[peakMegabytesAllocated] :: GCStats -> !Int64
[mutatorCpuSeconds] :: GCStats -> !Double

-- | Wall clock time spent running mutator threads. This does not include
--   initialization.
[mutatorWallSeconds] :: GCStats -> !Double

-- | CPU time spent running GC
[gcCpuSeconds] :: GCStats -> !Double

-- | Wall clock time spent running GC
[gcWallSeconds] :: GCStats -> !Double

-- | Total CPU time elapsed since program start
[cpuSeconds] :: GCStats -> !Double

-- | Total wall clock time elapsed since start | Number of bytes copied
--   during GC, minus space held by mutable lists held by the capabilities.
--   Can be used with <a>parMaxBytesCopied</a> to determine how well
--   parallel GC utilized all cores.
[wallSeconds] :: GCStats -> !Double
[parTotBytesCopied] :: GCStats -> !Int64

-- | Sum of number of bytes copied each GC by the most active GC thread
--   each GC. The ratio of <a>parTotBytesCopied</a> divided by
--   <a>parMaxBytesCopied</a> approaches 1 for a maximally sequential run
--   and approaches the number of threads (set by the RTS flag <tt>-N</tt>)
--   for a maximally parallel run.
[parMaxBytesCopied] :: GCStats -> !Int64

-- | Retrieves garbage collection and memory statistics as of the last
--   garbage collection. If you would like your statistics as recent as
--   possible, first run a <a>performGC</a>.
getGCStats :: IO GCStats

-- | Returns whether GC stats have been enabled (with <tt>+RTS -T</tt>, for
--   example).
getGCStatsEnabled :: IO Bool
instance GHC.Read.Read GHC.Stats.GCStats
instance GHC.Show.Show GHC.Stats.GCStats


-- | Operations on lists.
module Data.List

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]

-- | Extract the first element of a list, which must be non-empty.
head :: [a] -> a

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: [a] -> [a]

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: [a] -> [a]

-- | Decompose a list into its head and tail. If the list is empty, returns
--   <a>Nothing</a>. If the list is non-empty, returns <tt><a>Just</a> (x,
--   xs)</tt>, where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.
uncons :: [a] -> Maybe (a, [a])

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | The <a>intersperse</a> function takes an element and a list and
--   `intersperses' that element between the elements of the list. For
--   example,
--   
--   <pre>
--   intersperse ',' "abcde" == "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   subsequences "abc" == ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   permutations "abc" == ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | Left-associative fold of a structure.
--   
--   <pre>
--   <a>foldl</a> f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure. but with strict application of
--   the operator.
--   
--   <pre>
--   <a>foldl</a> f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A strict version of <a>foldl1</a>
foldl1' :: (a -> a -> a) -> [a] -> a

-- | Right-associative fold of a structure.
--   
--   <pre>
--   <a>foldr</a> f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | A strictly accumulating version of <a>scanl</a>
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldl</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldr</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--    [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   dropWhileEnd isSpace "foo\n" == "foo"
--   dropWhileEnd isSpace "foo bar" == "foo bar"
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>stripPrefix</a> function drops the given prefix from a list. It
--   returns <a>Nothing</a> if the list did not start with the prefix
--   given, or <a>Just</a> the list after the prefix, if it does.
--   
--   <pre>
--   stripPrefix "foo" "foobar" == Just "bar"
--   stripPrefix "foo" "foo" == Just ""
--   stripPrefix "foo" "barfoo" == Nothing
--   stripPrefix "foo" "barfoobaz" == Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   inits "abc" == ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: [a] -> [[a]]

-- | The <a>tails</a> function returns all final segments of the argument,
--   longest first. For example,
--   
--   <pre>
--   tails "abc" == ["abc", "bc", "c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
isPrefixOf :: (Eq a) => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
isSuffixOf :: (Eq a) => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   Example:
--   
--   <pre>
--   isInfixOf "Haskell" "I really like Haskell." == True
--   isInfixOf "Ial" "I really like Haskell." == False
--   </pre>
isInfixOf :: (Eq a) => [a] -> [a] -> Bool

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if the first list is a subsequence of the second list.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt><a>elem</a> x
--   (<a>subsequences</a> y)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf ['a','d'..'z'] ['a'..'z']
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf [1..10] [10,9..0]
--   False
--   </pre>
isSubsequenceOf :: (Eq a) => [a] -> [a] -> Bool

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: (Eq a) => a -> [(a, b)] -> Maybe b

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element.
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   If one input list is short, excess elements of the longer list are
--   discarded.
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
unwords :: [String] -> String

-- | <i>O(n^2)</i>. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
nub :: (Eq a) => [a] -> [a]

-- | <a>delete</a> <tt>x</tt> removes the first occurrence of <tt>x</tt>
--   from its list argument. For example,
--   
--   <pre>
--   delete 'a' "banana" == "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: (Eq a) => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: (Eq a) => [a] -> [a] -> [a]

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   "dog" `union` "cow" == "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: (Eq a) => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: (Eq a) => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
sort :: (Ord a) => [a] -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy . comparing
--   f</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | The <a>insert</a> function takes an element and a list and inserts the
--   element into the list at the first position where it is less than or
--   equal to the next element. In particular, if the list is sorted before
--   the call, the result will also be sorted. It is a special case of
--   <a>insertBy</a>, which allows the programmer to supply their own
--   comparison function.
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | The <a>deleteBy</a> function behaves like <a>delete</a>, but takes a
--   user-supplied equality predicate.
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The <a>genericLength</a> function is an overloaded version of
--   <a>length</a>. In particular, instead of returning an <a>Int</a>, it
--   returns any type which is an instance of <a>Num</a>. It is, however,
--   less efficient than <a>length</a>.
genericLength :: (Num i) => [a] -> i

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: (Integral i) => i -> [a] -> [a]

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: (Integral i) => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: (Integral i) => i -> [a] -> ([a], [a])

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: (Integral i) => [a] -> i -> a

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: (Integral i) => i -> a -> [a]


-- | The <tt>String</tt> type and associated operations.
module Data.String

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
unwords :: [String] -> String
instance Data.String.IsString [GHC.Types.Char]


-- | A general library for representation and manipulation of versions.
--   
--   Versioning schemes are many and varied, so the version representation
--   provided by this library is intended to be a compromise between
--   complete generality, where almost no common functionality could
--   reasonably be provided, and fixing a particular versioning scheme,
--   which would probably be too restrictive.
--   
--   So the approach taken here is to provide a representation which
--   subsumes many of the versioning schemes commonly in use, and we
--   provide implementations of <a>Eq</a>, <a>Ord</a> and conversion
--   to/from <a>String</a> which will be appropriate for some applications,
--   but not all.
module Data.Version

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data Version
Version :: [Int] -> [String] -> Version

-- | The numeric branch for this version. This reflects the fact that most
--   software versions are tree-structured; there is a main trunk which is
--   tagged with versions at various points (1,2,3...), and the first
--   branch off the trunk after version 3 is 3.1, the second branch off the
--   trunk after version 3 is 3.2, and so on. The tree can be branched
--   arbitrarily, just by adding more digits.
--   
--   We represent the branch as a list of <a>Int</a>, so version 3.2.1
--   becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of
--   <a>Ord</a> for <tt>[Int]</tt>) gives the natural ordering of branches.
[versionBranch] :: Version -> [Int]

-- | A version can be tagged with an arbitrary list of strings. The
--   interpretation of the list of tags is entirely dependent on the entity
--   that this version applies to.

-- | <i>Deprecated: See GHC ticket #2496</i>
[versionTags] :: Version -> [String]

-- | Provides one possible concrete representation for <a>Version</a>. For
--   a version with <a>versionBranch</a> <tt>= [1,2,3]</tt> and
--   <a>versionTags</a> <tt>= ["tag1","tag2"]</tt>, the output will be
--   <tt>1.2.3-tag1-tag2</tt>.
showVersion :: Version -> String

-- | A parser for versions in the format produced by <a>showVersion</a>.
parseVersion :: ReadP Version

-- | Construct tag-less <a>Version</a>
makeVersion :: [Int] -> Version
instance GHC.Show.Show Data.Version.Version
instance GHC.Read.Read Data.Version.Version
instance GHC.Classes.Eq Data.Version.Version
instance GHC.Classes.Ord Data.Version.Version


-- | "Scrap your boilerplate" --- Generic programming in Haskell. See
--   <a>http://www.haskell.org/haskellwiki/Research_papers/Generics#Scrap_your_boilerplate.21</a>.
--   This module provides the <a>Data</a> class with its primitives for
--   generic programming, along with instances for many datatypes. It
--   corresponds to a merge between the previous
--   <a>Data.Generics.Basics</a> and almost all of
--   <a>Data.Generics.Instances</a>. The instances that are not present in
--   this module were moved to the <tt>Data.Generics.Instances</tt> module
--   in the <tt>syb</tt> package.
--   
--   For more information, please visit the new SYB wiki:
--   <a>http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB</a>.
module Data.Data

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type withing generic folding is <tt>r
--   -&gt; r</tt>. So the result of folding is a function to which we
--   finally pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a where gfoldl _ z = z dataCast1 _ = Nothing dataCast2 _ = Nothing gmapT f x0 = unID (gfoldl k ID x0) where k :: Data d => ID (d -> b) -> d -> ID b k (ID c) x = ID (c (f x)) gmapQl o r f = unCONST . gfoldl k z where k :: Data d => CONST r (d -> b) -> d -> CONST r b k c x = CONST $ (unCONST c) `o` f x z :: g -> CONST r g z _ = CONST r gmapQr o r0 f x0 = unQr (gfoldl k (const (Qr id)) x0) r0 where k :: Data d => Qr r (d -> b) -> d -> Qr r b k (Qr c) x = Qr (\ r -> c (f x `o` r)) gmapQ f = gmapQr (:) [] f gmapQi i f x = case gfoldl k z x of { Qi _ q -> fromJust q } where k :: Data d => Qi u (d -> b) -> d -> Qi u b k (Qi i' q) a = Qi (i' + 1) (if i == i' then Just (f a) else q) z :: g -> Qi q g z _ = Qi 0 Nothing gmapM f = gfoldl k return where k :: Data d => m (d -> b) -> d -> m b k c x = do { c' <- c; x' <- f x; return (c' x') } gmapMp f x = unMp (gfoldl k z x) >>= \ (x', b) -> if b then return x' else mzero where z :: g -> Mp m g z g = Mp (return (g, False)) k :: Data d => Mp m (d -> b) -> d -> Mp m b k (Mp c) y = Mp (c >>= \ (h, b) -> (f y >>= \ y' -> return (h y', True)) `mplus` return (h y, b)) gmapMo f x = unMp (gfoldl k z x) >>= \ (x', b) -> if b then return x' else mzero where z :: g -> Mp m g z g = Mp (return (g, False)) k :: Data d => Mp m (d -> b) -> d -> Mp m b k (Mp c) y = Mp (c >>= \ (h, b) -> if b then return (h y, b) else (f y >>= \ y' -> return (h y', True)) `mplus` return (h y, b))

-- | Left-associative fold operation for constructor applications.
--   
--   The type of <a>gfoldl</a> is a headache, but operationally it is a
--   simple generalisation of a list fold.
--   
--   The default definition for <a>gfoldl</a> is <tt><a>const</a>
--   <a>id</a></tt>, which is suitable for abstract datatypes with no
--   substructures.
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a

-- | Unfolding constructor applications
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a

-- | Obtaining the constructor from a given datum. For proper terms, this
--   is meant to be the top-level constructor. Primitive datatypes are here
--   viewed as potentially infinite sets of values (i.e., constructors).
toConstr :: Data a => a -> Constr

-- | The outer type constructor of the type
dataTypeOf :: Data a => a -> DataType

-- | Mediate types and unary type constructors. In <a>Data</a> instances of
--   the form <tt>T a</tt>, <a>dataCast1</a> should be defined as
--   <a>gcast1</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for non-unary type constructors.
dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c a)

-- | Mediate types and binary type constructors. In <a>Data</a> instances
--   of the form <tt>T a b</tt>, <a>dataCast2</a> should be defined as
--   <a>gcast2</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for non-binary type constructors.
dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)

-- | A generic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to an identity datatype constructor, using
--   the isomorphism pair as injection and projection.
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a

-- | A generic query with a left-associative binary operator
gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query with a right-associative binary operator
gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query that processes the immediate subterms and returns a
--   list of results. The list is given in the same order as originally
--   specified in the declaration of the data constructors.
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]

-- | A generic query that processes one child by index (zero-based)
gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u

-- | A generic monadic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to the monad datatype constructor, defining
--   injection and projection using <a>return</a> and <a>&gt;&gt;=</a>.
gmapM :: (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of at least one immediate subterm does not fail
gmapMp :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of one immediate subterm with success
gmapMo :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Representation of datatypes. A package of constructor representations
--   with names of type and module.
data DataType

-- | Constructs an algebraic datatype
mkDataType :: String -> [Constr] -> DataType

-- | Constructs the <a>Int</a> type
mkIntType :: String -> DataType

-- | Constructs the <a>Float</a> type
mkFloatType :: String -> DataType

-- | Constructs the <a>Char</a> type
mkCharType :: String -> DataType

-- | Constructs a non-representation for a non-representable type
mkNoRepType :: String -> DataType

-- | Gets the type constructor including the module
dataTypeName :: DataType -> String

-- | Public representation of datatypes
data DataRep
AlgRep :: [Constr] -> DataRep
IntRep :: DataRep
FloatRep :: DataRep
CharRep :: DataRep
NoRep :: DataRep

-- | Gets the public presentation of a datatype
dataTypeRep :: DataType -> DataRep

-- | Look up a constructor by its representation
repConstr :: DataType -> ConstrRep -> Constr

-- | Test for an algebraic type
isAlgType :: DataType -> Bool

-- | Gets the constructors of an algebraic datatype
dataTypeConstrs :: DataType -> [Constr]

-- | Gets the constructor for an index (algebraic datatypes only)
indexConstr :: DataType -> ConIndex -> Constr

-- | Gets the maximum constructor index of an algebraic datatype
maxConstrIndex :: DataType -> ConIndex

-- | Test for a non-representable type
isNorepType :: DataType -> Bool

-- | Representation of constructors. Note that equality on constructors
--   with different types may not work -- i.e. the constructors for
--   <a>False</a> and <a>Nothing</a> may compare equal.
data Constr

-- | Unique index for datatype constructors, counting from 1 in the order
--   they are given in the program text.
type ConIndex = Int

-- | Fixity of constructors
data Fixity
Prefix :: Fixity
Infix :: Fixity

-- | Constructs a constructor
mkConstr :: DataType -> String -> [String] -> Fixity -> Constr
mkIntegralConstr :: (Integral a, Show a) => DataType -> a -> Constr
mkRealConstr :: (Real a, Show a) => DataType -> a -> Constr

-- | Makes a constructor for <a>Char</a>.
mkCharConstr :: DataType -> Char -> Constr

-- | Gets the datatype of a constructor
constrType :: Constr -> DataType

-- | Public representation of constructors
data ConstrRep
AlgConstr :: ConIndex -> ConstrRep
IntConstr :: Integer -> ConstrRep
FloatConstr :: Rational -> ConstrRep
CharConstr :: Char -> ConstrRep

-- | Gets the public presentation of constructors
constrRep :: Constr -> ConstrRep

-- | Gets the field labels of a constructor. The list of labels is returned
--   in the same order as they were given in the original constructor
--   declaration.
constrFields :: Constr -> [String]

-- | Gets the fixity of a constructor
constrFixity :: Constr -> Fixity

-- | Gets the index of a constructor (algebraic datatypes only)
constrIndex :: Constr -> ConIndex

-- | Gets the string for a constructor
showConstr :: Constr -> String

-- | Lookup a constructor via a string
readConstr :: DataType -> String -> Maybe Constr

-- | Gets the unqualified type constructor: drop *.*.*... before name
tyconUQname :: String -> String

-- | Gets the module of a type constructor: take *.*.*... before name
tyconModule :: String -> String

-- | Build a term skeleton
fromConstr :: Data a => Constr -> a

-- | Build a term and use a generic function for subterms
fromConstrB :: Data a => (forall d. Data d => d) -> Constr -> a

-- | Monadic variation on <a>fromConstrB</a>
fromConstrM :: (Monad m, Data a) => (forall d. Data d => m d) -> Constr -> m a
instance GHC.Show.Show Data.Data.DataRep
instance GHC.Classes.Eq Data.Data.DataRep
instance GHC.Show.Show Data.Data.DataType
instance GHC.Show.Show Data.Data.Fixity
instance GHC.Classes.Eq Data.Data.Fixity
instance GHC.Show.Show Data.Data.ConstrRep
instance GHC.Classes.Eq Data.Data.ConstrRep
instance GHC.Show.Show Data.Data.Constr
instance GHC.Classes.Eq Data.Data.Constr
instance Data.Data.Data GHC.Types.Bool
instance Data.Data.Data GHC.Types.Char
instance Data.Data.Data GHC.Types.Float
instance Data.Data.Data GHC.Types.Double
instance Data.Data.Data GHC.Types.Int
instance Data.Data.Data GHC.Integer.Type.Integer
instance Data.Data.Data GHC.Int.Int8
instance Data.Data.Data GHC.Int.Int16
instance Data.Data.Data GHC.Int.Int32
instance Data.Data.Data GHC.Int.Int64
instance Data.Data.Data GHC.Types.Word
instance Data.Data.Data GHC.Word.Word8
instance Data.Data.Data GHC.Word.Word16
instance Data.Data.Data GHC.Word.Word32
instance Data.Data.Data GHC.Word.Word64
instance (Data.Data.Data a, GHC.Real.Integral a) => Data.Data.Data (GHC.Real.Ratio a)
instance Data.Data.Data a => Data.Data.Data [a]
instance Data.Data.Data a => Data.Data.Data (GHC.Base.Maybe a)
instance Data.Data.Data GHC.Types.Ordering
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Either.Either a b)
instance Data.Data.Data ()
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (a, b)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c) => Data.Data.Data (a, b, c)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d) => Data.Data.Data (a, b, c, d)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e) => Data.Data.Data (a, b, c, d, e)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f) => Data.Data.Data (a, b, c, d, e, f)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f, Data.Data.Data g) => Data.Data.Data (a, b, c, d, e, f, g)
instance (Data.Data.Data a, Data.Typeable.Internal.Typeable a) => Data.Data.Data (GHC.Ptr.Ptr a)
instance (Data.Data.Data a, Data.Typeable.Internal.Typeable a) => Data.Data.Data (GHC.ForeignPtr.ForeignPtr a)
instance (Data.Typeable.Internal.Typeable a, Data.Data.Data a, Data.Data.Data b, GHC.Arr.Ix a) => Data.Data.Data (GHC.Arr.Array a b)
instance Data.Data.Data t => Data.Data.Data (Data.Proxy.Proxy t)
instance (a ~ b, Data.Data.Data a) => Data.Data.Data (a Data.Type.Equality.:~: b)
instance (GHC.Types.Coercible a b, Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Type.Coercion.Coercion a b)
instance Data.Data.Data Data.Version.Version


-- | The arbitrary-precision <a>Natural</a> number type.
--   
--   <b>Note</b>: This is an internal GHC module with an API subject to
--   change. It's recommended use the <a>Numeric.Natural</a> module to
--   import the <a>Natural</a> type.
module GHC.Natural

-- | Type representing arbitrary-precision non-negative integers.
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>.
data Natural

-- | in <tt>[0, maxBound::Word]</tt>
NatS# :: GmpLimb# -> Natural

-- | in <tt>]maxBound::Word, +inf[</tt>
--   
--   <b>Invariant</b>: <a>NatJ#</a> is used <i>iff</i> value doesn't fit in
--   <a>NatS#</a> constructor.
NatJ# :: {-# UNPACK #-} !BigNat -> Natural

-- | Test whether all internal invariants are satisfied by <a>Natural</a>
--   value
--   
--   This operation is mostly useful for test-suites and/or code which
--   constructs <a>Integer</a> values directly.
isValidNatural :: Natural -> Bool

-- | Construct <a>Natural</a> from <a>Word</a> value.
wordToNatural :: Word -> Natural

-- | Try downcasting <a>Natural</a> to <a>Word</a> value. Returns
--   <a>Nothing</a> if value doesn't fit in <a>Word</a>.
naturalToWordMaybe :: Natural -> Maybe Word

-- | <a>Natural</a> subtraction. Returns <a>Nothing</a>s for non-positive
--   results.
minusNaturalMaybe :: Natural -> Natural -> Maybe Natural

-- | "<tt><a>powModNatural</a> <i>b</i> <i>e</i> <i>m</i></tt>" computes
--   base <tt><i>b</i></tt> raised to exponent <tt><i>e</i></tt> modulo
--   <tt><i>m</i></tt>.
powModNatural :: Natural -> Natural -> Natural -> Natural
instance GHC.Classes.Ord GHC.Natural.Natural
instance GHC.Classes.Eq GHC.Natural.Natural
instance GHC.Show.Show GHC.Natural.Natural
instance GHC.Read.Read GHC.Natural.Natural
instance GHC.Num.Num GHC.Natural.Natural
instance GHC.Real.Real GHC.Natural.Natural
instance GHC.Enum.Enum GHC.Natural.Natural
instance GHC.Real.Integral GHC.Natural.Natural
instance GHC.Arr.Ix GHC.Natural.Natural
instance Data.Bits.Bits GHC.Natural.Natural
instance Data.Data.Data GHC.Natural.Natural


-- | The arbitrary-precision <a>Natural</a> number type.
module Numeric.Natural

-- | Type representing arbitrary-precision non-negative integers.
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>.
data Natural


-- | Accessors to GHC RTS flags. Descriptions of flags can be seen in
--   <a>GHC User's Guide</a>, or by running RTS help message using <tt>+RTS
--   --help</tt>.
module GHC.RTS.Flags

-- | <tt><tt>Time</tt></tt> is defined as a <tt><tt>StgWord64</tt></tt> in
--   <tt>stg/Types.h</tt>
type RtsTime = Word64

-- | <tt><tt>nat</tt></tt> defined in <tt>rts/Types.h</tt>
type RtsNat = Word32

-- | Parameters of the runtime system
data RTSFlags
RTSFlags :: GCFlags -> ConcFlags -> MiscFlags -> DebugFlags -> CCFlags -> ProfFlags -> TraceFlags -> TickyFlags -> RTSFlags
[gcFlags] :: RTSFlags -> GCFlags
[concurrentFlags] :: RTSFlags -> ConcFlags
[miscFlags] :: RTSFlags -> MiscFlags
[debugFlags] :: RTSFlags -> DebugFlags
[costCentreFlags] :: RTSFlags -> CCFlags
[profilingFlags] :: RTSFlags -> ProfFlags
[traceFlags] :: RTSFlags -> TraceFlags
[tickyFlags] :: RTSFlags -> TickyFlags

-- | Should we produce a summary of the garbage collector statistics after
--   the program has exited?
data GiveGCStats
NoGCStats :: GiveGCStats
CollectGCStats :: GiveGCStats
OneLineGCStats :: GiveGCStats
SummaryGCStats :: GiveGCStats
VerboseGCStats :: GiveGCStats

-- | Parameters of the garbage collector.
data GCFlags
GCFlags :: Maybe FilePath -> GiveGCStats -> RtsNat -> RtsNat -> RtsNat -> RtsNat -> RtsNat -> RtsNat -> RtsNat -> RtsNat -> Bool -> Double -> Double -> RtsNat -> RtsNat -> Bool -> Bool -> Double -> Bool -> Bool -> Bool -> RtsTime -> Bool -> Word -> Word -> GCFlags
[statsFile] :: GCFlags -> Maybe FilePath
[giveStats] :: GCFlags -> GiveGCStats
[maxStkSize] :: GCFlags -> RtsNat
[initialStkSize] :: GCFlags -> RtsNat
[stkChunkSize] :: GCFlags -> RtsNat
[stkChunkBufferSize] :: GCFlags -> RtsNat
[maxHeapSize] :: GCFlags -> RtsNat
[minAllocAreaSize] :: GCFlags -> RtsNat
[minOldGenSize] :: GCFlags -> RtsNat
[heapSizeSuggestion] :: GCFlags -> RtsNat
[heapSizeSuggestionAuto] :: GCFlags -> Bool
[oldGenFactor] :: GCFlags -> Double
[pcFreeHeap] :: GCFlags -> Double
[generations] :: GCFlags -> RtsNat
[steps] :: GCFlags -> RtsNat
[squeezeUpdFrames] :: GCFlags -> Bool

-- | True <a>=</a> "compact all the time"
[compact] :: GCFlags -> Bool
[compactThreshold] :: GCFlags -> Double

-- | use "mostly mark-sweep" instead of copying for the oldest generation
[sweep] :: GCFlags -> Bool
[ringBell] :: GCFlags -> Bool
[frontpanel] :: GCFlags -> Bool
[idleGCDelayTime] :: GCFlags -> RtsTime
[doIdleGC] :: GCFlags -> Bool

-- | address to ask the OS for memory
[heapBase] :: GCFlags -> Word
[allocLimitGrace] :: GCFlags -> Word

-- | Parameters concerning context switching
data ConcFlags
ConcFlags :: RtsTime -> Int -> ConcFlags
[ctxtSwitchTime] :: ConcFlags -> RtsTime
[ctxtSwitchTicks] :: ConcFlags -> Int

-- | Miscellaneous parameters
data MiscFlags
MiscFlags :: RtsTime -> Bool -> Bool -> Word -> MiscFlags
[tickInterval] :: MiscFlags -> RtsTime
[installSignalHandlers] :: MiscFlags -> Bool
[machineReadable] :: MiscFlags -> Bool

-- | address to ask the OS for memory for the linker, 0 ==&gt; off
[linkerMemBase] :: MiscFlags -> Word

-- | Flags to control debugging output &amp; extra checking in various
--   subsystems.
data DebugFlags
DebugFlags :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> DebugFlags

-- | <tt>s</tt>
[scheduler] :: DebugFlags -> Bool

-- | <tt>i</tt>
[interpreter] :: DebugFlags -> Bool

-- | <tt>w</tt>
[weak] :: DebugFlags -> Bool

-- | <tt>G</tt>
[gccafs] :: DebugFlags -> Bool

-- | <tt>g</tt>
[gc] :: DebugFlags -> Bool

-- | <tt>b</tt>
[block_alloc] :: DebugFlags -> Bool

-- | <tt>S</tt>
[sanity] :: DebugFlags -> Bool

-- | <tt>t</tt>
[stable] :: DebugFlags -> Bool

-- | <tt>p</tt>
[prof] :: DebugFlags -> Bool

-- | <tt>l</tt> the object linker
[linker] :: DebugFlags -> Bool

-- | <tt>a</tt>
[apply] :: DebugFlags -> Bool

-- | <tt>m</tt>
[stm] :: DebugFlags -> Bool

-- | <tt>z</tt> stack squeezing &amp; lazy blackholing
[squeeze] :: DebugFlags -> Bool

-- | <tt>c</tt> coverage
[hpc] :: DebugFlags -> Bool

-- | <tt>r</tt>
[sparks] :: DebugFlags -> Bool

-- | Should the RTS produce a cost-center summary?
data DoCostCentres
CostCentresNone :: DoCostCentres
CostCentresSummary :: DoCostCentres
CostCentresVerbose :: DoCostCentres
CostCentresAll :: DoCostCentres
CostCentresXML :: DoCostCentres

-- | Parameters pertaining to the cost-center profiler.
data CCFlags
CCFlags :: DoCostCentres -> Int -> Int -> CCFlags
[doCostCentres] :: CCFlags -> DoCostCentres
[profilerTicks] :: CCFlags -> Int
[msecsPerTick] :: CCFlags -> Int

-- | What sort of heap profile are we collecting?
data DoHeapProfile
NoHeapProfiling :: DoHeapProfile
HeapByCCS :: DoHeapProfile
HeapByMod :: DoHeapProfile
HeapByDescr :: DoHeapProfile
HeapByType :: DoHeapProfile
HeapByRetainer :: DoHeapProfile
HeapByLDV :: DoHeapProfile
HeapByClosureType :: DoHeapProfile

-- | Parameters of the cost-center profiler
data ProfFlags
ProfFlags :: DoHeapProfile -> RtsTime -> Word -> Bool -> Bool -> Word -> Word -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> ProfFlags
[doHeapProfile] :: ProfFlags -> DoHeapProfile

-- | time between samples
[heapProfileInterval] :: ProfFlags -> RtsTime

-- | ticks between samples (derived)
[heapProfileIntervalTicks] :: ProfFlags -> Word
[includeTSOs] :: ProfFlags -> Bool
[showCCSOnException] :: ProfFlags -> Bool
[maxRetainerSetSize] :: ProfFlags -> Word
[ccsLength] :: ProfFlags -> Word
[modSelector] :: ProfFlags -> Maybe String
[descrSelector] :: ProfFlags -> Maybe String
[typeSelector] :: ProfFlags -> Maybe String
[ccSelector] :: ProfFlags -> Maybe String
[ccsSelector] :: ProfFlags -> Maybe String
[retainerSelector] :: ProfFlags -> Maybe String
[bioSelector] :: ProfFlags -> Maybe String

-- | Is event tracing enabled?
data DoTrace

-- | no tracing
TraceNone :: DoTrace

-- | send tracing events to the event log
TraceEventLog :: DoTrace

-- | send tracing events to <tt>stderr</tt>
TraceStderr :: DoTrace

-- | Parameters pertaining to event tracing
data TraceFlags
TraceFlags :: DoTrace -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> TraceFlags
[tracing] :: TraceFlags -> DoTrace

-- | show timestamp in stderr output
[timestamp] :: TraceFlags -> Bool

-- | trace scheduler events
[traceScheduler] :: TraceFlags -> Bool

-- | trace GC events
[traceGc] :: TraceFlags -> Bool

-- | trace spark events by a sampled method
[sparksSampled] :: TraceFlags -> Bool

-- | trace spark events 100% accurately
[sparksFull] :: TraceFlags -> Bool

-- | trace user events (emitted from Haskell code)
[user] :: TraceFlags -> Bool

-- | Parameters pertaining to ticky-ticky profiler
data TickyFlags
TickyFlags :: Bool -> Maybe FilePath -> TickyFlags
[showTickyStats] :: TickyFlags -> Bool
[tickyFile] :: TickyFlags -> Maybe FilePath
getRTSFlags :: IO RTSFlags
getGCFlags :: IO GCFlags
getConcFlags :: IO ConcFlags
getMiscFlags :: IO MiscFlags
getDebugFlags :: IO DebugFlags
getCCFlags :: IO CCFlags
getProfFlags :: IO ProfFlags
getTraceFlags :: IO TraceFlags
getTickyFlags :: IO TickyFlags
instance GHC.Show.Show GHC.RTS.Flags.RTSFlags
instance GHC.Show.Show GHC.RTS.Flags.TickyFlags
instance GHC.Show.Show GHC.RTS.Flags.TraceFlags
instance GHC.Show.Show GHC.RTS.Flags.DoTrace
instance GHC.Show.Show GHC.RTS.Flags.ProfFlags
instance GHC.Show.Show GHC.RTS.Flags.DoHeapProfile
instance GHC.Show.Show GHC.RTS.Flags.CCFlags
instance GHC.Show.Show GHC.RTS.Flags.DoCostCentres
instance GHC.Show.Show GHC.RTS.Flags.DebugFlags
instance GHC.Show.Show GHC.RTS.Flags.MiscFlags
instance GHC.Show.Show GHC.RTS.Flags.ConcFlags
instance GHC.Show.Show GHC.RTS.Flags.GCFlags
instance GHC.Show.Show GHC.RTS.Flags.GiveGCStats
instance GHC.Enum.Enum GHC.RTS.Flags.GiveGCStats
instance GHC.Enum.Enum GHC.RTS.Flags.DoCostCentres
instance GHC.Enum.Enum GHC.RTS.Flags.DoHeapProfile
instance GHC.Enum.Enum GHC.RTS.Flags.DoTrace

module GHC.Fingerprint
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
fingerprint0 :: Fingerprint
fingerprintData :: Ptr Word8 -> Int -> IO Fingerprint
fingerprintString :: String -> Fingerprint
fingerprintFingerprints :: [Fingerprint] -> Fingerprint

-- | Computes the hash of a given file. This function loops over the
--   handle, running in constant memory.
getFileHash :: FilePath -> IO Fingerprint


-- | This module provides scalable event notification for file descriptors
--   and timeouts.
--   
--   This module should be considered GHC internal.
--   
--   <ul>
--   
--   <li>---------------------------------------------------------------------------</li>
--   </ul>
module GHC.Event

-- | The event manager state.
data EventManager

-- | The event manager state.
data TimerManager

-- | Retrieve the system event manager for the capability on which the
--   calling thread is running.
--   
--   This function always returns <a>Just</a> the current thread's event
--   manager when using the threaded RTS and <a>Nothing</a> otherwise.
getSystemEventManager :: IO (Maybe EventManager)

-- | Create a new event manager.
new :: IO EventManager
getSystemTimerManager :: IO TimerManager

-- | An I/O event.
data Event

-- | Data is available to be read.
evtRead :: Event

-- | The file descriptor is ready to accept a write.
evtWrite :: Event

-- | Callback invoked on I/O events.
type IOCallback = FdKey -> Event -> IO ()

-- | A file descriptor registration cookie.
data FdKey

-- | The lifetime of an event registration.
data Lifetime

-- | the registration will be active for only one event
OneShot :: Lifetime

-- | the registration will trigger multiple times
MultiShot :: Lifetime

-- | <tt>registerFd mgr cb fd evs lt</tt> registers interest in the events
--   <tt>evs</tt> on the file descriptor <tt>fd</tt> for lifetime
--   <tt>lt</tt>. <tt>cb</tt> is called for each event that occurs. Returns
--   a cookie that can be handed to <a>unregisterFd</a>.
registerFd :: EventManager -> IOCallback -> Fd -> Event -> Lifetime -> IO FdKey

-- | Drop a previous file descriptor registration.
unregisterFd :: EventManager -> FdKey -> IO ()

-- | Drop a previous file descriptor registration, without waking the event
--   manager thread. The return value indicates whether the event manager
--   ought to be woken.
unregisterFd_ :: EventManager -> FdKey -> IO Bool

-- | Close a file descriptor in a race-safe way.
closeFd :: EventManager -> (Fd -> IO ()) -> Fd -> IO ()

-- | Callback invoked on timeout events.
type TimeoutCallback = IO ()

-- | A timeout registration cookie.
data TimeoutKey

-- | Register a timeout in the given number of microseconds. The returned
--   <a>TimeoutKey</a> can be used to later unregister or update the
--   timeout. The timeout is automatically unregistered after the given
--   time has passed.
registerTimeout :: TimerManager -> Int -> TimeoutCallback -> IO TimeoutKey

-- | Update an active timeout to fire in the given number of microseconds.
updateTimeout :: TimerManager -> TimeoutKey -> Int -> IO ()

-- | Unregister an active timeout.
unregisterTimeout :: TimerManager -> TimeoutKey -> IO ()


-- | This module is an internal GHC module. It declares the constants used
--   in the implementation of type-level natural numbers. The programmer
--   interface for working with type-level naturals should be defined in a
--   separate library.
module GHC.TypeLits

-- | (Kind) This is the kind of type-level natural numbers.
data Nat

-- | (Kind) This is the kind of type-level symbols.
data Symbol

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)

natVal :: KnownNat n => proxy n -> Integer

natVal' :: KnownNat n => Proxy# n -> Integer

-- | This class gives the string associated with a type-level symbol. There
--   are instances of the class for every concrete literal: "hello", etc.
class KnownSymbol (n :: Symbol)

symbolVal :: KnownSymbol n => proxy n -> String

symbolVal' :: KnownSymbol n => Proxy# n -> String

-- | This type represents unknown type-level natural numbers.
data SomeNat

SomeNat :: (Proxy n) -> SomeNat

-- | This type represents unknown type-level symbols.
data SomeSymbol

SomeSymbol :: (Proxy n) -> SomeSymbol

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Integer -> Maybe SomeNat

-- | Convert a string into an unknown type-level symbol.
someSymbolVal :: String -> SomeSymbol

-- | We either get evidence that this function was instantiated with the
--   same type-level numbers, or <a>Nothing</a>.
sameNat :: (KnownNat a, KnownNat b) => Proxy a -> Proxy b -> Maybe (a :~: b)

-- | We either get evidence that this function was instantiated with the
--   same type-level symbols, or <a>Nothing</a>.
sameSymbol :: (KnownSymbol a, KnownSymbol b) => Proxy a -> Proxy b -> Maybe (a :~: b)

-- | Comparison of type-level naturals, as a constraint.
type (<=) x y = (x <=? y) ~ True

-- | Comparison of type-level naturals, as a function. NOTE: The
--   functionality for this function should be subsumed by <a>CmpNat</a>,
--   so this might go away in the future. Please let us know, if you
--   encounter discrepancies between the two.

-- | Addition of type-level naturals.

-- | Multiplication of type-level naturals.

-- | Exponentiation of type-level naturals.

-- | Subtraction of type-level naturals.

-- | Comparison of type-level naturals, as a function.

-- | Comparison of type-level symbols, as a function.
instance GHC.Classes.Eq GHC.TypeLits.SomeNat
instance GHC.Classes.Ord GHC.TypeLits.SomeNat
instance GHC.Show.Show GHC.TypeLits.SomeNat
instance GHC.Read.Read GHC.TypeLits.SomeNat
instance GHC.Classes.Eq GHC.TypeLits.SomeSymbol
instance GHC.Classes.Ord GHC.TypeLits.SomeSymbol
instance GHC.Show.Show GHC.TypeLits.SomeSymbol
instance GHC.Read.Read GHC.TypeLits.SomeSymbol


module GHC.IP

-- | The syntax <tt>?x :: a</tt> is desugared into <tt>IP "x" a</tt>
class IP (x :: Symbol) a | x -> a
ip :: IP x a => a


-- | The Prelude: a standard module. The Prelude is imported by default
--   into all Haskell modules unless either there is an explicit import
--   statement for it, or the NoImplicitPrelude extension is enabled.
module Prelude
data Bool :: *
False :: Bool
True :: Bool

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <tt>show</tt> to a <tt>Maybe Int</tt>. If we have <tt>Just
--   n</tt>, we want to show the underlying <a>Int</a> <tt>n</tt>. But if
--   we have <a>Nothing</a>, we return the empty string instead of (for
--   example) "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <tt>length</tt> function (if we have a <a>String</a>) or the
--   "times-two" function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c
data Ordering :: *
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
uncurry :: (a -> b -> c) -> ((a, b) -> c)

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a where succ = toEnum . (+ 1) . fromEnum pred = toEnum . (subtract 1) . fromEnum enumFrom x = map toEnum [fromEnum x .. ] enumFromThen x y = map toEnum [fromEnum x, fromEnum y .. ] enumFromTo x y = map toEnum [fromEnum x .. fromEnum y] enumFromThenTo x1 x2 y = map toEnum [fromEnum x1, fromEnum x2 .. fromEnum y]

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt>.
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt>.
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt>.
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt>.
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer :: *

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word :: *

-- | Basic numeric class.
class Num a where x - y = x + negate y negate x = 0 - x
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Integral numbers, supporting integer division.
class (Real a, Enum a) => Integral a where n `quot` d = q where (q, _) = quotRem n d n `rem` d = r where (_, r) = quotRem n d n `div` d = q where (q, _) = divMod n d n `mod` d = r where (_, r) = divMod n d divMod n d = if signum r == negate (signum d) then (q - 1, r + d) else qr where qr@(q, r) = quotRem n d

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer

-- | Fractional numbers, supporting real division.
class (Num a) => Fractional a where recip x = 1 / x x / y = x * recip y

-- | fractional division
(/) :: Fractional a => a -> a -> a

-- | reciprocal fraction
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a

-- | Trigonometric and hyperbolic functions and related functions.
class (Fractional a) => Floating a where x ** y = exp (log x * y) logBase x y = log y / log x sqrt x = x ** 0.5 tan x = sin x / cos x tanh x = sinh x / cosh x
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a where truncate x = m where (m, _) = properFraction x round x = let (n, r) = properFraction x m = if r < 0 then n - 1 else n + 1 in case signum (abs r - 0.5) of { -1 -> n 0 -> if even n then n else m 1 -> m _ -> error "round default defn: Bad value" } ceiling x = if r > 0 then n + 1 else n where (n, r) = properFraction x floor x = if r < 0 then n - 1 else n where (n, r) = properFraction x

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a where exponent x = if m == 0 then 0 else n + floatDigits x where (m, n) = decodeFloat x significand x = encodeFloat m (negate (floatDigits x)) where (m, _) = decodeFloat x scaleFloat 0 x = x scaleFloat k x | isFix = x | otherwise = encodeFloat m (n + clamp b k) where (m, n) = decodeFloat x (l, h) = floatRange x d = floatDigits x b = h - l + 4 * d isFix = x == 0 || isNaN x || isInfinite x atan2 y x | x > 0 = atan (y / x) | x == 0 && y > 0 = pi / 2 | x < 0 && y > 0 = pi + atan (y / x) | (x <= 0 && y < 0) || (x < 0 && isNegativeZero y) || (isNegativeZero x && isNegativeZero y) = - atan2 (- y) x | y == 0 && (x < 0 || isNegativeZero x) = pi | x == 0 && y == 0 = y | otherwise = x + y

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><tt>uncurry</tt> <a>encodeFloat</a> (<a>decodeFloat</a> x) =
--   x</tt>. <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: (Num a) => a -> a -> a
even :: (Integral a) => a -> Bool
odd :: (Integral a) => a -> Bool

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: (Integral a) => a -> a -> a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: (Integral a) => a -> a -> a

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
class Monoid a where mconcat = foldr mappend mempty

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid. For most types, the default definition
--   for <a>mconcat</a> will be used, but the function is included in the
--   class definition so that an optimized version can be provided for
--   specific types.
mconcat :: Monoid a => [a] -> a

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor f where (<$) = fmap . const
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results
--   (<a>&lt;*&gt;</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of these
--   functions satisfying the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = <a>pure</a> (<a>const</a> <a>id</a>)
--   <a>&lt;*&gt;</a> u <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>pure</a> <a>const</a> <a>&lt;*&gt;</a>
--   u <a>&lt;*&gt;</a> v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative f where a1 *> a2 = (id <$ a1) <*> a2 (<*) = liftA2 const

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m where m >> k = m >>= \ _ -> k return = pure fail s = error s

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
fail :: Monad m => String -> m a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable t where fold = foldMap id foldMap f = foldr (mappend . f) mempty foldr f z t = appEndo (foldMap (Endo #. f) t) z foldr' f z0 xs = foldl f' id xs z0 where f' k x z = k $! f x z foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z foldl' f z0 xs = foldr f' id xs z0 where f' x k z = k $! f z x foldr1 f xs = fromMaybe (error "foldr1: empty structure") (foldr mf Nothing xs) where mf x m = Just (case m of { Nothing -> x Just y -> f x y }) foldl1 f xs = fromMaybe (error "foldl1: empty structure") (foldl mf Nothing xs) where mf m y = Just (case m of { Nothing -> y Just x -> f x y }) toList t = build (\ c n -> foldr c n t) null = foldr (\ _ _ -> False) True length = foldl' (\ c _ -> c + 1) 0 elem = any . (==) maximum = fromMaybe (error "maximum: empty structure") . getMax . foldMap (Max #. (Just :: a -> Maybe a)) minimum = fromMaybe (error "minimum: empty structure") . getMin . foldMap (Min #. (Just :: a -> Maybe a)) sum = getSum #. foldMap Sum product = getProduct #. foldMap Product

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   <pre>
--   <a>foldr</a> f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   <pre>
--   <a>foldl</a> f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Indentity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable t where traverse f = sequenceA . fmap f sequenceA = traverse id mapM = traverse sequence = sequenceA

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and and
--   collect the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Identity function.
id :: a -> a

-- | Constant function.
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
flip :: (a -> b -> c) -> b -> a -> c

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
($) :: (a -> b) -> a -> b

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | <a>error</a> stops execution and displays an error message.
error :: [Char] -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: a

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. <tt>seq</tt> is usually introduced to
--   improve performance by avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: a -> b -> b

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: (a -> b) -> a -> b

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | Extract the first element of a list, which must be non-empty.
head :: [a] -> a

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: [a] -> [a]

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: [a] -> [a]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: (Eq a) => a -> [(a, b)] -> Maybe b

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   If one input list is short, excess elements of the longer list are
--   discarded.
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
unwords :: [String] -> String

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a where showsPrec _ x s = show x ++ s show x = shows x "" showList ls s = showList__ shows ls s

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: (Show a) => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
class Read a where readsPrec = readPrec_to_S readPrec readList = readPrec_to_S (list readPrec) 0 readPrec = readS_to_Prec readsPrec readListPrec = readS_to_Prec (\ _ -> readList)

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process.
read :: Read a => String -> a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a :: * -> *

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Control.Exception.Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | Construct an <a>IOError</a> value with a string describing the error.
--   The <a>fail</a> method of the <a>IO</a> instance of the <a>Monad</a>
--   class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

module GHC.SrcLoc

-- | A single location in the source code.
data SrcLoc
srcLocPackage :: SrcLoc -> String
srcLocModule :: SrcLoc -> String
srcLocFile :: SrcLoc -> String
srcLocStartLine :: SrcLoc -> Int
srcLocStartCol :: SrcLoc -> Int
srcLocEndLine :: SrcLoc -> Int
srcLocEndCol :: SrcLoc -> Int
showSrcLoc :: SrcLoc -> String
instance GHC.Classes.Eq GHC.SrcLoc.SrcLoc
instance GHC.Show.Show GHC.SrcLoc.SrcLoc


-- | Access to GHC's call-stack simulation
module GHC.Stack

-- | returns a '[String]' representing the current call stack. This can be
--   useful for debugging.
--   
--   The implementation uses the call-stack simulation maintined by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | Get the stack trace attached to an object.
whoCreated :: a -> IO [String]

-- | Like the function <a>error</a>, but appends a stack trace to the error
--   message if one is available.
errorWithStackTrace :: String -> a

-- | <tt>CallStack</tt>s are an alternate method of obtaining the call
--   stack at a given point in the program.
--   
--   When an implicit-parameter of type <tt>CallStack</tt> occurs in a
--   program, GHC will solve it with the current location. If another
--   <tt>CallStack</tt> implicit-parameter is in-scope (e.g. as a function
--   argument), the new location will be appended to the one in-scope,
--   creating an explicit call-stack. For example,
--   
--   <pre>
--   myerror :: (?loc :: CallStack) =&gt; String -&gt; a
--   myerror msg = error (msg ++ "n" ++ showCallStack ?loc)
--   </pre>
--   
--   ghci&gt; myerror "die" *** Exception: die ?loc, called at
--   MyError.hs:7:51 in main:MyError myerror, called at
--   <a>interactive</a>:2:1 in interactive:Ghci1
--   
--   <tt>CallStack</tt>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly using implicit-parameters, they will generally not
--   contain as much information as the simulated call-stacks maintained by
--   the RTS.
--   
--   The <tt>CallStack</tt> type is abstract, but it can be converted into
--   a <tt>[(String, SrcLoc)]</tt> via <a>getCallStack</a>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
data CallStack
getCallStack :: CallStack -> [(String, SrcLoc)]
showCallStack :: CallStack -> String
data CostCentreStack
data CostCentre
getCurrentCCS :: dummy -> IO (Ptr CostCentreStack)
getCCSOf :: a -> IO (Ptr CostCentreStack)
ccsCC :: Ptr CostCentreStack -> IO (Ptr CostCentre)
ccsParent :: Ptr CostCentreStack -> IO (Ptr CostCentreStack)
ccLabel :: Ptr CostCentre -> IO CString
ccModule :: Ptr CostCentre -> IO CString
ccSrcSpan :: Ptr CostCentre -> IO CString
ccsToStrings :: Ptr CostCentreStack -> IO [String]
renderStack :: [String] -> String
instance GHC.Classes.Eq GHC.Stack.CallStack
instance GHC.Show.Show GHC.Stack.CallStack


-- | Functions for tracing and monitoring execution.
--   
--   These can be useful for investigating bugs or performance problems.
--   They should <i>not</i> be used in production code.
module Debug.Trace

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   trace ("calling f with x = " ++ show x) (f x)
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a

-- | Like <a>trace</a> but returns the message instead of a third value.
traceId :: String -> String

-- | Like <a>trace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example here we print
--   the value of the variables <tt>x</tt> and <tt>z</tt>:
--   
--   <pre>
--   f x y =
--       traceShow (x, z) $ result
--     where
--       z = ...
--       ...
--   </pre>
traceShow :: (Show a) => a -> b -> b

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
traceShowId :: (Show a) => a -> a

-- | like <a>trace</a>, but additionally prints a call stack if one is
--   available.
--   
--   In the current GHC implementation, the call stack is only availble if
--   the program was compiled with <tt>-prof</tt>; otherwise
--   <a>traceStack</a> behaves exactly like <a>trace</a>. Entries in the
--   call stack correspond to <tt>SCC</tt> annotations, so it is a good
--   idea to use <tt>-fprof-auto</tt> or <tt>-fprof-auto-calls</tt> to add
--   SCC annotations automatically.
traceStack :: String -> a -> a

-- | The <a>traceIO</a> function outputs the trace message from the IO
--   monad. This sequences the output with respect to other IO actions.
traceIO :: String -> IO ()

-- | Like <a>trace</a> but returning unit in an arbitrary monad. Allows for
--   convenient use in do-notation. Note that the application of
--   <a>trace</a> is not an action in the monad, as <a>traceIO</a> is in
--   the <a>IO</a> monad.
--   
--   <pre>
--   ... = do
--     x &lt;- ...
--     traceM $ "x: " ++ show x
--     y &lt;- ...
--     traceM $ "y: " ++ show y
--   </pre>
traceM :: (Monad m) => String -> m ()

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   ... = do
--     x &lt;- ...
--     traceMShow $ x
--     y &lt;- ...
--     traceMShow $ x + y
--   </pre>
traceShowM :: (Show a, Monad m) => a -> m ()

-- | <i>Deprecated: Use <a>traceIO</a></i>
putTraceMsg :: String -> IO ()

-- | The <a>traceEvent</a> function behaves like <a>trace</a> with the
--   difference that the message is emitted to the eventlog, if eventlog
--   profiling is available and enabled at runtime.
--   
--   It is suitable for use in pure code. In an IO context use
--   <a>traceEventIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceEvent</a>.
traceEvent :: String -> a -> a

-- | The <a>traceEventIO</a> function emits a message to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceEvent</a>, <a>traceEventIO</a> sequences the event
--   with respect to other IO actions.
traceEventIO :: String -> IO ()

-- | The <a>traceMarker</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime. The
--   <tt>String</tt> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
--   
--   This function is suitable for use in pure code. In an IO context use
--   <a>traceMarkerIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceMarker</a>.
traceMarker :: String -> a -> a

-- | The <a>traceMarkerIO</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceMarker</a>, <a>traceMarkerIO</a> sequences the
--   event with respect to other IO actions.
traceMarkerIO :: String -> IO ()


-- | GHC Extensions: this is the Approved Way to get at GHC-specific
--   extensions.
--   
--   Note: no other base module should import this module.
module GHC.Exts

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *
I# :: Int# -> Int

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word :: *
W# :: Word# -> Word

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *
F# :: Float# -> Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *
D# :: Double# -> Double

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *
C# :: Char# -> Char

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a
Ptr :: Addr# -> Ptr a

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a
FunPtr :: Addr# -> FunPtr a
maxTupleSize :: Int

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
shiftL# :: Word# -> Int# -> Word#

-- | Shift the argument right by the specified number of bits (which must
--   be non-negative). The <a>RL</a> means "right, logical" (as opposed to
--   RA for arithmetic) (although an arithmetic right shift wouldn't make
--   sense for Word#)
shiftRL# :: Word# -> Int# -> Word#

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
iShiftL# :: Int# -> Int# -> Int#

-- | Shift the argument right (signed) by the specified number of bits
--   (which must be non-negative). The <a>RA</a> means "right, arithmetic"
--   (as opposed to RL for logical)
iShiftRA# :: Int# -> Int# -> Int#

-- | Shift the argument right (unsigned) by the specified number of bits
--   (which must be non-negative). The <a>RL</a> means "right, logical" (as
--   opposed to RA for arithmetic)
iShiftRL# :: Int# -> Int# -> Int#
uncheckedShiftL64# :: Word# -> Int# -> Word#
uncheckedShiftRL64# :: Word# -> Int# -> Word#
uncheckedIShiftL64# :: Int# -> Int# -> Int#
uncheckedIShiftRA64# :: Int# -> Int# -> Int#

-- | Alias for <a>tagToEnum#</a>. Returns True if its parameter is 1# and
--   False if it is 0#.
isTrue# :: Int# -> Bool

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   build g = g (:) []
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>build</a> g)</tt>, which may arise after
--   inlining, to <tt>g k z</tt>, which avoids producing an intermediate
--   list.
build :: (forall b. (a -> b -> b) -> b -> b) -> [a]

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   augment g xs = g (:) xs
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>augment</a> g xs)</tt>, which may arise after
--   inlining, to <tt>g k (<a>foldr</a> k z xs)</tt>, which avoids
--   producing an intermediate list.
augment :: (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a
breakpoint :: a -> a
breakpointCond :: Bool -> a -> a

-- | The <a>lazy</a> function restrains strictness analysis a little. The
--   call <tt>lazy e</tt> means the same as <tt>e</tt>, but <a>lazy</a> has
--   a magical property so far as strictness analysis is concerned: it is
--   lazy in its first argument, even though its semantics is strict. After
--   strictness analysis has run, calls to <a>lazy</a> are inlined to be
--   the identity function.
--   
--   This behaviour is occasionally useful when controlling evaluation
--   order. Notably, <a>lazy</a> is used in the library definition of
--   <a>par</a>:
--   
--   <pre>
--   par :: a -&gt; b -&gt; b
--   par x y = case (par# x) of _ -&gt; lazy y
--   </pre>
--   
--   If <a>lazy</a> were not lazy, <tt>par</tt> would look strict in
--   <tt>y</tt> which would defeat the whole purpose of <tt>par</tt>.
--   
--   Like <tt>seq</tt>, the argument of <a>lazy</a> can have an unboxed
--   type.
lazy :: a -> a

-- | The call <tt>inline f</tt> arranges that <tt>f</tt> is inlined,
--   regardless of its size. More precisely, the call <tt>inline f</tt>
--   rewrites to the right-hand side of <tt>f</tt>'s definition. This
--   allows the programmer to control inlining from a particular call site
--   rather than the definition site of the function (c.f. <tt>INLINE</tt>
--   pragmas).
--   
--   This inlining occurs regardless of the argument to the call or the
--   size of <tt>f</tt>'s definition; it is unconditional. The main caveat
--   is that <tt>f</tt>'s definition must be visible to the compiler; it is
--   therefore recommended to mark the function with an <tt>INLINABLE</tt>
--   pragma at its definition so that GHC guarantees to record its
--   unfolding regardless of size.
--   
--   If no inlining takes place, the <a>inline</a> function expands to the
--   identity function in Phase zero, so its use imposes no overhead.
inline :: a -> a

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible * a b => a -> b

-- | This two-parameter class has instances for types <tt>a</tt> and
--   <tt>b</tt> if the compiler can infer that they have the same
--   representation. This class does not have regular instances; instead
--   they are created on-the-fly during type-checking. Trying to manually
--   declare an instance of <tt>Coercible</tt> is an error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class Coercible (a :: k) (b :: k)

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
--   
--   Provides <a>Show</a> and <a>Read</a> instances (<i>since:
--   4.7.0.0</i>).
newtype Down a
Down :: a -> Down a

-- | The <a>groupWith</a> function uses the user supplied function which
--   projects an element out of every list element in order to first sort
--   the input list and then to form groups by equality on these projected
--   elements
groupWith :: Ord b => (a -> b) -> [a] -> [[a]]

-- | The <a>sortWith</a> function sorts a list of elements using the user
--   supplied function to project something out of each element
sortWith :: Ord b => (a -> b) -> [a] -> [a]

-- | <a>the</a> ensures that all the elements of the list are identical and
--   then returns that unique element
the :: Eq a => [a] -> a

-- | <i>Deprecated: Use <a>traceEvent</a> or <a>traceEventIO</a></i>
traceEvent :: String -> IO ()
data SpecConstrAnnotation
NoSpecConstr :: SpecConstrAnnotation
ForceSpecConstr :: SpecConstrAnnotation

-- | returns a '[String]' representing the current call stack. This can be
--   useful for debugging.
--   
--   The implementation uses the call-stack simulation maintined by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]
data Constraint :: BOX

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class IsList l where type family Item l fromListN _ = fromList

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length as a hint.
--   Its behaviour should be equivalent to <a>fromList</a>. The hint can be
--   used to construct the structure <tt>l</tt> more efficiently compared
--   to <a>fromList</a>. If the given hint does not equal to the input
--   list's length the behaviour of <a>fromListN</a> is not specified.
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]
instance GHC.Classes.Eq GHC.Exts.SpecConstrAnnotation
instance Data.Data.Data GHC.Exts.SpecConstrAnnotation
instance GHC.Exts.IsList [a]
instance GHC.Exts.IsList Data.Version.Version


-- | Monadic zipping (used for monad comprehensions)
module Control.Monad.Zip

-- | <a>MonadZip</a> type class. Minimal definition: <a>mzip</a> or
--   <a>mzipWith</a>
--   
--   Instances should satisfy the laws:
--   
--   <ul>
--   <li>Naturality :</li>
--   </ul>
--   
--   <pre>
--   liftM (f *** g) (mzip ma mb) = mzip (liftM f ma) (liftM g mb)
--   </pre>
--   
--   <ul>
--   <li>Information Preservation:</li>
--   </ul>
--   
--   <pre>
--   liftM (const ()) ma = liftM (const ()) mb
--   ==&gt;
--   munzip (mzip ma mb) = (ma, mb)
--   </pre>
class Monad m => MonadZip m where mzip = mzipWith (,) mzipWith f ma mb = liftM (uncurry f) (mzip ma mb) munzip mab = (liftM fst mab, liftM snd mab)
mzip :: MonadZip m => m a -> m b -> m (a, b)
mzipWith :: MonadZip m => (a -> b -> c) -> m a -> m b -> m c
munzip :: MonadZip m => m (a, b) -> (m a, m b)
instance Control.Monad.Zip.MonadZip []


-- | Symbolic references to values.
--   
--   References to values are usually implemented with memory addresses,
--   and this is practical when communicating values between the different
--   pieces of a single process.
--   
--   When values are communicated across different processes running in
--   possibly different machines, though, addresses are no longer useful
--   since each process may use different addresses to store a given value.
--   
--   To solve such concern, the references provided by this module offer a
--   key that can be used to locate the values on each process. Each
--   process maintains a global table of references which can be looked up
--   with a given key. This table is known as the Static Pointer Table. The
--   reference can then be dereferenced to obtain the value.
module GHC.StaticPtr

-- | A reference to a value of type <tt>a</tt>.
data StaticPtr a

-- | Dereferences a static pointer.
deRefStaticPtr :: StaticPtr a -> a

-- | A key for <tt>StaticPtrs</tt> that can be serialized and used with
--   <a>unsafeLookupStaticPtr</a>.
type StaticKey = Fingerprint

-- | The <a>StaticKey</a> that can be used to look up the given
--   <a>StaticPtr</a>.
staticKey :: StaticPtr a -> StaticKey

-- | Looks up a <a>StaticPtr</a> by its <a>StaticKey</a>.
--   
--   If the <a>StaticPtr</a> is not found returns <tt>Nothing</tt>.
--   
--   This function is unsafe because the program behavior is undefined if
--   the type of the returned <a>StaticPtr</a> does not match the expected
--   one.
unsafeLookupStaticPtr :: StaticKey -> IO (Maybe (StaticPtr a))

-- | Miscelaneous information available for debugging purposes.
data StaticPtrInfo
StaticPtrInfo :: String -> String -> String -> (Int, Int) -> StaticPtrInfo

-- | Package key of the package where the static pointer is defined
[spInfoPackageKey] :: StaticPtrInfo -> String

-- | Name of the module where the static pointer is defined
[spInfoModuleName] :: StaticPtrInfo -> String

-- | An internal name that is distinct for every static pointer defined in
--   a given module.
[spInfoName] :: StaticPtrInfo -> String

-- | Source location of the definition of the static pointer as a
--   <tt>(Line, Column)</tt> pair.
[spInfoSrcLoc] :: StaticPtrInfo -> (Int, Int)

-- | <a>StaticPtrInfo</a> of the given <a>StaticPtr</a>.
staticPtrInfo :: StaticPtr a -> StaticPtrInfo

-- | A list of all known keys.
staticPtrKeys :: IO [StaticKey]
instance GHC.Show.Show GHC.StaticPtr.StaticPtrInfo


-- | Unbounded channels.
module Control.Concurrent.Chan

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data Chan a

-- | Build and returns a new instance of <a>Chan</a>.
newChan :: IO (Chan a)

-- | Write a value to a <a>Chan</a>.
writeChan :: Chan a -> a -> IO ()

-- | Read the next value from the <a>Chan</a>.
readChan :: Chan a -> IO a

-- | Duplicate a <a>Chan</a>: the duplicate channel begins empty, but data
--   written to either channel from then on will be available from both.
--   Hence this creates a kind of broadcast channel, where data written by
--   anyone is seen by everyone else.
--   
--   (Note that a duplicated channel is not equal to its original. So:
--   <tt>fmap (c /=) $ dupChan c</tt> returns <tt>True</tt> for all
--   <tt>c</tt>.)
dupChan :: Chan a -> IO (Chan a)

-- | Put a data item back onto a channel, where it will be the next item
--   read.

-- | <i>Deprecated: if you need this operation, use
--   Control.Concurrent.STM.TChan instead. See
--   <a>http://ghc.haskell.org/trac/ghc/ticket/4154</a> for details</i>
unGetChan :: Chan a -> a -> IO ()

-- | Returns <a>True</a> if the supplied <a>Chan</a> is empty.

-- | <i>Deprecated: if you need this operation, use
--   Control.Concurrent.STM.TChan instead. See
--   <a>http://ghc.haskell.org/trac/ghc/ticket/4154</a> for details</i>
isEmptyChan :: Chan a -> IO Bool

-- | Return a lazy list representing the contents of the supplied
--   <a>Chan</a>, much like <a>hGetContents</a>.
getChanContents :: Chan a -> IO [a]

-- | Write an entire list of items to a <a>Chan</a>.
writeList2Chan :: Chan a -> [a] -> IO ()
instance GHC.Classes.Eq (Control.Concurrent.Chan.Chan a)


-- | Simple quantity semaphores.
module Control.Concurrent.QSem

-- | <a>QSem</a> is a quantity semaphore in which the resource is aqcuired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSem</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ waitQSem signalQSem (...)
--   </pre>
--   
--   is safe; it never loses a unit of the resource.
data QSem

-- | Build a new <a>QSem</a> with a supplied initial quantity. The initial
--   quantity must be at least 0.
newQSem :: Int -> IO QSem

-- | Wait for a unit to become available
waitQSem :: QSem -> IO ()

-- | Signal that a unit of the <a>QSem</a> is available
signalQSem :: QSem -> IO ()


-- | Quantity semaphores in which each thread may wait for an arbitrary
--   "amount".
module Control.Concurrent.QSemN

-- | <a>QSemN</a> is a quantity semaphore in which the resource is aqcuired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSemN</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ (waitQSemN n) (signalQSemN n) (...)
--   </pre>
--   
--   is safe; it never loses any of the resource.
data QSemN

-- | Build a new <a>QSemN</a> with a supplied initial quantity. The initial
--   quantity must be at least 0.
newQSemN :: Int -> IO QSemN

-- | Wait for the specified quantity to become available
waitQSemN :: QSemN -> Int -> IO ()

-- | Signal that a given quantity is now available from the <a>QSemN</a>.
signalQSemN :: QSemN -> Int -> IO ()


-- | A common interface to a collection of useful concurrency abstractions.
module Control.Concurrent

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
forkIO :: IO () -> IO ThreadId

-- | fork a thread and call the supplied function when the thread is about
--   to terminate, with an exception or a returned value. The function is
--   called with asynchronous exceptions masked.
--   
--   <pre>
--   forkFinally action and_then =
--     mask $ \restore -&gt;
--       forkIO $ try (restore action) &gt;&gt;= and_then
--   </pre>
--   
--   This function is useful for informing the parent when a child
--   terminates, for example.
forkFinally :: IO a -> (Either SomeException a -> IO ()) -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
setNumCapabilities :: Int -> IO ()

-- | returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
threadCapability :: ThreadId -> IO (Int, Bool)

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
threadDelay :: Int -> IO ()

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | <a>True</a> if bound threads are supported. If
--   <tt>rtsSupportsBoundThreads</tt> is <a>False</a>,
--   <a>isCurrentThreadBound</a> will always return <a>False</a> and both
--   <a>forkOS</a> and <a>runInBoundThread</a> will fail.
rtsSupportsBoundThreads :: Bool

-- | Like <a>forkIO</a>, this sparks off a new thread to run the <a>IO</a>
--   computation passed as the first argument, and returns the
--   <a>ThreadId</a> of the newly created thread.
--   
--   However, <a>forkOS</a> creates a <i>bound</i> thread, which is
--   necessary if you need to call foreign (non-Haskell) libraries that
--   make use of thread-local state, such as OpenGL (see
--   <a>Control.Concurrent#boundthreads</a>).
--   
--   Using <a>forkOS</a> instead of <a>forkIO</a> makes no difference at
--   all to the scheduling behaviour of the Haskell runtime system. It is a
--   common misconception that you need to use <a>forkOS</a> instead of
--   <a>forkIO</a> to avoid blocking all the Haskell threads when making a
--   foreign call; this isn't the case. To allow foreign calls to be made
--   without blocking all the Haskell threads (with GHC), it is only
--   necessary to use the <tt>-threaded</tt> option when linking your
--   program, and to make sure the foreign import is not marked
--   <tt>unsafe</tt>.
forkOS :: IO () -> IO ThreadId

-- | Returns <a>True</a> if the calling thread is <i>bound</i>, that is, if
--   it is safe to use foreign libraries that rely on thread-local state
--   from the calling thread.
isCurrentThreadBound :: IO Bool

-- | Run the <a>IO</a> computation passed as the first argument. If the
--   calling thread is not <i>bound</i>, a bound thread is created
--   temporarily. <tt>runInBoundThread</tt> doesn't finish until the
--   <a>IO</a> computation finishes.
--   
--   You can wrap a series of foreign function calls that rely on
--   thread-local state with <tt>runInBoundThread</tt> so that you can use
--   them without knowing whether the current thread is <i>bound</i>.
runInBoundThread :: IO a -> IO a

-- | Run the <a>IO</a> computation passed as the first argument. If the
--   calling thread is <i>bound</i>, an unbound thread is created
--   temporarily using <a>forkIO</a>. <tt>runInBoundThread</tt> doesn't
--   finish until the <a>IO</a> computation finishes.
--   
--   Use this function <i>only</i> in the rare case that you have actually
--   observed a performance loss due to the use of bound threads. A program
--   that doesn't need its main thread to be bound and makes <i>heavy</i>
--   use of concurrency (e.g. a web server), might want to wrap its
--   <tt>main</tt> action in <tt>runInUnboundThread</tt>.
--   
--   Note that exceptions which are thrown to the current thread are thrown
--   in turn to the thread that is executing the given computation. This
--   ensures there's always a way of killing the forked thread.
runInUnboundThread :: IO a -> IO a

-- | make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)


-- | <i>This module is DEPRECATED and will be removed in the future!</i>
--   
--   <a>Functor</a> and <a>Monad</a> instances for <tt>(-&gt;) r</tt> and
--   <a>Functor</a> instances for <tt>(,) a</tt> and <tt><a>Either</a>
--   a</tt>.

-- | <i>Deprecated: This module now contains no instances and will be
--   removed in the future</i>
module Control.Monad.Instances

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor f where (<$) = fmap . const
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m where m >> k = m >>= \ _ -> k return = pure fail s = error s

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
fail :: Monad m => String -> m a


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
--   
--   References (variables) that can be used within the <tt>ST</tt> monad
--   are provided by <a>Data.STRef</a>, and arrays are provided by
--   <a>Data.Array.ST</a>.
module Control.Monad.ST

-- | The strict state-transformer monad. A computation of type
--   <tt><a>ST</a> s a</tt> transforms an internal state indexed by
--   <tt>s</tt>, and returns a value of type <tt>a</tt>. The <tt>s</tt>
--   parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a

-- | Return the value computed by a state transformer computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of a state transformer computation to be used
--   (lazily) inside the computation. Note that if <tt>f</tt> is strict,
--   <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: *

-- | A monad transformer embedding strict state transformers in the
--   <a>IO</a> monad. The <a>RealWorld</a> parameter indicates that the
--   internal state used by the <a>ST</a> computation is a special one
--   supplied by the <a>IO</a> monad, and thus distinct from those used by
--   invocations of <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Control.Monad.ST
--   instead</i>
module Control.Monad.ST.Safe

-- | The strict state-transformer monad. A computation of type
--   <tt><a>ST</a> s a</tt> transforms an internal state indexed by
--   <tt>s</tt>, and returns a value of type <tt>a</tt>. The <tt>s</tt>
--   parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a

-- | Return the value computed by a state transformer computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of a state transformer computation to be used
--   (lazily) inside the computation. Note that if <tt>f</tt> is strict,
--   <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: *

-- | A monad transformer embedding strict state transformers in the
--   <a>IO</a> monad. The <a>RealWorld</a> parameter indicates that the
--   internal state used by the <a>ST</a> computation is a special one
--   supplied by the <a>IO</a> monad, and thus distinct from those used by
--   invocations of <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | The strict ST monad (re-export of <a>Control.Monad.ST</a>)
module Control.Monad.ST.Strict


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
--   
--   Unsafe API.
module Control.Monad.ST.Unsafe
unsafeInterleaveST :: ST s a -> ST s a
unsafeIOToST :: IO a -> ST s a
unsafeSTToIO :: ST s a -> IO a


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   state operations until a value depending on them is required.
module Control.Monad.ST.Lazy

-- | The lazy state-transformer monad. A computation of type <tt><a>ST</a>
--   s a</tt> transforms an internal state indexed by <tt>s</tt>, and
--   returns a value of type <tt>a</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an unstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are not strict in
--   the state. For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= readSTRef _|_ &gt;&gt; return 2) = 2
--   </pre>
data ST s a

-- | Return the value computed by a state transformer computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of a state transformer computation to be used
--   (lazily) inside the computation. Note that if <tt>f</tt> is strict,
--   <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | Convert a strict <a>ST</a> computation into a lazy one. The strict
--   state thread passed to <a>strictToLazyST</a> is not performed until
--   the result of the lazy state thread it returns is demanded.
strictToLazyST :: ST s a -> ST s a

-- | Convert a lazy <a>ST</a> computation into a strict one.
lazyToStrictST :: ST s a -> ST s a

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: *

-- | A monad transformer embedding lazy state transformers in the <a>IO</a>
--   monad. The <a>RealWorld</a> parameter indicates that the internal
--   state used by the <a>ST</a> computation is a special one supplied by
--   the <a>IO</a> monad, and thus distinct from those used by invocations
--   of <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   state operations until a value depending on them is required.
--   
--   Safe API only.

-- | <i>Deprecated: Safe is now the default, please use
--   Control.Monad.ST.Lazy instead</i>
module Control.Monad.ST.Lazy.Safe

-- | The lazy state-transformer monad. A computation of type <tt><a>ST</a>
--   s a</tt> transforms an internal state indexed by <tt>s</tt>, and
--   returns a value of type <tt>a</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an unstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are not strict in
--   the state. For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= readSTRef _|_ &gt;&gt; return 2) = 2
--   </pre>
data ST s a

-- | Return the value computed by a state transformer computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of a state transformer computation to be used
--   (lazily) inside the computation. Note that if <tt>f</tt> is strict,
--   <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | Convert a strict <a>ST</a> computation into a lazy one. The strict
--   state thread passed to <a>strictToLazyST</a> is not performed until
--   the result of the lazy state thread it returns is demanded.
strictToLazyST :: ST s a -> ST s a

-- | Convert a lazy <a>ST</a> computation into a strict one.
lazyToStrictST :: ST s a -> ST s a

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: *

-- | A monad transformer embedding lazy state transformers in the <a>IO</a>
--   monad. The <a>RealWorld</a> parameter indicates that the internal
--   state used by the <a>ST</a> computation is a special one supplied by
--   the <a>IO</a> monad, and thus distinct from those used by invocations
--   of <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   state operations until a value depending on them is required.
--   
--   Unsafe API.
module Control.Monad.ST.Lazy.Unsafe
unsafeInterleaveST :: ST s a -> ST s a
unsafeIOToST :: IO a -> ST s a


module Data.Bifunctor

-- | Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor p where bimap f g = first f . second g first f = bimap f id second = bimap id

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c
instance Data.Bifunctor.Bifunctor (,)
instance Data.Bifunctor.Bifunctor ((,,) x1)
instance Data.Bifunctor.Bifunctor ((,,,) x1 x2)
instance Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3)
instance Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4)
instance Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5)
instance Data.Bifunctor.Bifunctor Data.Either.Either
instance Data.Bifunctor.Bifunctor Control.Applicative.Const


-- | Complex numbers.
module Data.Complex

-- | Complex numbers are an algebraic type.
--   
--   For a complex number <tt>z</tt>, <tt><a>abs</a> z</tt> is a number
--   with the magnitude of <tt>z</tt>, but oriented in the positive real
--   direction, whereas <tt><a>signum</a> z</tt> has the phase of
--   <tt>z</tt>, but unit magnitude.
data Complex a

-- | forms a complex number from its real and imaginary rectangular
--   components.
(:+) :: !a -> !a -> Complex a

-- | Extracts the real part of a complex number.
realPart :: Complex a -> a

-- | Extracts the imaginary part of a complex number.
imagPart :: Complex a -> a

-- | Form a complex number from polar components of magnitude and phase.
mkPolar :: Floating a => a -> a -> Complex a

-- | <tt><a>cis</a> t</tt> is a complex value with magnitude <tt>1</tt> and
--   phase <tt>t</tt> (modulo <tt>2*<a>pi</a></tt>).
cis :: Floating a => a -> Complex a

-- | The function <a>polar</a> takes a complex number and returns a
--   (magnitude, phase) pair in canonical form: the magnitude is
--   nonnegative, and the phase in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>; if the magnitude is zero, then so is the phase.
polar :: (RealFloat a) => Complex a -> (a, a)

-- | The nonnegative magnitude of a complex number.
magnitude :: (RealFloat a) => Complex a -> a

-- | The phase of a complex number, in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>. If the magnitude is zero, then so is the phase.
phase :: (RealFloat a) => Complex a -> a

-- | The conjugate of a complex number.
conjugate :: Num a => Complex a -> Complex a
instance Data.Data.Data a => Data.Data.Data (Data.Complex.Complex a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Complex.Complex a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Complex.Complex a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Num.Num (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Real.Fractional (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Float.Floating (Data.Complex.Complex a)
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Complex.Complex a)


-- | This module defines a "Fixed" type for fixed-precision arithmetic. The
--   parameter to Fixed is any type that's an instance of HasResolution.
--   HasResolution has a single method that gives the resolution of the
--   Fixed type.
--   
--   This module also contains generalisations of div, mod, and divmod to
--   work with any Real instance.
module Data.Fixed

-- | generalisation of <a>div</a> to any instance of Real
div' :: (Real a, Integral b) => a -> a -> b

-- | generalisation of <a>mod</a> to any instance of Real
mod' :: (Real a) => a -> a -> a

-- | generalisation of <a>divMod</a> to any instance of Real
divMod' :: (Real a, Integral b) => a -> a -> (b, a)

-- | The type parameter should be an instance of <a>HasResolution</a>.
newtype Fixed a

MkFixed :: Integer -> Fixed a
class HasResolution a
resolution :: HasResolution a => p a -> Integer

-- | First arg is whether to chop off trailing zeros
showFixed :: (HasResolution a) => Bool -> Fixed a -> String
data E0

-- | resolution of 1, this works the same as Integer
type Uni = Fixed E0
data E1

-- | resolution of 10^-1 = .1
type Deci = Fixed E1
data E2

-- | resolution of 10^-2 = .01, useful for many monetary currencies
type Centi = Fixed E2
data E3

-- | resolution of 10^-3 = .001
type Milli = Fixed E3
data E6

-- | resolution of 10^-6 = .000001
type Micro = Fixed E6
data E9

-- | resolution of 10^-9 = .000000001
type Nano = Fixed E9
data E12

-- | resolution of 10^-12 = .000000000001
type Pico = Fixed E12
instance GHC.Classes.Ord (Data.Fixed.Fixed a)
instance GHC.Classes.Eq (Data.Fixed.Fixed a)
instance Data.Typeable.Internal.Typeable a => Data.Data.Data (Data.Fixed.Fixed a)
instance GHC.Enum.Enum (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Num.Num (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Real.Real (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Real.Fractional (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Real.RealFrac (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Show.Show (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Read.Read (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution Data.Fixed.E0
instance Data.Fixed.HasResolution Data.Fixed.E1
instance Data.Fixed.HasResolution Data.Fixed.E2
instance Data.Fixed.HasResolution Data.Fixed.E3
instance Data.Fixed.HasResolution Data.Fixed.E6
instance Data.Fixed.HasResolution Data.Fixed.E9
instance Data.Fixed.HasResolution Data.Fixed.E12


-- | The identity functor and monad.
--   
--   This trivial type constructor serves two purposes:
--   
--   <ul>
--   <li>It can be used with functions parameterized by functor or monad
--   classes.</li>
--   <li>It can be used as a base monad to which a series of monad
--   transformers may be applied to construct a composite monad. Most monad
--   transformer modules include the special case of applying the
--   transformer to <a>Identity</a>. For example, <tt>State s</tt> is an
--   abbreviation for <tt>StateT s <a>Identity</a></tt>.</li>
--   </ul>
module Data.Functor.Identity

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a
instance GHC.Generics.Selector Data.Functor.Identity.S1_0_0Identity
instance GHC.Generics.Constructor Data.Functor.Identity.C1_0Identity
instance GHC.Generics.Datatype Data.Functor.Identity.D1Identity
instance GHC.Generics.Generic1 Data.Functor.Identity.Identity
instance GHC.Generics.Generic (Data.Functor.Identity.Identity a)
instance Data.Traversable.Traversable Data.Functor.Identity.Identity
instance Data.Data.Data a => Data.Data.Data (Data.Functor.Identity.Identity a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Identity.Identity a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Identity.Identity a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Functor.Identity.Identity a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Identity.Identity a)
instance Data.Foldable.Foldable Data.Functor.Identity.Identity
instance GHC.Base.Functor Data.Functor.Identity.Identity
instance GHC.Base.Applicative Data.Functor.Identity.Identity
instance GHC.Base.Monad Data.Functor.Identity.Identity
instance Control.Monad.Fix.MonadFix Data.Functor.Identity.Identity
instance Control.Monad.Zip.MonadZip Data.Functor.Identity.Identity


-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   type onto integers. It is used primarily for array indexing (see the
--   array package). <a>Ix</a> uses row-major order.
module Data.Ix

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <a>elem</a> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <a>!!</a> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <a>length</a> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class (Ord a) => Ix a where index b i | inRange b i = unsafeIndex b i | otherwise = hopelessIndexError unsafeIndex b i = index b i rangeSize b@(_l, h) | inRange b h = unsafeIndex b h + 1 | otherwise = 0 unsafeRangeSize b@(_l, h) = unsafeIndex b h + 1

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: Ix a => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int


-- | Standard functions on rational numbers
module Data.Ratio

-- | Rational numbers, with numerator and denominator of some
--   <a>Integral</a> type.
data Ratio a

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | Forms the ratio of two integral numbers.
(%) :: (Integral a) => a -> a -> Ratio a

-- | Extract the numerator of the ratio in reduced form: the numerator and
--   denominator have no common factor and the denominator is positive.
numerator :: (Integral a) => Ratio a -> a

-- | Extract the denominator of the ratio in reduced form: the numerator
--   and denominator have no common factor and the denominator is positive.
denominator :: (Integral a) => Ratio a -> a

-- | <a>approxRational</a>, applied to two real fractional numbers
--   <tt>x</tt> and <tt>epsilon</tt>, returns the simplest rational number
--   within <tt>epsilon</tt> of <tt>x</tt>. A rational number <tt>y</tt> is
--   said to be <i>simpler</i> than another <tt>y'</tt> if
--   
--   <ul>
--   <li><tt><a>abs</a> (<a>numerator</a> y) &lt;= <a>abs</a>
--   (<a>numerator</a> y')</tt>, and</li>
--   <li><tt><a>denominator</a> y &lt;= <a>denominator</a> y'</tt>.</li>
--   </ul>
--   
--   Any real interval contains a unique simplest rational; in particular,
--   note that <tt>0/1</tt> is the simplest rational of all.
approxRational :: (RealFrac a) => a -> a -> Rational


-- | Mutable references in the (strict) ST monad.
module Data.STRef

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
data STRef s a

-- | Build a new <a>STRef</a> in the current state thread
newSTRef :: a -> ST s (STRef s a)

-- | Read the value of an <a>STRef</a>
readSTRef :: STRef s a -> ST s a

-- | Write a new value into an <a>STRef</a>
writeSTRef :: STRef s a -> a -> ST s ()

-- | Mutate the contents of an <a>STRef</a>.
--   
--   Be warned that <a>modifySTRef</a> does not apply the function
--   strictly. This means if the program calls <a>modifySTRef</a> many
--   times, but seldomly uses the value, thunks will pile up in memory
--   resulting in a space leak. This is a common mistake made when using an
--   STRef as a counter. For example, the following will leak memory and
--   likely produce a stack overflow:
--   
--   <pre>
--   print $ runST $ do
--       ref &lt;- newSTRef 0
--       replicateM_ 1000000 $ modifySTRef ref (+1)
--       readSTRef ref
--   </pre>
--   
--   To avoid this problem, use <a>modifySTRef'</a> instead.
modifySTRef :: STRef s a -> (a -> a) -> ST s ()

-- | Strict version of <a>modifySTRef</a>
modifySTRef' :: STRef s a -> (a -> a) -> ST s ()


-- | Mutable references in the lazy ST monad.
module Data.STRef.Lazy

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
data STRef s a
newSTRef :: a -> ST s (STRef s a)
readSTRef :: STRef s a -> ST s a
writeSTRef :: STRef s a -> a -> ST s ()
modifySTRef :: STRef s a -> (a -> a) -> ST s ()


-- | Mutable references in the (strict) ST monad (re-export of
--   <a>Data.STRef</a>)
module Data.STRef.Strict


-- | An abstract interface to a unique symbol generator.
module Data.Unique

-- | An abstract unique object. Objects of type <a>Unique</a> may be
--   compared for equality and ordering and hashed into <a>Int</a>.
data Unique

-- | Creates a new object of type <a>Unique</a>. The value returned will
--   not compare equal to any other value of type <a>Unique</a> returned by
--   previous calls to <a>newUnique</a>. There is no limit on the number of
--   times <a>newUnique</a> may be called.
newUnique :: IO Unique

-- | Hashes a <a>Unique</a> into an <a>Int</a>. Two <a>Unique</a>s may hash
--   to the same value, although in practice this is unlikely. The
--   <a>Int</a> returned makes a good hash key.
hashUnique :: Unique -> Int
instance GHC.Classes.Ord Data.Unique.Unique
instance GHC.Classes.Eq Data.Unique.Unique


-- | A logically uninhabited data type, used to indicate that a given term
--   should not exist.
module Data.Void

-- | Uninhabited data type
data Void

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
absurd :: Void -> a

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values.
vacuous :: Functor f => f Void -> f a
instance GHC.Generics.Datatype Data.Void.D1Void
instance GHC.Generics.Generic Data.Void.Void
instance Data.Data.Data Data.Void.Void
instance GHC.Classes.Eq Data.Void.Void
instance GHC.Classes.Ord Data.Void.Void
instance GHC.Read.Read Data.Void.Void
instance GHC.Show.Show Data.Void.Void
instance GHC.Arr.Ix Data.Void.Void
instance GHC.Exception.Exception Data.Void.Void


-- | The standard CPUTime library.
module System.CPUTime

-- | Computation <a>getCPUTime</a> returns the number of picoseconds CPU
--   time used by the current program. The precision of this result is
--   implementation-dependent.
getCPUTime :: IO Integer

-- | The <a>cpuTimePrecision</a> constant is the smallest measurable
--   difference in CPU time that the implementation can record, and is
--   given as an integral number of picoseconds.
cpuTimePrecision :: Integer


-- | This library provides facilities for parsing the command-line options
--   in a standalone program. It is essentially a Haskell port of the GNU
--   <tt>getopt</tt> library.
module System.Console.GetOpt

-- | Process the command-line, and return the list of values that matched
--   (and those that didn't). The arguments are:
--   
--   <ul>
--   <li>The order requirements (see <a>ArgOrder</a>)</li>
--   <li>The option descriptions (see <a>OptDescr</a>)</li>
--   <li>The actual command line arguments (presumably got from
--   <a>getArgs</a>).</li>
--   </ul>
--   
--   <a>getOpt</a> returns a triple consisting of the option arguments, a
--   list of non-options, and a list of error messages.
getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])

-- | This is almost the same as <a>getOpt</a>, but returns a quadruple
--   consisting of the option arguments, a list of non-options, a list of
--   unrecognized options, and a list of error messages.
getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])

-- | Return a string describing the usage of a command, derived from the
--   header (first argument) and the options described by the second
--   argument.
usageInfo :: String -> [OptDescr a] -> String

-- | What to do with options following non-options
data ArgOrder a

-- | no option processing after first non-option
RequireOrder :: ArgOrder a

-- | freely intersperse options and non-options
Permute :: ArgOrder a

-- | wrap non-options into options
ReturnInOrder :: (String -> a) -> ArgOrder a

-- | Each <a>OptDescr</a> describes a single option.
--   
--   The arguments to <a>Option</a> are:
--   
--   <ul>
--   <li>list of short option characters</li>
--   <li>list of long option strings (without "--")</li>
--   <li>argument descriptor</li>
--   <li>explanation of option for user</li>
--   </ul>
data OptDescr a
Option :: [Char] -> [String] -> (ArgDescr a) -> String -> OptDescr a

-- | Describes whether an option takes an argument or not, and if so how
--   the argument is injected into a value of type <tt>a</tt>.
data ArgDescr a

-- | no argument expected
NoArg :: a -> ArgDescr a

-- | option requires argument
ReqArg :: (String -> a) -> String -> ArgDescr a

-- | optional argument
OptArg :: (Maybe String -> a) -> String -> ArgDescr a
instance GHC.Base.Functor System.Console.GetOpt.ArgOrder
instance GHC.Base.Functor System.Console.GetOpt.OptDescr
instance GHC.Base.Functor System.Console.GetOpt.ArgDescr


-- | Miscellaneous information about the system environment.
module System.Environment

-- | Computation <a>getArgs</a> returns a list of the program's command
--   line arguments (not including the program name).
getArgs :: IO [String]

-- | Computation <a>getProgName</a> returns the name of the program as it
--   was invoked.
--   
--   However, this is hard-to-impossible to implement on some non-Unix
--   OSes, so instead, for maximum portability, we just return the leafname
--   of the program as invoked. Even then there are some differences
--   between platforms: on Windows, for example, a program invoked as foo
--   is probably really <tt>FOO.EXE</tt>, and that is what
--   <a>getProgName</a> will return.
getProgName :: IO String

-- | Returns the absolute pathname of the current executable.
--   
--   Note that for scripts and interactive sessions, this is the path to
--   the interpreter (e.g. ghci.)
getExecutablePath :: IO FilePath

-- | Computation <a>getEnv</a> <tt>var</tt> returns the value of the
--   environment variable <tt>var</tt>. For the inverse, POSIX users can
--   use <a>putEnv</a>.
--   
--   This computation may fail with:
--   
--   <ul>
--   <li><a>isDoesNotExistError</a> if the environment variable does not
--   exist.</li>
--   </ul>
getEnv :: String -> IO String

-- | Return the value of the environment variable <tt>var</tt>, or
--   <tt>Nothing</tt> if there is no such value.
--   
--   For POSIX users, this is equivalent to <a>getEnv</a>.
lookupEnv :: String -> IO (Maybe String)

-- | <tt>setEnv name value</tt> sets the specified environment variable to
--   <tt>value</tt>.
--   
--   On Windows setting an environment variable to the <i>empty string</i>
--   removes that environment variable from the environment. For the sake
--   of compatibility we adopt that behavior. In particular
--   
--   <pre>
--   setEnv name ""
--   </pre>
--   
--   has the same effect as
--   
--   <pre>
--   <a>unsetEnv</a> name
--   </pre>
--   
--   If you don't care about Windows support and want to set an environment
--   variable to the empty string use <tt>System.Posix.Env.setEnv</tt> from
--   the <tt>unix</tt> package instead.
--   
--   Throws <a>IOException</a> if <tt>name</tt> is the empty string or
--   contains an equals sign.
setEnv :: String -> String -> IO ()

-- | <tt>unSet name</tt> removes the specified environment variable from
--   the environment of the current process.
--   
--   Throws <a>IOException</a> if <tt>name</tt> is the empty string or
--   contains an equals sign.
unsetEnv :: String -> IO ()

-- | <a>withArgs</a> <tt>args act</tt> - while executing action
--   <tt>act</tt>, have <a>getArgs</a> return <tt>args</tt>.
withArgs :: [String] -> IO a -> IO a

-- | <a>withProgName</a> <tt>name act</tt> - while executing action
--   <tt>act</tt>, have <a>getProgName</a> return <tt>name</tt>.
withProgName :: String -> IO a -> IO a

-- | <a>getEnvironment</a> retrieves the entire environment as a list of
--   <tt>(key,value)</tt> pairs.
--   
--   If an environment entry does not contain an <tt>'='</tt> character,
--   the <tt>key</tt> is the whole entry and the <tt>value</tt> is the
--   empty string.
getEnvironment :: IO [(String, String)]


-- | Exiting the program.
module System.Exit

-- | Defines the exit codes that a program can return.
data ExitCode

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | Computation <a>exitWith</a> <tt>code</tt> throws <a>ExitCode</a>
--   <tt>code</tt>. Normally this terminates the program, returning
--   <tt>code</tt> to the program's caller.
--   
--   On program termination, the standard <a>Handle</a>s <a>stdout</a> and
--   <a>stderr</a> are flushed automatically; any other buffered
--   <a>Handle</a>s need to be flushed manually, otherwise the buffered
--   data will be discarded.
--   
--   A program that fails in any other way is treated as if it had called
--   <a>exitFailure</a>. A program that terminates successfully without
--   calling <a>exitWith</a> explicitly is treated as it it had called
--   <a>exitWith</a> <a>ExitSuccess</a>.
--   
--   As an <a>ExitCode</a> is not an <a>IOError</a>, <a>exitWith</a>
--   bypasses the error handling in the <a>IO</a> monad and cannot be
--   intercepted by <tt>catch</tt> from the <a>Prelude</a>. However it is a
--   <tt>SomeException</tt>, and can be caught using the functions of
--   <a>Control.Exception</a>. This means that cleanup computations added
--   with <a>bracket</a> (from <a>Control.Exception</a>) are also executed
--   properly on <a>exitWith</a>.
--   
--   Note: in GHC, <a>exitWith</a> should be called from the main program
--   thread in order to exit the process. When called from another thread,
--   <a>exitWith</a> will throw an <tt>ExitException</tt> as normal, but
--   the exception will not cause the process itself to exit.
exitWith :: ExitCode -> IO a

-- | The computation <a>exitFailure</a> is equivalent to <a>exitWith</a>
--   <tt>(</tt><a>ExitFailure</a> <i>exitfail</i><tt>)</tt>, where
--   <i>exitfail</i> is implementation-dependent.
exitFailure :: IO a

-- | The computation <a>exitSuccess</a> is equivalent to <a>exitWith</a>
--   <a>ExitSuccess</a>, It terminates the program successfully.
exitSuccess :: IO a

-- | Write given error message to <a>stderr</a> and terminate with
--   <a>exitFailure</a>.
die :: String -> IO a


-- | Information about the characteristics of the host system lucky enough
--   to run your program.
module System.Info

-- | The operating system on which the program is running.
os :: String

-- | The machine architecture on which the program is running.
arch :: String

-- | The Haskell implementation with which the program was compiled or is
--   being interpreted.
compilerName :: String

-- | The version of <a>compilerName</a> with which the program was compiled
--   or is being interpreted.
compilerVersion :: Version


-- | Memory-related system things.
module System.Mem

-- | Triggers an immediate garbage collection.
performGC :: IO ()

-- | Triggers an immediate garbage collection.
performMajorGC :: IO ()

-- | Triggers an immediate minor garbage collection.
performMinorGC :: IO ()


-- | Stable names are a way of performing fast (O(1)), not-quite-exact
--   comparison between objects.
--   
--   Stable names solve the following problem: suppose you want to build a
--   hash table with Haskell objects as keys, but you want to use pointer
--   equality for comparison; maybe because the keys are large and hashing
--   would be slow, or perhaps because the keys are infinite in size. We
--   can't build a hash table using the address of the object as the key,
--   because objects get moved around by the garbage collector, meaning a
--   re-hash would be necessary after every garbage collection.
module System.Mem.StableName

-- | An abstract name for an object, that supports equality and hashing.
--   
--   Stable names have the following property:
--   
--   <ul>
--   <li>If <tt>sn1 :: StableName</tt> and <tt>sn2 :: StableName</tt> and
--   <tt>sn1 == sn2</tt> then <tt>sn1</tt> and <tt>sn2</tt> were created by
--   calls to <tt>makeStableName</tt> on the same object.</li>
--   </ul>
--   
--   The reverse is not necessarily true: if two stable names are not
--   equal, then the objects they name may still be equal. Note in
--   particular that <tt>mkStableName</tt> may return a different
--   <a>StableName</a> after an object is evaluated.
--   
--   Stable Names are similar to Stable Pointers
--   (<a>Foreign.StablePtr</a>), but differ in the following ways:
--   
--   <ul>
--   <li>There is no <tt>freeStableName</tt> operation, unlike
--   <a>Foreign.StablePtr</a>s. Stable names are reclaimed by the runtime
--   system when they are no longer needed.</li>
--   <li>There is no <tt>deRefStableName</tt> operation. You can't get back
--   from a stable name to the original Haskell object. The reason for this
--   is that the existence of a stable name for an object does not
--   guarantee the existence of the object itself; it can still be garbage
--   collected.</li>
--   </ul>
data StableName a

-- | Makes a <a>StableName</a> for an arbitrary object. The object passed
--   as the first argument is not evaluated by <a>makeStableName</a>.
makeStableName :: a -> IO (StableName a)

-- | Convert a <a>StableName</a> to an <a>Int</a>. The <a>Int</a> returned
--   is not necessarily unique; several <a>StableName</a>s may map to the
--   same <a>Int</a> (in practice however, the chances of this are small,
--   so the result of <a>hashStableName</a> makes a good hash key).
hashStableName :: StableName a -> Int

-- | Equality on <a>StableName</a> that does not require that the types of
--   the arguments match.
eqStableName :: StableName a -> StableName b -> Bool
instance GHC.Classes.Eq (System.Mem.StableName.StableName a)


-- | In general terms, a weak pointer is a reference to an object that is
--   not followed by the garbage collector - that is, the existence of a
--   weak pointer to an object has no effect on the lifetime of that
--   object. A weak pointer can be de-referenced to find out whether the
--   object it refers to is still alive or not, and if so to return the
--   object itself.
--   
--   Weak pointers are particularly useful for caches and memo tables. To
--   build a memo table, you build a data structure mapping from the
--   function argument (the key) to its result (the value). When you apply
--   the function to a new argument you first check whether the key/value
--   pair is already in the memo table. The key point is that the memo
--   table itself should not keep the key and value alive. So the table
--   should contain a weak pointer to the key, not an ordinary pointer. The
--   pointer to the value must not be weak, because the only reference to
--   the value might indeed be from the memo table.
--   
--   So it looks as if the memo table will keep all its values alive for
--   ever. One way to solve this is to purge the table occasionally, by
--   deleting entries whose keys have died.
--   
--   The weak pointers in this library support another approach, called
--   <i>finalization</i>. When the key referred to by a weak pointer dies,
--   the storage manager arranges to run a programmer-specified finalizer.
--   In the case of memo tables, for example, the finalizer could remove
--   the key/value pair from the memo table.
--   
--   Another difficulty with the memo table is that the value of a
--   key/value pair might itself contain a pointer to the key. So the memo
--   table keeps the value alive, which keeps the key alive, even though
--   there may be no other references to the key so both should die. The
--   weak pointers in this library provide a slight generalisation of the
--   basic weak-pointer idea, in which each weak pointer actually contains
--   both a key and a value.
module System.Mem.Weak

-- | A weak pointer object with a key and a value. The value has type
--   <tt>v</tt>.
--   
--   A weak pointer expresses a relationship between two objects, the
--   <i>key</i> and the <i>value</i>: if the key is considered to be alive
--   by the garbage collector, then the value is also alive. A reference
--   from the value to the key does <i>not</i> keep the key alive.
--   
--   A weak pointer may also have a finalizer of type <tt>IO ()</tt>; if it
--   does, then the finalizer will be run at most once, at a time after the
--   key has become unreachable by the program ("dead"). The storage
--   manager attempts to run the finalizer(s) for an object soon after the
--   object dies, but promptness is not guaranteed.
--   
--   It is not guaranteed that a finalizer will eventually run, and no
--   attempt is made to run outstanding finalizers when the program exits.
--   Therefore finalizers should not be relied on to clean up resources -
--   other methods (eg. exception handlers) should be employed, possibly in
--   addition to finalizers.
--   
--   References from the finalizer to the key are treated in the same way
--   as references from the value to the key: they do not keep the key
--   alive. A finalizer may therefore ressurrect the key, perhaps by
--   storing it in the same data structure.
--   
--   The finalizer, and the relationship between the key and the value,
--   exist regardless of whether the program keeps a reference to the
--   <a>Weak</a> object or not.
--   
--   There may be multiple weak pointers with the same key. In this case,
--   the finalizers for each of these weak pointers will all be run in some
--   arbitrary order, or perhaps concurrently, when the key dies. If the
--   programmer specifies a finalizer that assumes it has the only
--   reference to an object (for example, a file that it wishes to close),
--   then the programmer must ensure that there is only one such finalizer.
--   
--   If there are no other threads to run, the runtime system will check
--   for runnable finalizers before declaring the system to be deadlocked.
--   
--   WARNING: weak pointers to ordinary non-primitive Haskell types are
--   particularly fragile, because the compiler is free to optimise away or
--   duplicate the underlying data structure. Therefore attempting to place
--   a finalizer on an ordinary Haskell type may well result in the
--   finalizer running earlier than you expected. This is not a problem for
--   caches and memo tables where early finalization is benign.
--   
--   Finalizers <i>can</i> be used reliably for types that are created
--   explicitly and have identity, such as <tt>IORef</tt> and
--   <tt>MVar</tt>. However, to place a finalizer on one of these types,
--   you should use the specific operation provided for that type, e.g.
--   <tt>mkWeakIORef</tt> and <tt>addMVarFinalizer</tt> respectively (the
--   non-uniformity is accidental). These operations attach the finalizer
--   to the primitive object inside the box (e.g. <tt>MutVar#</tt> in the
--   case of <tt>IORef</tt>), because attaching the finalizer to the box
--   itself fails when the outer box is optimised away by the compiler.
data Weak v

-- | Establishes a weak pointer to <tt>k</tt>, with value <tt>v</tt> and a
--   finalizer.
--   
--   This is the most general interface for building a weak pointer.
mkWeak :: k -> v -> Maybe (IO ()) -> IO (Weak v)

-- | Dereferences a weak pointer. If the key is still alive, then
--   <tt><a>Just</a> v</tt> is returned (where <tt>v</tt> is the
--   <i>value</i> in the weak pointer), otherwise <a>Nothing</a> is
--   returned.
--   
--   The return value of <a>deRefWeak</a> depends on when the garbage
--   collector runs, hence it is in the <a>IO</a> monad.
deRefWeak :: Weak v -> IO (Maybe v)

-- | Causes a the finalizer associated with a weak pointer to be run
--   immediately.
finalize :: Weak v -> IO ()

-- | A specialised version of <a>mkWeak</a>, where the key and the value
--   are the same object:
--   
--   <pre>
--   mkWeakPtr key finalizer = mkWeak key key finalizer
--   </pre>
mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k)

-- | A specialised version of <a>mkWeakPtr</a>, where the <a>Weak</a>
--   object returned is simply thrown away (however the finalizer will be
--   remembered by the garbage collector, and will still be run when the
--   key becomes unreachable).
--   
--   Note: adding a finalizer to a <a>ForeignPtr</a> using
--   <a>addFinalizer</a> won't work; use the specialised version
--   <a>addForeignPtrFinalizer</a> instead. For discussion see the
--   <a>Weak</a> type. .
addFinalizer :: key -> IO () -> IO ()

-- | A specialised version of <a>mkWeak</a> where the value is actually a
--   pair of the key and value passed to <a>mkWeakPair</a>:
--   
--   <pre>
--   mkWeakPair key val finalizer = mkWeak key (key,val) finalizer
--   </pre>
--   
--   The advantage of this is that the key can be retrieved by
--   <a>deRefWeak</a> in addition to the value.
mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k, v))


-- | Attach a timeout event to arbitrary <a>IO</a> computations.
module System.Timeout

-- | Wrap an <a>IO</a> computation to time out and return <tt>Nothing</tt>
--   in case no result is available within <tt>n</tt> microseconds
--   (<tt>1/10^6</tt> seconds). In case a result is available before the
--   timeout expires, <tt>Just a</tt> is returned. A negative timeout
--   interval means "wait indefinitely". When specifying long timeouts, be
--   careful not to exceed <tt>maxBound :: Int</tt>.
--   
--   The design of this combinator was guided by the objective that
--   <tt>timeout n f</tt> should behave exactly the same as <tt>f</tt> as
--   long as <tt>f</tt> doesn't time out. This means that <tt>f</tt> has
--   the same <a>myThreadId</a> it would have without the timeout wrapper.
--   Any exceptions <tt>f</tt> might throw cancel the timeout and propagate
--   further up. It also possible for <tt>f</tt> to receive exceptions
--   thrown to it by another thread.
--   
--   A tricky implementation detail is the question of how to abort an
--   <tt>IO</tt> computation. This combinator relies on asynchronous
--   exceptions internally. The technique works very well for computations
--   executing inside of the Haskell runtime system, but it doesn't work at
--   all for non-Haskell code. Foreign function calls, for example, cannot
--   be timed out with this combinator simply because an arbitrary C
--   function cannot receive asynchronous exceptions. When <tt>timeout</tt>
--   is used to wrap an FFI call that blocks, no timeout event can be
--   delivered until the FFI call returns, which pretty much negates the
--   purpose of the combinator. In practice, however, this limitation is
--   less severe than it may sound. Standard I/O functions like
--   <a>hGetBuf</a>, <a>hPutBuf</a>, Network.Socket.accept, or
--   <a>hWaitForInput</a> appear to be blocking, but they really don't
--   because the runtime system uses scheduling mechanisms like
--   <tt>select(2)</tt> to perform asynchronous I/O, so it is possible to
--   interrupt standard socket I/O or file I/O using this combinator.
timeout :: Int -> IO a -> IO (Maybe a)
instance GHC.Classes.Eq System.Timeout.Timeout
instance GHC.Show.Show System.Timeout.Timeout
instance GHC.Exception.Exception System.Timeout.Timeout


-- | A C <tt>printf(3)</tt>-like formatter. This version has been extended
--   by Bart Massey as per the recommendations of John Meacham and Simon
--   Marlow
--   &lt;<a>http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726</a>&gt;
--   to support extensible formatting for new datatypes. It has also been
--   extended to support almost all C <tt>printf(3)</tt> syntax.
module Text.Printf

-- | Format a variable number of arguments with the C-style formatting
--   string. The return value is either <a>String</a> or <tt>(<a>IO</a>
--   a)</tt> (which should be <tt>(<a>IO</a> '()')</tt>, but Haskell's type
--   system makes this hard).
--   
--   The format string consists of ordinary characters and <i>conversion
--   specifications</i>, which specify how to format one of the arguments
--   to <a>printf</a> in the output string. A format specification is
--   introduced by the <tt>%</tt> character; this character can be
--   self-escaped into the format string using <tt>%%</tt>. A format
--   specification ends with a /format character/ that provides the primary
--   information about how to format the value. The rest of the conversion
--   specification is optional. In order, one may have flag characters, a
--   width specifier, a precision specifier, and type-specific modifier
--   characters.
--   
--   Unlike C <tt>printf(3)</tt>, the formatting of this <a>printf</a> is
--   driven by the argument type; formatting is type specific. The types
--   formatted by <a>printf</a> "out of the box" are:
--   
--   <ul>
--   <li><a>Integral</a> types, including <a>Char</a></li>
--   <li><a>String</a></li>
--   <li><a>RealFloat</a> types</li>
--   </ul>
--   
--   <a>printf</a> is also extensible to support other types: see below.
--   
--   A conversion specification begins with the character <tt>%</tt>,
--   followed by zero or more of the following flags:
--   
--   <pre>
--   -      left adjust (default is right adjust)
--   +      always use a sign (+ or -) for signed conversions
--   space  leading space for positive numbers in signed conversions
--   0      pad with zeros rather than spaces
--   #      use an \"alternate form\": see below
--   </pre>
--   
--   When both flags are given, <tt>-</tt> overrides <tt>0</tt> and
--   <tt>+</tt> overrides space. A negative width specifier in a <tt>*</tt>
--   conversion is treated as positive but implies the left adjust flag.
--   
--   The "alternate form" for unsigned radix conversions is as in C
--   <tt>printf(3)</tt>:
--   
--   <pre>
--   %o           prefix with a leading 0 if needed
--   %x           prefix with a leading 0x if nonzero
--   %X           prefix with a leading 0X if nonzero
--   %b           prefix with a leading 0b if nonzero
--   %[eEfFgG]    ensure that the number contains a decimal point
--   </pre>
--   
--   Any flags are followed optionally by a field width:
--   
--   <pre>
--   num    field width
--   *      as num, but taken from argument list
--   </pre>
--   
--   The field width is a minimum, not a maximum: it will be expanded as
--   needed to avoid mutilating a value.
--   
--   Any field width is followed optionally by a precision:
--   
--   <pre>
--   .num   precision
--   .      same as .0
--   .*     as num, but taken from argument list
--   </pre>
--   
--   Negative precision is taken as 0. The meaning of the precision depends
--   on the conversion type.
--   
--   <pre>
--   Integral    minimum number of digits to show
--   RealFloat   number of digits after the decimal point
--   String      maximum number of characters
--   </pre>
--   
--   The precision for Integral types is accomplished by zero-padding. If
--   both precision and zero-pad are given for an Integral field, the
--   zero-pad is ignored.
--   
--   Any precision is followed optionally for Integral types by a width
--   modifier; the only use of this modifier being to set the implicit size
--   of the operand for conversion of a negative operand to unsigned:
--   
--   <pre>
--   hh     Int8
--   h      Int16
--   l      Int32
--   ll     Int64
--   L      Int64
--   </pre>
--   
--   The specification ends with a format character:
--   
--   <pre>
--   c      character               Integral
--   d      decimal                 Integral
--   o      octal                   Integral
--   x      hexadecimal             Integral
--   X      hexadecimal             Integral
--   b      binary                  Integral
--   u      unsigned decimal        Integral
--   f      floating point          RealFloat
--   F      floating point          RealFloat
--   g      general format float    RealFloat
--   G      general format float    RealFloat
--   e      exponent format float   RealFloat
--   E      exponent format float   RealFloat
--   s      string                  String
--   v      default format          any type
--   </pre>
--   
--   The "%v" specifier is provided for all built-in types, and should be
--   provided for user-defined type formatters as well. It picks a "best"
--   representation for the given type. For the built-in types the "%v"
--   specifier is converted as follows:
--   
--   <pre>
--   c      Char
--   u      other unsigned Integral
--   d      other signed Integral
--   g      RealFloat
--   s      String
--   </pre>
--   
--   Mismatch between the argument types and the format string, as well as
--   any other syntactic or semantic errors in the format string, will
--   cause an exception to be thrown at runtime.
--   
--   Note that the formatting for <a>RealFloat</a> types is currently a bit
--   different from that of C <tt>printf(3)</tt>, conforming instead to
--   <a>showEFloat</a>, <a>showFFloat</a> and <a>showGFloat</a> (and their
--   alternate versions <a>showFFloatAlt</a> and <a>showGFloatAlt</a>).
--   This is hard to fix: the fixed versions would format in a
--   backward-incompatible way. In any case the Haskell behavior is
--   generally more sensible than the C behavior. A brief summary of some
--   key differences:
--   
--   <ul>
--   <li>Haskell <a>printf</a> never uses the default "6-digit" precision
--   used by C printf.</li>
--   <li>Haskell <a>printf</a> treats the "precision" specifier as
--   indicating the number of digits after the decimal point.</li>
--   <li>Haskell <a>printf</a> prints the exponent of e-format numbers
--   without a gratuitous plus sign, and with the minimum possible number
--   of digits.</li>
--   <li>Haskell <a>printf</a> will place a zero after a decimal point when
--   possible.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; printf "%d\n" (23::Int)
--   23
--   &gt; printf "%s %s\n" "Hello" "World"
--   Hello World
--   &gt; printf "%.2f\n" pi
--   3.14
--   </pre>
printf :: (PrintfType r) => String -> r

-- | Similar to <a>printf</a>, except that output is via the specified
--   <a>Handle</a>. The return type is restricted to <tt>(<a>IO</a>
--   a)</tt>.
hPrintf :: (HPrintfType r) => Handle -> String -> r

-- | Typeclass of <a>printf</a>-formattable values. The <a>formatArg</a>
--   method takes a value and a field format descriptor and either fails
--   due to a bad descriptor or produces a <a>ShowS</a> as the result. The
--   default <a>parseFormat</a> expects no modifiers: this is the normal
--   case. Minimal instance: <a>formatArg</a>.
class PrintfArg a where parseFormat _ (c : cs) = FormatParse "" c cs parseFormat _ "" = errorShortFormat

formatArg :: PrintfArg a => a -> FieldFormatter

parseFormat :: PrintfArg a => a -> ModifierParser

-- | This is the type of a field formatter reified over its argument.
type FieldFormatter = FieldFormat -> ShowS

-- | Description of field formatting for <a>formatArg</a>. See UNIX
--   <a>printf</a>(3) for a description of how field formatting works.
data FieldFormat
FieldFormat :: Maybe Int -> Maybe Int -> Maybe FormatAdjustment -> Maybe FormatSign -> Bool -> String -> Char -> FieldFormat

-- | Total width of the field.
[fmtWidth] :: FieldFormat -> Maybe Int

-- | Secondary field width specifier.
[fmtPrecision] :: FieldFormat -> Maybe Int

-- | Kind of filling or padding to be done.
[fmtAdjust] :: FieldFormat -> Maybe FormatAdjustment

-- | Whether to insist on a plus sign for positive numbers.
[fmtSign] :: FieldFormat -> Maybe FormatSign

-- | Indicates an "alternate format". See printf(3) for the details, which
--   vary by argument spec.
[fmtAlternate] :: FieldFormat -> Bool

-- | Characters that appeared immediately to the left of <a>fmtChar</a> in
--   the format and were accepted by the type's <a>parseFormat</a>.
--   Normally the empty string.
[fmtModifiers] :: FieldFormat -> String

-- | The format character <a>printf</a> was invoked with. <a>formatArg</a>
--   should fail unless this character matches the type. It is normal to
--   handle many different format characters for a single type.
[fmtChar] :: FieldFormat -> Char

-- | Whether to left-adjust or zero-pad a field. These are mutually
--   exclusive, with <a>LeftAdjust</a> taking precedence.
data FormatAdjustment
LeftAdjust :: FormatAdjustment
ZeroPad :: FormatAdjustment

-- | How to handle the sign of a numeric field. These are mutually
--   exclusive, with <a>SignPlus</a> taking precedence.
data FormatSign
SignPlus :: FormatSign
SignSpace :: FormatSign

-- | Substitute a 'v' format character with the given default format
--   character in the <a>FieldFormat</a>. A convenience for
--   user-implemented types, which should support "%v".
vFmt :: Char -> FieldFormat -> FieldFormat

-- | Type of a function that will parse modifier characters from the format
--   string.
type ModifierParser = String -> FormatParse

-- | The "format parser" walks over argument-type-specific modifier
--   characters to find the primary format character. This is the type of
--   its result.
data FormatParse
FormatParse :: String -> Char -> String -> FormatParse

-- | Any modifiers found.
[fpModifiers] :: FormatParse -> String

-- | Primary format character.
[fpChar] :: FormatParse -> Char

-- | Rest of the format string.
[fpRest] :: FormatParse -> String

-- | Formatter for <a>String</a> values.
formatString :: IsChar a => [a] -> FieldFormatter

-- | Formatter for <a>Char</a> values.
formatChar :: Char -> FieldFormatter

-- | Formatter for <a>Int</a> values.
formatInt :: (Integral a, Bounded a) => a -> FieldFormatter

-- | Formatter for <a>Integer</a> values.
formatInteger :: Integer -> FieldFormatter

-- | Formatter for <a>RealFloat</a> values.
formatRealFloat :: RealFloat a => a -> FieldFormatter

-- | Calls <a>perror</a> to indicate an unknown format letter for a given
--   type.
errorBadFormat :: Char -> a

-- | Calls <a>perror</a> to indicate that the format string ended early.
errorShortFormat :: a

-- | Calls <a>perror</a> to indicate that there is a missing argument in
--   the argument list.
errorMissingArgument :: a

-- | Calls <a>perror</a> to indicate that there is a type error or similar
--   in the given argument.
errorBadArgument :: a

-- | Raises an <a>error</a> with a printf-specific prefix on the message
--   string.
perror :: String -> a

-- | The <a>PrintfType</a> class provides the variable argument magic for
--   <a>printf</a>. Its implementation is intentionally not visible from
--   this module. If you attempt to pass an argument of a type which is not
--   an instance of this class to <a>printf</a> or <a>hPrintf</a>, then the
--   compiler will report it as a missing instance of <a>PrintfArg</a>.
class PrintfType t

-- | The <a>HPrintfType</a> class provides the variable argument magic for
--   <a>hPrintf</a>. Its implementation is intentionally not visible from
--   this module.
class HPrintfType t

-- | This class, with only the one instance, is used as a workaround for
--   the fact that <a>String</a>, as a concrete type, is not allowable as a
--   typeclass instance. <a>IsChar</a> is exported for
--   backward-compatibility.
class IsChar c

toChar :: IsChar c => c -> Char

fromChar :: IsChar c => Char -> c
instance Text.Printf.IsChar c => Text.Printf.PrintfType [c]
instance (a ~ ()) => Text.Printf.PrintfType (GHC.Types.IO a)
instance (a ~ ()) => Text.Printf.HPrintfType (GHC.Types.IO a)
instance (Text.Printf.PrintfArg a, Text.Printf.PrintfType r) => Text.Printf.PrintfType (a -> r)
instance (Text.Printf.PrintfArg a, Text.Printf.HPrintfType r) => Text.Printf.HPrintfType (a -> r)
instance Text.Printf.PrintfArg GHC.Types.Char
instance Text.Printf.IsChar c => Text.Printf.PrintfArg [c]
instance Text.Printf.PrintfArg GHC.Types.Int
instance Text.Printf.PrintfArg GHC.Int.Int8
instance Text.Printf.PrintfArg GHC.Int.Int16
instance Text.Printf.PrintfArg GHC.Int.Int32
instance Text.Printf.PrintfArg GHC.Int.Int64
instance Text.Printf.PrintfArg GHC.Types.Word
instance Text.Printf.PrintfArg GHC.Word.Word8
instance Text.Printf.PrintfArg GHC.Word.Word16
instance Text.Printf.PrintfArg GHC.Word.Word32
instance Text.Printf.PrintfArg GHC.Word.Word64
instance Text.Printf.PrintfArg GHC.Integer.Type.Integer
instance Text.Printf.PrintfArg GHC.Natural.Natural
instance Text.Printf.PrintfArg GHC.Types.Float
instance Text.Printf.PrintfArg GHC.Types.Double
instance Text.Printf.IsChar GHC.Types.Char


-- | Optional instance of <a>Show</a> for functions:
--   
--   <pre>
--   instance Show (a -&gt; b) where
--      showsPrec _ _ = showString \"\&lt;function\&gt;\"
--   </pre>
module Text.Show.Functions
instance GHC.Show.Show (a -> b)

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.TASequence</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-TASequence.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">type-aligned-0.9.6: Various type-aligned sequence data structures.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Atze van der Ploeg 2014</td></tr><tr><th>License</th><td>BSD-style</td></tr><tr><th>Maintainer</th><td>atzeus@gmail.org</td></tr><tr><th>Stability</th><td>provisional</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.TASequence</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A type class for type aligned sequences: heterogeneous
 sequences where the types enforce the element order.</p><p>Type aligned sequences are best explained by an example: a type
 aligned sequence of functions is a sequence f 1 , f 2 , f 3 ... f n such that
 the composition of these functions f 1 &#9702; f 2 &#9702; f 3 &#9702; ... &#9702; f n is well typed.
 In other words: the result type of each function in the sequence
 must be the same as the argument type of the next function (if any).
 In general, the elements of a type aligned sequence do not have to
 be functions, i.e. values of type a &#8594; b, but can be values of type
 (c a b), for some binary type constructor c. Hence, we define a type
 aligned sequence to be a sequence of elements of the type (c a_i b_i )
 with the side-condition b_i&#8722;1 = a_i . If s is the type of a type aligned
 sequence data structure, then (s c a b) is the type of a type aligned
 sequence where the first element has type (c a x), for some x, and
 the last element has type (c y b), for some y.</p><p>The simplest type aligned sequence data structure is a list, see <a href="Data-TASequence-ConsList.html">Data.TASequence.ConsList</a>. The other modules
 give various other type aligned sequence data structures. The data structure <a href="Data-TASequence-FastCatQueue.html">Data.TASequence.FastCatQueue</a> supports the most operations in worst case constant time.</p><p>See the paper Reflection without Remorse: Revealing a hidden sequence to speed up Monadic Reflection, Atze van der Ploeg and Oleg Kiselyov, Haskell Symposium 2014
 for more details.</p><p>Paper: <a href="http://homepages.cwi.nl/~ploeg/zseq.pdf">http://homepages.cwi.nl/~ploeg/zseq.pdf</a>
 Talk : <a href="http://www.youtube.com/watch?v=_XoI65Rxmss">http://www.youtube.com/watch?v=_XoI65Rxmss</a></p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> <a href="#t:TASequence">TASequence</a> s <span class="keyword">where</span><ul class="subs"><li><a href="#v:tempty">tempty</a> :: s c x x</li><li><a href="#v:tsingleton">tsingleton</a> :: c x y -&gt; s c x y</li><li><a href="#v:-62--60-">(&gt;&lt;)</a> :: s c x y -&gt; s c y z -&gt; s c x z</li><li><a href="#v:tviewl">tviewl</a> :: s c x y -&gt; <a href="Data-TASequence.html#t:TAViewL">TAViewL</a> s c x y</li><li><a href="#v:tviewr">tviewr</a> :: s c x y -&gt; <a href="Data-TASequence.html#t:TAViewR">TAViewR</a> s c x y</li><li><a href="#v:-124--62-">(|&gt;)</a> :: s c x y -&gt; c y z -&gt; s c x z</li><li><a href="#v:-60--124-">(&lt;|)</a> :: c x y -&gt; s c y z -&gt; s c x z</li><li><a href="#v:tmap">tmap</a> :: (<span class="keyword">forall</span> x y. c x y -&gt; d x y) -&gt; s c x y -&gt; s d x y</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:TAViewL">TAViewL</a> s c x y <span class="keyword">where</span><ul class="subs"><li><a href="#v:TAEmptyL">TAEmptyL</a> ::  <a href="Data-TASequence.html#t:TAViewL">TAViewL</a> s c x x</li><li><a href="#v::-60-">(:&lt;)</a> ::  c x y -&gt; s c y z -&gt; <a href="Data-TASequence.html#t:TAViewL">TAViewL</a> s c x z</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:TAViewR">TAViewR</a> s c x y <span class="keyword">where</span><ul class="subs"><li><a href="#v:TAEmptyR">TAEmptyR</a> ::  <a href="Data-TASequence.html#t:TAViewR">TAViewR</a> s c x x</li><li><a href="#v::-62-">(:&gt;)</a> ::  s c x y -&gt; c y z -&gt; <a href="Data-TASequence.html#t:TAViewR">TAViewR</a> s c x z</li></ul></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:TASequence" class="def">TASequence</a> s <span class="keyword">where</span></p><div class="doc"><p>A type class for type aligned sequences</p><p>Minimal complete defention: <code><a href="Data-TASequence.html#v:tempty">tempty</a></code> and <code><a href="Data-TASequence.html#v:tsingleton">tsingleton</a></code> and (<code><a href="Data-TASequence.html#v:tviewl">tviewl</a></code> or <code><a href="Data-TASequence.html#v:tviewr">tviewr</a></code>) and (<code><a href="Data-TASequence.html#v:-62--60-">&gt;&lt;</a></code> or <code><a href="Data-TASequence.html#v:-124--62-">|&gt;</a></code> or <code><a href="Data-TASequence.html#v:-60--124-">&lt;|</a></code>)</p><p>Instances should satisfy the following laws:</p><p>Category laws:</p><pre>tempty &gt;&lt; x == x
x &gt;&lt; tempty == x
(x &gt;&lt; y) &gt;&lt; z = x &gt;&lt; (y &gt;&lt; z)</pre><p>Observation laws:</p><pre>tviewl (tsingleton e &gt;&lt; s) == e :&lt; s
tviewl tempty == TAEmptyL</pre><p>The behaviour of <code><a href="Data-TASequence.html#v:-60--124-">&lt;|</a></code>,<code><a href="Data-TASequence.html#v:-124--62-">|&gt;</a></code>, <code><a href="Data-TASequence.html#v:tmap">tmap</a></code> and <code><a href="Data-TASequence.html#v:tviewr">tviewr</a></code> is implied by the above laws and their default definitions.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Data-TASequence.html#v:tempty">tempty</a>, <a href="Data-TASequence.html#v:tsingleton">tsingleton</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:tempty" class="def">tempty</a> :: s c x x</p><p class="src"><a name="v:tsingleton" class="def">tsingleton</a> :: c x y -&gt; s c x y</p><p class="src"><a name="v:-62--60-" class="def">(&gt;&lt;)</a> :: s c x y -&gt; s c y z -&gt; s c x z <span class="fixity">infix 5</span><span class="rightedge"></span></p><div class="doc"><p>Append two type aligned sequences</p></div><p class="src"><a name="v:tviewl" class="def">tviewl</a> :: s c x y -&gt; <a href="Data-TASequence.html#t:TAViewL">TAViewL</a> s c x y</p><div class="doc"><p>View a type aligned sequence from the left</p></div><p class="src"><a name="v:tviewr" class="def">tviewr</a> :: s c x y -&gt; <a href="Data-TASequence.html#t:TAViewR">TAViewR</a> s c x y</p><div class="doc"><p>View a type aligned sequence from the right</p><p>Default definition:</p><pre>tviewr q = case tviewl q of 
  TAEmptyL -&gt; TAEmptyR
  h :&lt; t -&gt; case tviewr t of
       TAEmptyR -&gt; tempty   :&gt; h
       p :&gt; l   -&gt; (h &lt;| p) :&gt; l</pre></div><p class="src"><a name="v:-124--62-" class="def">(|&gt;)</a> :: s c x y -&gt; c y z -&gt; s c x z <span class="fixity">infixl 5</span><span class="rightedge"></span></p><div class="doc"><p>Append a single element to the right</p><p>Default definition:</p><pre>l |&gt; r = l &gt;&lt; tsingleton r</pre></div><p class="src"><a name="v:-60--124-" class="def">(&lt;|)</a> :: c x y -&gt; s c y z -&gt; s c x z <span class="fixity">infixr 5</span><span class="rightedge"></span></p><div class="doc"><p>Append a single element to the left</p><p>Default definition:</p><pre>l &lt;| r = tsingleton l &gt;&lt; r</pre></div><p class="src"><a name="v:tmap" class="def">tmap</a> :: (<span class="keyword">forall</span> x y. c x y -&gt; d x y) -&gt; s c x y -&gt; s d x y</p><div class="doc"><p>Apply a function to all elements in a type aligned sequence</p><p>Default definition:</p><pre>tmap f q = case tviewl q of
   TAEmptyL -&gt; tempty
   h :&lt; t -&gt; f h &lt;| tmap f t</pre></div></div><div class="subs instances"><p id="control.i:TASequence" class="caption collapser" onclick="toggleSection('i:TASequence')">Instances</p><div id="section.i:TASequence" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="Data-TASequence.html#t:TASequence">TASequence</a> <a href="Data-TASequence-BinaryTree.html#t:BinaryTree">BinaryTree</a></span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Data-TASequence.html#t:TASequence">TASequence</a> <a href="Data-TASequence-ConsList.html#t:ConsList">ConsList</a></span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Data-TASequence.html#t:TASequence">TASequence</a> <a href="Data-TASequence-SnocList.html#t:SnocList">SnocList</a></span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Data-TASequence.html#t:TASequence">TASequence</a> <a href="Data-TASequence-FastQueue.html#t:FastQueue">FastQueue</a></span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Data-TASequence.html#t:TASequence">TASequence</a> <a href="Data-TASequence-FingerTree.html#t:FingerTree">FingerTree</a></span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Data-TASequence.html#t:TASequence">TASequence</a> <a href="Data-TASequence-Queue.html#t:Queue">Queue</a></span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Data-TASequence.html#t:TASequence">TASequence</a> q =&gt; <a href="Data-TASequence.html#t:TASequence">TASequence</a> (<a href="Data-TASequence-ToCatQueue.html#t:ToCatQueue">ToCatQueue</a> q)</span></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:TAViewL" class="def">TAViewL</a> s c x y <span class="keyword">where</span></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:TAEmptyL" class="def">TAEmptyL</a> ::  <a href="Data-TASequence.html#t:TAViewL">TAViewL</a> s c x x</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v::-60-" class="def">(:&lt;)</a> ::  c x y -&gt; s c y z -&gt; <a href="Data-TASequence.html#t:TAViewL">TAViewL</a> s c x z</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:TAViewR" class="def">TAViewR</a> s c x y <span class="keyword">where</span></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:TAEmptyR" class="def">TAEmptyR</a> ::  <a href="Data-TASequence.html#t:TAViewR">TAViewR</a> s c x x</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v::-62-" class="def">(:&gt;)</a> ::  s c x y -&gt; c y z -&gt; <a href="Data-TASequence.html#t:TAViewR">TAViewR</a> s c x z</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>
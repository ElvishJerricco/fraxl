-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Concrete functor and monad transformers
--   
--   A portable library of functor and monad transformers, inspired by the
--   paper "Functional Programming with Overloading and Higher-Order
--   Polymorphism", by Mark P Jones, in <i>Advanced School of Functional
--   Programming</i>, 1995
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>).
--   
--   This package contains:
--   
--   <ul>
--   <li>the monad transformer class (in <a>Control.Monad.Trans.Class</a>)
--   and IO monad class (in <a>Control.Monad.IO.Class</a>)</li>
--   <li>concrete functor and monad transformers, each with associated
--   operations and functions to lift operations associated with other
--   transformers.</li>
--   </ul>
--   
--   The package can be used on its own in portable Haskell code, in which
--   case operations need to be manually lifted through transformer stacks
--   (see <a>Control.Monad.Trans.Class</a> for some examples).
--   Alternatively, it can be used with the non-portable monad classes in
--   the <tt>mtl</tt> or <tt>monads-tf</tt> packages, which automatically
--   lift operations introduced by monad transformers through other
--   transformers.
@package transformers
@version 0.4.2.0


-- | The class of monad transformers.
--   
--   A monad transformer makes a new monad out of an existing monad, such
--   that computations of the old monad may be embedded in the new one. To
--   construct a monad with a desired set of features, one typically starts
--   with a base monad, such as <a>Identity</a>, <tt>[]</tt> or <a>IO</a>,
--   and applies a sequence of monad transformers.
module Control.Monad.Trans.Class

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans t

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a


-- | Signatures for monad operations that require specialized lifting.
module Control.Monad.Signatures

-- | Signature of the <tt>callCC</tt> operation, introduced in
--   <a>Control.Monad.Trans.Cont</a>.
type CallCC m a b = ((a -> m b) -> m a) -> m a

-- | Signature of the <tt>catchE</tt> operation, introduced in
--   <a>Control.Monad.Trans.Except</a>.
type Catch e m a = m a -> (e -> m a) -> m a

-- | Signature of the <tt>listen</tt> operation, introduced in
--   <a>Control.Monad.Trans.Writer</a>.
type Listen w m a = m a -> m (a, w)

-- | Signature of the <tt>pass</tt> operation, introduced in
--   <a>Control.Monad.Trans.Writer</a>.
type Pass w m a = m (a, w -> w) -> m a


-- | Class of monads based on <tt>IO</tt>.
module Control.Monad.IO.Class

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class (Monad m) => MonadIO m

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a
instance Control.Monad.IO.Class.MonadIO GHC.Types.IO


-- | Continuation monads.
--   
--   Delimited continuation operators are taken from Kenichi Asai and Oleg
--   Kiselyov's tutorial at CW 2011, "Introduction to programming with
--   shift and reset"
--   (<a>http://okmij.org/ftp/continuations/#tutorial</a>).
module Control.Monad.Trans.Cont

-- | Continuation monad. <tt>Cont r a</tt> is a CPS computation that
--   produces an intermediate result of type <tt>a</tt> within a CPS
--   computation whose final result type is <tt>r</tt>.
--   
--   The <tt>return</tt> function simply creates a continuation which
--   passes the value on.
--   
--   The <tt>&gt;&gt;=</tt> operator adds the bound function into the
--   continuation chain.
type Cont r = ContT r Identity

-- | Construct a continuation-passing computation from a function. (The
--   inverse of <a>runCont</a>)
cont :: ((a -> r) -> r) -> Cont r a

-- | The result of running a CPS computation with a given final
--   continuation. (The inverse of <a>cont</a>)
runCont :: Cont r a -> (a -> r) -> r

-- | The result of running a CPS computation with the identity as the final
--   continuation.
--   
--   <ul>
--   <li><pre><a>evalCont</a> (<a>return</a> x) = x</pre></li>
--   </ul>
evalCont :: Cont r r -> r

-- | Apply a function to transform the result of a continuation-passing
--   computation.
--   
--   <ul>
--   <li><pre><a>runCont</a> (<a>mapCont</a> f m) = f . <a>runCont</a>
--   m</pre></li>
--   </ul>
mapCont :: (r -> r) -> Cont r a -> Cont r a

-- | Apply a function to transform the continuation passed to a CPS
--   computation.
--   
--   <ul>
--   <li><pre><a>runCont</a> (<a>withCont</a> f m) = <a>runCont</a> m .
--   f</pre></li>
--   </ul>
withCont :: ((b -> r) -> (a -> r)) -> Cont r a -> Cont r b

-- | <tt><a>reset</a> m</tt> delimits the continuation of any <a>shift</a>
--   inside <tt>m</tt>.
--   
--   <ul>
--   <li><pre><a>reset</a> (<a>return</a> m) = <a>return</a> m</pre></li>
--   </ul>
reset :: Cont r r -> Cont r' r

-- | <tt><a>shift</a> f</tt> captures the continuation up to the nearest
--   enclosing <a>reset</a> and passes it to <tt>f</tt>:
--   
--   <ul>
--   <li><pre><a>reset</a> (<a>shift</a> f &gt;&gt;= k) = <a>reset</a> (f
--   (<a>evalCont</a> . k))</pre></li>
--   </ul>
shift :: ((a -> r) -> Cont r r) -> Cont r a

-- | The continuation monad transformer. Can be used to add continuation
--   handling to other monads.
newtype ContT r m a
ContT :: ((a -> m r) -> m r) -> ContT r m a
[runContT] :: ContT r m a -> (a -> m r) -> m r

-- | The result of running a CPS computation with <a>return</a> as the
--   final continuation.
--   
--   <ul>
--   <li><pre><a>evalContT</a> (<a>lift</a> m) = m</pre></li>
--   </ul>
evalContT :: (Monad m) => ContT r m r -> m r

-- | Apply a function to transform the result of a continuation-passing
--   computation.
--   
--   <ul>
--   <li><pre><a>runContT</a> (<a>mapContT</a> f m) = f . <a>runContT</a>
--   m</pre></li>
--   </ul>
mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a

-- | Apply a function to transform the continuation passed to a CPS
--   computation.
--   
--   <ul>
--   <li><pre><a>runContT</a> (<a>withContT</a> f m) = <a>runContT</a> m .
--   f</pre></li>
--   </ul>
withContT :: ((b -> m r) -> (a -> m r)) -> ContT r m a -> ContT r m b

-- | <tt>callCC</tt> (call-with-current-continuation) calls its argument
--   function, passing it the current continuation. It provides an escape
--   continuation mechanism for use with continuation monads. Escape
--   continuations one allow to abort the current computation and return a
--   value immediately. They achieve a similar effect to <a>throwE</a> and
--   <a>catchE</a> within an <a>ExceptT</a> monad. The advantage of this
--   function over calling <a>return</a> is that it makes the continuation
--   explicit, allowing more flexibility and better control.
--   
--   The standard idiom used with <tt>callCC</tt> is to provide a
--   lambda-expression to name the continuation. Then calling the named
--   continuation anywhere within its scope will escape from the
--   computation, even if it is many layers deep within nested
--   computations.
callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a

-- | <tt><a>resetT</a> m</tt> delimits the continuation of any
--   <a>shiftT</a> inside <tt>m</tt>.
--   
--   <ul>
--   <li><pre><a>resetT</a> (<a>lift</a> m) = <a>lift</a> m</pre></li>
--   </ul>
resetT :: (Monad m) => ContT r m r -> ContT r' m r

-- | <tt><a>shiftT</a> f</tt> captures the continuation up to the nearest
--   enclosing <a>resetT</a> and passes it to <tt>f</tt>:
--   
--   <ul>
--   <li><pre><a>resetT</a> (<a>shiftT</a> f &gt;&gt;= k) = <a>resetT</a>
--   (f (<a>evalContT</a> . k))</pre></li>
--   </ul>
shiftT :: (Monad m) => ((a -> m r) -> ContT r m r) -> ContT r m a

-- | <tt><a>liftLocal</a> ask local</tt> yields a <tt>local</tt> function
--   for <tt><a>ContT</a> r m</tt>.
liftLocal :: (Monad m) => m r' -> ((r' -> r') -> m r -> m r) -> (r' -> r') -> ContT r m a -> ContT r m a
instance GHC.Base.Functor (Control.Monad.Trans.Cont.ContT r m)
instance GHC.Base.Applicative (Control.Monad.Trans.Cont.ContT r m)
instance GHC.Base.Monad (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Cont.ContT r)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Cont.ContT r m)


-- | Declaration of the <a>ReaderT</a> monad transformer, which adds a
--   static environment to a given monad.
--   
--   If the computation is to modify the stored information, use
--   <a>Control.Monad.Trans.State</a> instead.
module Control.Monad.Trans.Reader

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
type Reader r = ReaderT r Identity

-- | Constructor for computations in the reader monad (equivalent to
--   <a>asks</a>).
reader :: (Monad m) => (r -> a) -> ReaderT r m a

-- | Runs a <tt>Reader</tt> and extracts the final value from it. (The
--   inverse of <a>reader</a>.)
runReader :: Reader r a -> r -> a

-- | Transform the value returned by a <tt>Reader</tt>.
--   
--   <ul>
--   <li><pre><a>runReader</a> (<a>mapReader</a> f m) = f .
--   <a>runReader</a> m</pre></li>
--   </ul>
mapReader :: (a -> b) -> Reader r a -> Reader r b

-- | Execute a computation in a modified environment (a specialization of
--   <a>withReaderT</a>).
--   
--   <ul>
--   <li><pre><a>runReader</a> (<a>withReader</a> f m) = <a>runReader</a> m
--   . f</pre></li>
--   </ul>
withReader :: (r' -> r) -> Reader r a -> Reader r' a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype ReaderT r m a
ReaderT :: (r -> m a) -> ReaderT r m a
[runReaderT] :: ReaderT r m a -> r -> m a

-- | Transform the computation inside a <tt>ReaderT</tt>.
--   
--   <ul>
--   <li><pre><a>runReaderT</a> (<a>mapReaderT</a> f m) = f .
--   <a>runReaderT</a> m</pre></li>
--   </ul>
mapReaderT :: (m a -> n b) -> ReaderT r m a -> ReaderT r n b

-- | Execute a computation in a modified environment (a more general
--   version of <a>local</a>).
--   
--   <ul>
--   <li><pre><a>runReaderT</a> (<a>withReaderT</a> f m) =
--   <a>runReaderT</a> m . f</pre></li>
--   </ul>
withReaderT :: (r' -> r) -> ReaderT r m a -> ReaderT r' m a

-- | Fetch the value of the environment.
ask :: (Monad m) => ReaderT r m r

-- | Execute a computation in a modified environment (a specialization of
--   <a>withReaderT</a>).
--   
--   <ul>
--   <li><pre><a>runReaderT</a> (<a>local</a> f m) = <a>runReaderT</a> m .
--   f</pre></li>
--   </ul>
local :: (Monad m) => (r -> r) -> ReaderT r m a -> ReaderT r m a

-- | Retrieve a function of the current environment.
--   
--   <ul>
--   <li><pre><a>asks</a> f = <a>liftM</a> f <a>ask</a></pre></li>
--   </ul>
asks :: (Monad m) => (r -> a) -> ReaderT r m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m a b -> CallCC (ReaderT r m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m a -> Catch e (ReaderT r m) a
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Reader.ReaderT r)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Reader.ReaderT r m)


-- | A monad transformer that combines <tt>ReaderT</tt>, <tt>WriterT</tt>
--   and <tt>StateT</tt>. This version is lazy; for a strict version with
--   the same interface, see <a>Control.Monad.Trans.RWS.Strict</a>.
module Control.Monad.Trans.RWS.Lazy

-- | A monad containing an environment of type <tt>r</tt>, output of type
--   <tt>w</tt> and an updatable state of type <tt>s</tt>.
type RWS r w s = RWST r w s Identity

-- | Construct an RWS computation from a function. (The inverse of
--   <a>runRWS</a>.)
rws :: (r -> s -> (a, s, w)) -> RWS r w s a

-- | Unwrap an RWS computation as a function. (The inverse of <a>rws</a>.)
runRWS :: RWS r w s a -> r -> s -> (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWS :: RWS r w s a -> r -> s -> (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWS :: RWS r w s a -> r -> s -> (s, w)

-- | Map the return value, final state and output of a computation using
--   the given function.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>mapRWS</a> f m) r s = f (<a>runRWS</a> m r
--   s)</pre></li>
--   </ul>
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b

-- | <tt><a>withRWS</a> f m</tt> executes action <tt>m</tt> with an initial
--   environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>withRWS</a> f m) r s = <a>uncurry</a>
--   (<a>runRWS</a> m) (f r s)</pre></li>
--   </ul>
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
newtype RWST r w s m a
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
[runRWST] :: RWST r w s m a -> r -> s -> m (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWST :: (Monad m) => RWST r w s m a -> r -> s -> m (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWST :: (Monad m) => RWST r w s m a -> r -> s -> m (s, w)

-- | Map the inner computation using the given function.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>mapRWST</a> f m) r s = f (<a>runRWST</a> m
--   r s)</pre></li>
--   </ul>
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b

-- | <tt><a>withRWST</a> f m</tt> executes action <tt>m</tt> with an
--   initial environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>withRWST</a> f m) r s = <a>uncurry</a>
--   (<a>runRWST</a> m) (f r s)</pre></li>
--   </ul>
withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a

-- | Constructor for computations in the reader monad (equivalent to
--   <a>asks</a>).
reader :: (Monoid w, Monad m) => (r -> a) -> RWST r w s m a

-- | Fetch the value of the environment.
ask :: (Monoid w, Monad m) => RWST r w s m r

-- | Execute a computation in a modified environment
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>local</a> f m) r s = <a>runRWST</a> m (f
--   r) s</pre></li>
--   </ul>
local :: (Monoid w, Monad m) => (r -> r) -> RWST r w s m a -> RWST r w s m a

-- | Retrieve a function of the current environment.
--   
--   <ul>
--   <li><pre><a>asks</a> f = <a>liftM</a> f <a>ask</a></pre></li>
--   </ul>
asks :: (Monoid w, Monad m) => (r -> a) -> RWST r w s m a

-- | Construct a writer computation from a (result, output) pair.
writer :: (Monad m) => (a, w) -> RWST r w s m a

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: (Monoid w, Monad m) => w -> RWST r w s m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>listen</a> m) r s = <a>liftM</a> (\ (a, w)
--   -&gt; ((a, w), w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
listen :: (Monoid w, Monad m) => RWST r w s m a -> RWST r w s m (a, w)

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <a>liftM</a> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   <li><pre><a>runRWST</a> (<a>listens</a> f m) r s = <a>liftM</a> (\ (a,
--   w) -&gt; ((a, f w), w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
listens :: (Monoid w, Monad m) => (w -> b) -> RWST r w s m a -> RWST r w s m (a, b)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>pass</a> m) r s = <a>liftM</a> (\ ((a, f),
--   w) -&gt; (a, f w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
pass :: (Monoid w, Monad m) => RWST r w s m (a, w -> w) -> RWST r w s m a

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<a>liftM</a> (\ x -&gt;
--   (x,f)) m)</pre></li>
--   <li><pre><a>runRWST</a> (<a>censor</a> f m) r s = <a>liftM</a> (\ (a,
--   w) -&gt; (a, f w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
censor :: (Monoid w, Monad m) => (w -> w) -> RWST r w s m a -> RWST r w s m a

-- | Construct a state monad computation from a state transformer function.
state :: (Monoid w, Monad m) => (s -> (a, s)) -> RWST r w s m a

-- | Fetch the current value of the state within the monad.
get :: (Monoid w, Monad m) => RWST r w s m s

-- | <tt><a>put</a> s</tt> sets the state within the monad to <tt>s</tt>.
put :: (Monoid w, Monad m) => s -> RWST r w s m ()

-- | <tt><a>modify</a> f</tt> is an action that updates the state to the
--   result of applying <tt>f</tt> to the current state.
--   
--   <ul>
--   <li><pre><a>modify</a> f = <a>get</a> &gt;&gt;= (<a>put</a> .
--   f)</pre></li>
--   </ul>
modify :: (Monoid w, Monad m) => (s -> s) -> RWST r w s m ()

-- | Get a specific component of the state, using a projection function
--   supplied.
--   
--   <ul>
--   <li><pre><a>gets</a> f = <a>liftM</a> f <a>get</a></pre></li>
--   </ul>
gets :: (Monoid w, Monad m) => (s -> a) -> RWST r w s m a

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: (Monoid w) => CallCC m (a, s, w) (b, s, w) -> CallCC (RWST r w s m) a b

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation.
liftCallCC' :: (Monoid w) => CallCC m (a, s, w) (b, s, w) -> CallCC (RWST r w s m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, s, w) -> Catch e (RWST r w s m) a
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance GHC.Base.Monoid w => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance (GHC.Base.Monoid w, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.RWS.Lazy.RWST r w s m)


-- | A monad transformer that combines <tt>ReaderT</tt>, <tt>WriterT</tt>
--   and <tt>StateT</tt>. This version is lazy; for a strict version, see
--   <a>Control.Monad.Trans.RWS.Strict</a>, which has the same interface.
module Control.Monad.Trans.RWS


-- | A monad transformer that combines <tt>ReaderT</tt>, <tt>WriterT</tt>
--   and <tt>StateT</tt>. This version is strict; for a lazy version with
--   the same interface, see <a>Control.Monad.Trans.RWS.Lazy</a>.
module Control.Monad.Trans.RWS.Strict

-- | A monad containing an environment of type <tt>r</tt>, output of type
--   <tt>w</tt> and an updatable state of type <tt>s</tt>.
type RWS r w s = RWST r w s Identity

-- | Construct an RWS computation from a function. (The inverse of
--   <a>runRWS</a>.)
rws :: (r -> s -> (a, s, w)) -> RWS r w s a

-- | Unwrap an RWS computation as a function. (The inverse of <a>rws</a>.)
runRWS :: RWS r w s a -> r -> s -> (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWS :: RWS r w s a -> r -> s -> (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWS :: RWS r w s a -> r -> s -> (s, w)

-- | Map the return value, final state and output of a computation using
--   the given function.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>mapRWS</a> f m) r s = f (<a>runRWS</a> m r
--   s)</pre></li>
--   </ul>
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b

-- | <tt><a>withRWS</a> f m</tt> executes action <tt>m</tt> with an initial
--   environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>withRWS</a> f m) r s = <a>uncurry</a>
--   (<a>runRWS</a> m) (f r s)</pre></li>
--   </ul>
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
newtype RWST r w s m a
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
[runRWST] :: RWST r w s m a -> r -> s -> m (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWST :: (Monad m) => RWST r w s m a -> r -> s -> m (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWST :: (Monad m) => RWST r w s m a -> r -> s -> m (s, w)

-- | Map the inner computation using the given function.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>mapRWST</a> f m) r s = f (<a>runRWST</a> m
--   r s)</pre></li>
--   </ul>
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b

-- | <tt><a>withRWST</a> f m</tt> executes action <tt>m</tt> with an
--   initial environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>withRWST</a> f m) r s = <a>uncurry</a>
--   (<a>runRWST</a> m) (f r s)</pre></li>
--   </ul>
withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a

-- | Constructor for computations in the reader monad (equivalent to
--   <a>asks</a>).
reader :: (Monoid w, Monad m) => (r -> a) -> RWST r w s m a

-- | Fetch the value of the environment.
ask :: (Monoid w, Monad m) => RWST r w s m r

-- | Execute a computation in a modified environment
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>local</a> f m) r s = <a>runRWST</a> m (f
--   r) s</pre></li>
--   </ul>
local :: (Monoid w, Monad m) => (r -> r) -> RWST r w s m a -> RWST r w s m a

-- | Retrieve a function of the current environment.
--   
--   <ul>
--   <li><pre><a>asks</a> f = <a>liftM</a> f <a>ask</a></pre></li>
--   </ul>
asks :: (Monoid w, Monad m) => (r -> a) -> RWST r w s m a

-- | Construct a writer computation from a (result, output) pair.
writer :: (Monad m) => (a, w) -> RWST r w s m a

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: (Monoid w, Monad m) => w -> RWST r w s m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>listen</a> m) r s = <a>liftM</a> (\ (a, w)
--   -&gt; ((a, w), w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
listen :: (Monoid w, Monad m) => RWST r w s m a -> RWST r w s m (a, w)

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <a>liftM</a> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   <li><pre><a>runRWST</a> (<a>listens</a> f m) r s = <a>liftM</a> (\ (a,
--   w) -&gt; ((a, f w), w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
listens :: (Monoid w, Monad m) => (w -> b) -> RWST r w s m a -> RWST r w s m (a, b)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>pass</a> m) r s = <a>liftM</a> (\ ((a, f),
--   w) -&gt; (a, f w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
pass :: (Monoid w, Monad m) => RWST r w s m (a, w -> w) -> RWST r w s m a

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<a>liftM</a> (\ x -&gt;
--   (x,f)) m)</pre></li>
--   <li><pre><a>runRWST</a> (<a>censor</a> f m) r s = <a>liftM</a> (\ (a,
--   w) -&gt; (a, f w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
censor :: (Monoid w, Monad m) => (w -> w) -> RWST r w s m a -> RWST r w s m a

-- | Construct a state monad computation from a state transformer function.
state :: (Monoid w, Monad m) => (s -> (a, s)) -> RWST r w s m a

-- | Fetch the current value of the state within the monad.
get :: (Monoid w, Monad m) => RWST r w s m s

-- | <tt><a>put</a> s</tt> sets the state within the monad to <tt>s</tt>.
put :: (Monoid w, Monad m) => s -> RWST r w s m ()

-- | <tt><a>modify</a> f</tt> is an action that updates the state to the
--   result of applying <tt>f</tt> to the current state.
--   
--   <ul>
--   <li><pre><a>modify</a> f = <a>get</a> &gt;&gt;= (<a>put</a> .
--   f)</pre></li>
--   </ul>
modify :: (Monoid w, Monad m) => (s -> s) -> RWST r w s m ()

-- | Get a specific component of the state, using a projection function
--   supplied.
--   
--   <ul>
--   <li><pre><a>gets</a> f = <a>liftM</a> f <a>get</a></pre></li>
--   </ul>
gets :: (Monoid w, Monad m) => (s -> a) -> RWST r w s m a

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: (Monoid w) => CallCC m (a, s, w) (b, s, w) -> CallCC (RWST r w s m) a b

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation.
liftCallCC' :: (Monoid w) => CallCC m (a, s, w) (b, s, w) -> CallCC (RWST r w s m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, s, w) -> Catch e (RWST r w s m) a
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance GHC.Base.Monoid w => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance (GHC.Base.Monoid w, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.RWS.Strict.RWST r w s m)


-- | Lazy state monads, passing an updatable state through a computation.
--   See below for examples.
--   
--   Some computations may not require the full power of state
--   transformers:
--   
--   <ul>
--   <li>For a read-only state, see <a>Control.Monad.Trans.Reader</a>.</li>
--   <li>To accumulate a value without using it on the way, see
--   <a>Control.Monad.Trans.Writer</a>.</li>
--   </ul>
--   
--   In this version, sequencing of computations is lazy, so that for
--   example the following produces a usable result:
--   
--   <pre>
--   evalState (sequence $ repeat $ do { n &lt;- get; put (n*2); return n }) 1
--   </pre>
--   
--   For a strict version with the same interface, see
--   <a>Control.Monad.Trans.State.Strict</a>.
module Control.Monad.Trans.State.Lazy

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Construct a state monad computation from a function. (The inverse of
--   <a>runState</a>.)
state :: (Monad m) => (s -> (a, s)) -> StateT s m a

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: (s -> s) -> State s a -> State s a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s m a
StateT :: (s -> m (a, s)) -> StateT s m a
[runStateT] :: StateT s m a -> s -> m (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: (Monad m) => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: (Monad m) => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: (s -> s) -> StateT s m a -> StateT s m a

-- | Fetch the current value of the state within the monad.
get :: (Monad m) => StateT s m s

-- | <tt><a>put</a> s</tt> sets the state within the monad to <tt>s</tt>.
put :: (Monad m) => s -> StateT s m ()

-- | <tt><a>modify</a> f</tt> is an action that updates the state to the
--   result of applying <tt>f</tt> to the current state.
--   
--   <ul>
--   <li><pre><a>modify</a> f = <a>get</a> &gt;&gt;= (<a>put</a> .
--   f)</pre></li>
--   </ul>
modify :: (Monad m) => (s -> s) -> StateT s m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
--   
--   <ul>
--   <li><pre><a>modify'</a> f = <a>get</a> &gt;&gt;= ((<a>$!</a>)
--   <a>put</a> . f)</pre></li>
--   </ul>
modify' :: (Monad m) => (s -> s) -> StateT s m ()

-- | Get a specific component of the state, using a projection function
--   supplied.
--   
--   <ul>
--   <li><pre><a>gets</a> f = <a>liftM</a> f <a>get</a></pre></li>
--   </ul>
gets :: (Monad m) => (s -> a) -> StateT s m a

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: CallCC m (a, s) (b, s) -> CallCC (StateT s m) a b

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation. It does
--   not satisfy the laws of a monad transformer.
liftCallCC' :: CallCC m (a, s) (b, s) -> CallCC (StateT s m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, s) -> Catch e (StateT s m) a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: (Monad m) => Listen w m (a, s) -> Listen w (StateT s m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: (Monad m) => Pass w m (a, s) -> Pass w (StateT s m) a
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.State.Lazy.StateT s m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.State.Lazy.StateT s m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.State.Lazy.StateT s)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.State.Lazy.StateT s m)


-- | State monads, passing an updatable state through a computation.
--   
--   Some computations may not require the full power of state
--   transformers:
--   
--   <ul>
--   <li>For a read-only state, see <a>Control.Monad.Trans.Reader</a>.</li>
--   <li>To accumulate a value without using it on the way, see
--   <a>Control.Monad.Trans.Writer</a>.</li>
--   </ul>
--   
--   This version is lazy; for a strict version, see
--   <a>Control.Monad.Trans.State.Strict</a>, which has the same interface.
module Control.Monad.Trans.State


-- | Strict state monads, passing an updatable state through a computation.
--   See below for examples.
--   
--   Some computations may not require the full power of state
--   transformers:
--   
--   <ul>
--   <li>For a read-only state, see <a>Control.Monad.Trans.Reader</a>.</li>
--   <li>To accumulate a value without using it on the way, see
--   <a>Control.Monad.Trans.Writer</a>.</li>
--   </ul>
--   
--   In this version, sequencing of computations is strict (but
--   computations are not strict in the state unless you force it with
--   <a>seq</a> or the like). For a lazy version with the same interface,
--   see <a>Control.Monad.Trans.State.Lazy</a>.
module Control.Monad.Trans.State.Strict

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Construct a state monad computation from a function. (The inverse of
--   <a>runState</a>.)
state :: (Monad m) => (s -> (a, s)) -> StateT s m a

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: (s -> s) -> State s a -> State s a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s m a
StateT :: (s -> m (a, s)) -> StateT s m a
[runStateT] :: StateT s m a -> s -> m (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: (Monad m) => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: (Monad m) => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: (s -> s) -> StateT s m a -> StateT s m a

-- | Fetch the current value of the state within the monad.
get :: (Monad m) => StateT s m s

-- | <tt><a>put</a> s</tt> sets the state within the monad to <tt>s</tt>.
put :: (Monad m) => s -> StateT s m ()

-- | <tt><a>modify</a> f</tt> is an action that updates the state to the
--   result of applying <tt>f</tt> to the current state.
--   
--   <ul>
--   <li><pre><a>modify</a> f = <a>get</a> &gt;&gt;= (<a>put</a> .
--   f)</pre></li>
--   </ul>
modify :: (Monad m) => (s -> s) -> StateT s m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
--   
--   <ul>
--   <li><pre><a>modify'</a> f = <a>get</a> &gt;&gt;= ((<a>$!</a>)
--   <a>put</a> . f)</pre></li>
--   </ul>
modify' :: (Monad m) => (s -> s) -> StateT s m ()

-- | Get a specific component of the state, using a projection function
--   supplied.
--   
--   <ul>
--   <li><pre><a>gets</a> f = <a>liftM</a> f <a>get</a></pre></li>
--   </ul>
gets :: (Monad m) => (s -> a) -> StateT s m a

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: CallCC m (a, s) (b, s) -> CallCC (StateT s m) a b

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation. It does
--   not satisfy the laws of a monad transformer.
liftCallCC' :: CallCC m (a, s) (b, s) -> CallCC (StateT s m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, s) -> Catch e (StateT s m) a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: (Monad m) => Listen w m (a, s) -> Listen w (StateT s m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: (Monad m) => Pass w m (a, s) -> Pass w (StateT s m) a
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.State.Strict.StateT s m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.State.Strict.StateT s m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.State.Strict.StateT s)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.State.Strict.StateT s m)


-- | Prelude classes, lifted to unary type constructors.
module Data.Functor.Classes

-- | Lifting of the <a>Eq</a> class to unary type constructors.
class Eq1 f
eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool

-- | Lifting of the <a>Ord</a> class to unary type constructors.
class (Eq1 f) => Ord1 f
compare1 :: (Ord1 f, Ord a) => f a -> f a -> Ordering

-- | Lifting of the <a>Read</a> class to unary type constructors.
class Read1 f
readsPrec1 :: (Read1 f, Read a) => Int -> ReadS (f a)

-- | Lifting of the <a>Show</a> class to unary type constructors.
class Show1 f
showsPrec1 :: (Show1 f, Show a) => Int -> f a -> ShowS

-- | <tt><a>readsData</a> p d</tt> is a parser for datatypes where each
--   alternative begins with a data constructor. It parses the constructor
--   and passes it to <tt>p</tt>. Parsers for various constructors can be
--   constructed with <a>readsUnary</a>, <a>readsUnary1</a> and
--   <a>readsBinary1</a>, and combined with <tt>mappend</tt> from the
--   <tt>Monoid</tt> class.
readsData :: (String -> ReadS a) -> Int -> ReadS a

-- | <tt><a>readsUnary</a> n c n'</tt> matches the name of a unary data
--   constructor and then parses its argument using <a>readsPrec</a>.
readsUnary :: (Read a) => String -> (a -> t) -> String -> ReadS t

-- | <tt><a>readsUnary1</a> n c n'</tt> matches the name of a unary data
--   constructor and then parses its argument using <a>readsPrec1</a>.
readsUnary1 :: (Read1 f, Read a) => String -> (f a -> t) -> String -> ReadS t

-- | <tt><a>readsBinary1</a> n c n'</tt> matches the name of a binary data
--   constructor and then parses its arguments using <a>readsPrec1</a>.
readsBinary1 :: (Read1 f, Read1 g, Read a) => String -> (f a -> g a -> t) -> String -> ReadS t

-- | <tt><a>showsUnary</a> n d x</tt> produces the string representation of
--   a unary data constructor with name <tt>n</tt> and argument <tt>x</tt>,
--   in precedence context <tt>d</tt>.
showsUnary :: (Show a) => String -> Int -> a -> ShowS

-- | <tt><a>showsUnary1</a> n d x</tt> produces the string representation
--   of a unary data constructor with name <tt>n</tt> and argument
--   <tt>x</tt>, in precedence context <tt>d</tt>.
showsUnary1 :: (Show1 f, Show a) => String -> Int -> f a -> ShowS

-- | <tt><a>showsBinary1</a> n d x</tt> produces the string representation
--   of a binary data constructor with name <tt>n</tt> and arguments
--   <tt>x</tt> and <tt>y</tt>, in precedence context <tt>d</tt>.
showsBinary1 :: (Show1 f, Show1 g, Show a) => String -> Int -> f a -> g a -> ShowS
instance Data.Functor.Classes.Eq1 GHC.Base.Maybe
instance Data.Functor.Classes.Ord1 GHC.Base.Maybe
instance Data.Functor.Classes.Read1 GHC.Base.Maybe
instance Data.Functor.Classes.Show1 GHC.Base.Maybe
instance Data.Functor.Classes.Eq1 []
instance Data.Functor.Classes.Ord1 []
instance Data.Functor.Classes.Read1 []
instance Data.Functor.Classes.Show1 []
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 ((,) a)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 ((,) a)
instance GHC.Read.Read a => Data.Functor.Classes.Read1 ((,) a)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 ((,) a)
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Either.Either a)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Either.Either a)
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Either.Either a)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Either.Either a)
instance Data.Functor.Classes.Eq1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Ord1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Read1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Show1 Data.Functor.Identity.Identity


-- | The constant functor.
module Data.Functor.Constant

-- | Constant functor.
newtype Constant a b
Constant :: a -> Constant a b
[getConstant] :: Constant a b -> a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Constant.Constant a b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Constant.Constant a b)
instance GHC.Read.Read a => GHC.Read.Read (Data.Functor.Constant.Constant a b)
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Constant.Constant a b)
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Functor.Constant.Constant a)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Functor.Constant.Constant a)
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Functor.Constant.Constant a)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Functor.Constant.Constant a)
instance GHC.Base.Functor (Data.Functor.Constant.Constant a)
instance Data.Foldable.Foldable (Data.Functor.Constant.Constant a)
instance Data.Traversable.Traversable (Data.Functor.Constant.Constant a)
instance GHC.Base.Monoid a => GHC.Base.Applicative (Data.Functor.Constant.Constant a)


-- | Adding a new kind of pure computation to an applicative functor.
module Control.Applicative.Lift

-- | Applicative functor formed by adding pure computations to a given
--   applicative functor.
data Lift f a
Pure :: a -> Lift f a
Other :: (f a) -> Lift f a

-- | Projection to the other functor.
unLift :: (Applicative f) => Lift f a -> f a

-- | Apply a transformation to the other computation.
mapLift :: (f a -> g a) -> Lift f a -> Lift g a

-- | An applicative functor that collects a monoid (e.g. lists) of errors.
--   A sequence of computations fails if any of its components do, but
--   unlike monads made with <tt>ExceptT</tt> from
--   <a>Control.Monad.Trans.Except</a>, these computations continue after
--   an error, collecting all the errors.
--   
--   <ul>
--   <li><pre><a>pure</a> f <a>&lt;*&gt;</a> <a>pure</a> x = <a>pure</a> (f
--   x)</pre></li>
--   <li><pre><a>pure</a> f <a>&lt;*&gt;</a> <a>failure</a> e =
--   <a>failure</a> e</pre></li>
--   <li><pre><a>failure</a> e <a>&lt;*&gt;</a> <a>pure</a> x =
--   <a>failure</a> e</pre></li>
--   <li><pre><a>failure</a> e1 <a>&lt;*&gt;</a> <a>failure</a> e2 =
--   <a>failure</a> (e1 <tt>&lt;&gt;</tt> e2)</pre></li>
--   </ul>
type Errors e = Lift (Constant e)

-- | Extractor for computations with accumulating errors.
--   
--   <ul>
--   <li><pre><a>runErrors</a> (<a>pure</a> x) = <a>Right</a> x</pre></li>
--   <li><pre><a>runErrors</a> (<a>failure</a> e) = <a>Left</a>
--   e</pre></li>
--   </ul>
runErrors :: Errors e a -> Either e a

-- | Report an error.
failure :: (Monoid e) => e -> Errors e a
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Applicative.Lift.Lift f a)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Applicative.Lift.Lift f a)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => GHC.Read.Read (Control.Applicative.Lift.Lift f a)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Control.Applicative.Lift.Lift f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.Lift.Lift f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Lift.Lift f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.Lift.Lift f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.Lift.Lift f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.Lift.Lift f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Control.Applicative.Lift.Lift f)


-- | This monad transformer extends a monad with the ability throw
--   exceptions.
--   
--   A sequence of actions terminates normally, producing a value, only if
--   none of the actions in the sequence throws an exception. If one throws
--   an exception, the rest of the sequence is skipped and the composite
--   action exits with that exception.
--   
--   If the value of the exception is not required, the variant in
--   <a>Control.Monad.Trans.Maybe</a> may be used instead.
module Control.Monad.Trans.Except

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continies after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | Constructor for computations in the exception monad. (The inverse of
--   <a>runExcept</a>).
except :: Either e a -> Except e a

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype ExceptT e m a
ExceptT :: (m (Either e a)) -> ExceptT e m a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: (Functor m) => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Signal an exception value <tt>e</tt>.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>throwE</a> e) = <a>return</a>
--   (<a>Left</a> e)</pre></li>
--   <li><pre><a>throwE</a> e &gt;&gt;= m = <a>throwE</a> e</pre></li>
--   </ul>
throwE :: (Monad m) => e -> ExceptT e m a

-- | Handle an exception.
--   
--   <ul>
--   <li><pre><a>catchE</a> h (<a>lift</a> m) = <a>lift</a> m</pre></li>
--   <li><pre><a>catchE</a> h (<a>throwE</a> e) = h e</pre></li>
--   </ul>
catchE :: (Monad m) => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Either e a) (Either e b) -> CallCC (ExceptT e m) a b

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: (Monad m) => Listen w m (Either e a) -> Listen w (ExceptT e m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: (Monad m) => Pass w m (Either e a) -> Pass w (ExceptT e m) a
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Except.ExceptT e m a)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Except.ExceptT e m a)
instance (GHC.Read.Read e, Data.Functor.Classes.Read1 m, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Except.ExceptT e m a)
instance (GHC.Show.Show e, Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Except.ExceptT e m a)
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m) => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m) => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Read.Read e, Data.Functor.Classes.Read1 m) => Data.Functor.Classes.Read1 (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Show.Show e, Data.Functor.Classes.Show1 m) => Data.Functor.Classes.Show1 (Control.Monad.Trans.Except.ExceptT e m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Except.ExceptT e f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Except.ExceptT e f)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Base.Functor m, GHC.Base.Monad m, GHC.Base.Monoid e) => GHC.Base.Alternative (Control.Monad.Trans.Except.ExceptT e m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Base.Monad m, GHC.Base.Monoid e) => GHC.Base.MonadPlus (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Except.ExceptT e)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Except.ExceptT e m)


-- | This monad transformer adds the ability to fail or throw exceptions to
--   a monad.
--   
--   A sequence of actions succeeds, producing a value, only if all the
--   actions in the sequence are successful. If one fails with an error,
--   the rest of the sequence is skipped and the composite action fails
--   with that error.
--   
--   If the value of the error is not required, the variant in
--   <a>Control.Monad.Trans.Maybe</a> may be used instead.
--   
--   <i>Note:</i> This module will be removed in a future release. Instead,
--   use <a>Control.Monad.Trans.Except</a>, which does not restrict the
--   exception type, and also includes a base exception monad.

-- | <i>Deprecated: Use Control.Monad.Trans.Except instead</i>
module Control.Monad.Trans.Error

-- | An exception to be thrown.
--   
--   Minimal complete definition: <a>noMsg</a> or <a>strMsg</a>.
class Error a where noMsg = strMsg "" strMsg _ = noMsg

-- | Creates an exception without a message. The default implementation is
--   <tt><a>strMsg</a> ""</tt>.
noMsg :: Error a => a

-- | Creates an exception with a message. The default implementation of
--   <tt><a>strMsg</a> s</tt> is <a>noMsg</a>.
strMsg :: Error a => String -> a

-- | Workaround so that we can have a Haskell 98 instance <tt><a>Error</a>
--   <a>String</a></tt>.
class ErrorList a
listMsg :: ErrorList a => String -> [a]

-- | The error monad transformer. It can be used to add error handling to
--   other monads.
--   
--   The <tt>ErrorT</tt> Monad structure is parameterized over two things:
--   
--   <ul>
--   <li>e - The error type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a successful computation, while
--   <tt>&gt;&gt;=</tt> sequences two subcomputations, failing on the first
--   error.
newtype ErrorT e m a
ErrorT :: m (Either e a) -> ErrorT e m a
[runErrorT] :: ErrorT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runErrorT</a> (<a>mapErrorT</a> f m) = f (<a>runErrorT</a>
--   m)</pre></li>
--   </ul>
mapErrorT :: (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b

-- | Signal an error value <tt>e</tt>.
--   
--   <ul>
--   <li><pre><a>runErrorT</a> (<a>throwError</a> e) = <a>return</a>
--   (<a>Left</a> e)</pre></li>
--   <li><pre><a>throwError</a> e &gt;&gt;= m = <a>throwError</a>
--   e</pre></li>
--   </ul>
throwError :: (Monad m, Error e) => e -> ErrorT e m a

-- | Handle an error.
--   
--   <ul>
--   <li><pre><a>catchError</a> h (<a>lift</a> m) = <a>lift</a>
--   m</pre></li>
--   <li><pre><a>catchError</a> h (<a>throwError</a> e) = h e</pre></li>
--   </ul>
catchError :: (Monad m, Error e) => ErrorT e m a -> (e -> ErrorT e m a) -> ErrorT e m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Either e a) (Either e b) -> CallCC (ErrorT e m) a b

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: (Monad m) => Listen w m (Either e a) -> Listen w (ErrorT e m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: (Monad m) => Pass w m (Either e a) -> Pass w (ErrorT e m) a
instance GHC.Base.MonadPlus GHC.Types.IO
instance GHC.Base.Alternative GHC.Types.IO
instance Control.Monad.Trans.Error.Error GHC.IO.Exception.IOException
instance Control.Monad.Trans.Error.ErrorList a => Control.Monad.Trans.Error.Error [a]
instance Control.Monad.Trans.Error.ErrorList GHC.Types.Char
instance Control.Monad.Trans.Error.Error e => GHC.Base.Alternative (Data.Either.Either e)
instance Control.Monad.Trans.Error.Error e => GHC.Base.MonadPlus (Data.Either.Either e)
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Error.ErrorT e m a)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Error.ErrorT e m a)
instance (GHC.Read.Read e, Data.Functor.Classes.Read1 m, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Error.ErrorT e m a)
instance (GHC.Show.Show e, Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Error.ErrorT e m a)
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m) => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m) => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Read.Read e, Data.Functor.Classes.Read1 m) => Data.Functor.Classes.Read1 (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Show.Show e, Data.Functor.Classes.Show1 m) => Data.Functor.Classes.Show1 (Control.Monad.Trans.Error.ErrorT e m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Error.ErrorT e m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Error.ErrorT e f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Error.ErrorT e f)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Base.Functor m, GHC.Base.Monad m, Control.Monad.Trans.Error.Error e) => GHC.Base.Alternative (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Base.Monad m, Control.Monad.Trans.Error.Error e) => GHC.Base.Monad (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Base.Monad m, Control.Monad.Trans.Error.Error e) => GHC.Base.MonadPlus (Control.Monad.Trans.Error.ErrorT e m)
instance (Control.Monad.Fix.MonadFix m, Control.Monad.Trans.Error.Error e) => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Error.ErrorT e m)
instance Control.Monad.Trans.Error.Error e => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Error.ErrorT e)
instance (Control.Monad.Trans.Error.Error e, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Error.ErrorT e m)


-- | The identity monad transformer.
--   
--   This is useful for functions parameterized by a monad transformer.
module Control.Monad.Trans.Identity

-- | The trivial monad transformer, which maps a monad to an equivalent
--   monad.
newtype IdentityT f a
IdentityT :: f a -> IdentityT f a
[runIdentityT] :: IdentityT f a -> f a

-- | Lift a unary operation to the new monad.
mapIdentityT :: (m a -> n b) -> IdentityT m a -> IdentityT n b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m a -> Catch e (IdentityT m) a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m a b -> CallCC (IdentityT m) a b
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Identity.IdentityT f a)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Identity.IdentityT f a)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Identity.IdentityT f a)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Identity.IdentityT f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Monad.Trans.Identity.IdentityT f)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Identity.IdentityT f)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.Identity.IdentityT m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Control.Monad.Trans.Identity.IdentityT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Identity.IdentityT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.Identity.IdentityT


-- | The ListT monad transformer, adding backtracking to a given monad,
--   which must be commutative.
module Control.Monad.Trans.List

-- | Parameterizable list monad, with an inner monad.
--   
--   <i>Note:</i> this does not yield a monad unless the argument monad is
--   commutative.
newtype ListT m a
ListT :: m [a] -> ListT m a
[runListT] :: ListT m a -> m [a]

-- | Map between <a>ListT</a> computations.
--   
--   <ul>
--   <li><pre><a>runListT</a> (<a>mapListT</a> f m) = f (<a>runListT</a>
--   m)</pre></li>
--   </ul>
mapListT :: (m [a] -> n [b]) -> ListT m a -> ListT n b

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m [a] [b] -> CallCC (ListT m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m [a] -> Catch e (ListT m) a
instance (Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.List.ListT m a)
instance (Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.List.ListT m a)
instance (Data.Functor.Classes.Read1 m, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.List.ListT m a)
instance (Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.List.ListT m a)
instance Data.Functor.Classes.Eq1 m => Data.Functor.Classes.Eq1 (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Classes.Ord1 m => Data.Functor.Classes.Ord1 (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Classes.Read1 m => Data.Functor.Classes.Read1 (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Classes.Show1 m => Data.Functor.Classes.Show1 (Control.Monad.Trans.List.ListT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.List.ListT m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.List.ListT f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.List.ListT f)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.List.ListT m)
instance GHC.Base.Applicative m => GHC.Base.Alternative (Control.Monad.Trans.List.ListT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.List.ListT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Control.Monad.Trans.List.ListT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.List.ListT
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.List.ListT m)


-- | The <a>MaybeT</a> monad transformer extends a monad with the ability
--   to exit the computation without returning a value.
--   
--   A sequence of actions produces a value only if all the actions in the
--   sequence do. If one exits, the rest of the sequence is skipped and the
--   composite action exits.
--   
--   For a variant allowing a range of exception values, see
--   <a>Control.Monad.Trans.Except</a>.
module Control.Monad.Trans.Maybe

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT m a
MaybeT :: m (Maybe a) -> MaybeT m a
[runMaybeT] :: MaybeT m a -> m (Maybe a)

-- | Transform the computation inside a <tt>MaybeT</tt>.
--   
--   <ul>
--   <li><pre><a>runMaybeT</a> (<a>mapMaybeT</a> f m) = f (<a>runMaybeT</a>
--   m)</pre></li>
--   </ul>
mapMaybeT :: (m (Maybe a) -> n (Maybe b)) -> MaybeT m a -> MaybeT n b

-- | Convert a <a>MaybeT</a> computation to <a>ExceptT</a>, with a default
--   exception value.
maybeToExceptT :: (Functor m) => e -> MaybeT m a -> ExceptT e m a

-- | Convert a <a>ExceptT</a> computation to <a>MaybeT</a>, discarding the
--   value of any exception.
exceptToMaybeT :: (Functor m) => ExceptT e m a -> MaybeT m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Maybe a) (Maybe b) -> CallCC (MaybeT m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (Maybe a) -> Catch e (MaybeT m) a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: (Monad m) => Listen w m (Maybe a) -> Listen w (MaybeT m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: (Monad m) => Pass w m (Maybe a) -> Pass w (MaybeT m) a
instance (Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Maybe.MaybeT m a)
instance (Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Maybe.MaybeT m a)
instance (Data.Functor.Classes.Read1 m, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Maybe.MaybeT m a)
instance (Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Maybe.MaybeT m a)
instance Data.Functor.Classes.Eq1 m => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Ord1 m => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Read1 m => Data.Functor.Classes.Read1 (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Show1 m => Data.Functor.Classes.Show1 (Control.Monad.Trans.Maybe.MaybeT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Maybe.MaybeT f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Maybe.MaybeT f)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Alternative (Control.Monad.Trans.Maybe.MaybeT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Maybe.MaybeT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.Maybe.MaybeT
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Maybe.MaybeT m)


-- | The lazy <a>WriterT</a> monad transformer, which adds collection of
--   outputs (such as a count or string output) to a given monad.
--   
--   This monad transformer provides only limited access to the output
--   during the computation. For more general access, use
--   <a>Control.Monad.Trans.State</a> instead.
--   
--   This version builds its output lazily; for a strict version with the
--   same interface, see <a>Control.Monad.Trans.Writer.Strict</a>.
module Control.Monad.Trans.Writer.Lazy

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | Construct a writer computation from a (result, output) pair. (The
--   inverse of <a>runWriter</a>.)
writer :: (Monad m) => (a, w) -> WriterT w m a

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Writer w a -> (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriter</a> m = <a>snd</a> (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
execWriter :: Writer w a -> w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriter</a> (<a>mapWriter</a> f m) = f (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
newtype WriterT w m a
WriterT :: m (a, w) -> WriterT w m a
[runWriterT] :: WriterT w m a -> m (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriterT</a> m = <a>liftM</a> <a>snd</a>
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
execWriterT :: (Monad m) => WriterT w m a -> m w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>mapWriterT</a> f m) = f
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: (Monoid w, Monad m) => w -> WriterT w m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>listen</a> m) = <a>liftM</a> (\ (a, w)
--   -&gt; ((a, w), w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
listen :: (Monoid w, Monad m) => WriterT w m a -> WriterT w m (a, w)

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <a>liftM</a> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   <li><pre><a>runWriterT</a> (<a>listens</a> f m) = <a>liftM</a> (\ (a,
--   w) -&gt; ((a, f w), w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
listens :: (Monoid w, Monad m) => (w -> b) -> WriterT w m a -> WriterT w m (a, b)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>pass</a> m) = <a>liftM</a> (\ ((a, f),
--   w) -&gt; (a, f w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
pass :: (Monoid w, Monad m) => WriterT w m (a, w -> w) -> WriterT w m a

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<a>liftM</a> (\ x -&gt;
--   (x,f)) m)</pre></li>
--   <li><pre><a>runWriterT</a> (<a>censor</a> f m) = <a>liftM</a> (\ (a,
--   w) -&gt; (a, f w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
censor :: (Monoid w, Monad m) => (w -> w) -> WriterT w m a -> WriterT w m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: (Monoid w) => CallCC m (a, w) (b, w) -> CallCC (WriterT w m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, w) -> Catch e (WriterT w m) a
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m) => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m) => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m) => Data.Functor.Classes.Read1 (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m) => Data.Functor.Classes.Show1 (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Writer.Lazy.WriterT w f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Writer.Lazy.WriterT w f)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => GHC.Base.Applicative (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Alternative m) => GHC.Base.Alternative (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance GHC.Base.Monoid w => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance (GHC.Base.Monoid w, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Writer.Lazy.WriterT w m)


-- | The WriterT monad transformer. This version is lazy; for a strict
--   version, see <a>Control.Monad.Trans.Writer.Strict</a>, which has the
--   same interface.
module Control.Monad.Trans.Writer


-- | The strict <a>WriterT</a> monad transformer, which adds collection of
--   outputs (such as a count or string output) to a given monad.
--   
--   This monad transformer provides only limited access to the output
--   during the computation. For more general access, use
--   <a>Control.Monad.Trans.State</a> instead.
--   
--   This version builds its output strictly; for a lazy version with the
--   same interface, see <a>Control.Monad.Trans.Writer.Lazy</a>. Although
--   the output is built strictly, it is not possible to achieve constant
--   space behaviour with this transformer: for that, use
--   <a>Control.Monad.Trans.State.Strict</a> instead.
module Control.Monad.Trans.Writer.Strict

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | Construct a writer computation from a (result, output) pair. (The
--   inverse of <a>runWriter</a>.)
writer :: (Monad m) => (a, w) -> WriterT w m a

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Writer w a -> (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriter</a> m = <a>snd</a> (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
execWriter :: Writer w a -> w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriter</a> (<a>mapWriter</a> f m) = f (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
newtype WriterT w m a
WriterT :: m (a, w) -> WriterT w m a
[runWriterT] :: WriterT w m a -> m (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriterT</a> m = <a>liftM</a> <a>snd</a>
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
execWriterT :: (Monad m) => WriterT w m a -> m w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>mapWriterT</a> f m) = f
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: (Monoid w, Monad m) => w -> WriterT w m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>listen</a> m) = <a>liftM</a> (\ (a, w)
--   -&gt; ((a, w), w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
listen :: (Monoid w, Monad m) => WriterT w m a -> WriterT w m (a, w)

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <a>liftM</a> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   <li><pre><a>runWriterT</a> (<a>listens</a> f m) = <a>liftM</a> (\ (a,
--   w) -&gt; ((a, f w), w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
listens :: (Monoid w, Monad m) => (w -> b) -> WriterT w m a -> WriterT w m (a, b)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>pass</a> m) = <a>liftM</a> (\ ((a, f),
--   w) -&gt; (a, f w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
pass :: (Monoid w, Monad m) => WriterT w m (a, w -> w) -> WriterT w m a

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<a>liftM</a> (\ x -&gt;
--   (x,f)) m)</pre></li>
--   <li><pre><a>runWriterT</a> (<a>censor</a> f m) = <a>liftM</a> (\ (a,
--   w) -&gt; (a, f w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
censor :: (Monoid w, Monad m) => (w -> w) -> WriterT w m a -> WriterT w m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: (Monoid w) => CallCC m (a, w) (b, w) -> CallCC (WriterT w m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, w) -> Catch e (WriterT w m) a
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m) => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m) => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m) => Data.Functor.Classes.Read1 (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m) => Data.Functor.Classes.Show1 (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Writer.Strict.WriterT w f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Writer.Strict.WriterT w f)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => GHC.Base.Applicative (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Alternative m) => GHC.Base.Alternative (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance GHC.Base.Monoid w => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Writer.Strict.WriterT w)
instance (GHC.Base.Monoid w, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Writer.Strict.WriterT w m)


-- | Composition of functors.
module Data.Functor.Compose

-- | Right-to-left composition of functors. The composition of applicative
--   functors is always applicative, but the composition of monads is not
--   always a monad.
newtype Compose f g a
Compose :: f (g a) -> Compose f g a
[getCompose] :: Compose f g a -> f (g a)
instance (Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Compose.Apply g a)
instance (Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Compose.Apply g a)
instance (Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Compose.Apply g a)
instance (Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Compose.Apply g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Compose.Compose f g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Compose.Compose f g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Compose.Compose f g a)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Compose.Compose f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Alternative f, GHC.Base.Applicative g) => GHC.Base.Alternative (Data.Functor.Compose.Compose f g)


-- | Products, lifted to functors.
module Data.Functor.Product

-- | Lifted product of functors.
data Product f g a
Pair :: (f a) -> (g a) -> Product f g a
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Product.Product f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Product.Product f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Product.Product f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Product.Product f g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (Data.Functor.Product.Product f g)
instance (GHC.Base.Alternative f, GHC.Base.Alternative g) => GHC.Base.Alternative (Data.Functor.Product.Product f g)
instance (GHC.Base.Monad f, GHC.Base.Monad g) => GHC.Base.Monad (Data.Functor.Product.Product f g)
instance (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) => GHC.Base.MonadPlus (Data.Functor.Product.Product f g)
instance (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) => Control.Monad.Fix.MonadFix (Data.Functor.Product.Product f g)


-- | Sums, lifted to functors.
module Data.Functor.Sum

-- | Lifted sum of functors.
data Sum f g a
InL :: (f a) -> Sum f g a
InR :: (g a) -> Sum f g a
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Sum.Sum f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Sum.Sum f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Sum.Sum f g)


-- | Making functors with an <a>Applicative</a> instance that performs
--   actions in the reverse order.
module Control.Applicative.Backwards

-- | The same functor, but with an <a>Applicative</a> instance that
--   performs actions in the reverse order.
newtype Backwards f a
Backwards :: f a -> Backwards f a
[forwards] :: Backwards f a -> f a
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Applicative.Backwards.Backwards f a)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Applicative.Backwards.Backwards f a)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => GHC.Read.Read (Control.Applicative.Backwards.Backwards f a)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Control.Applicative.Backwards.Backwards f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.Backwards.Backwards f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Backwards.Backwards f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.Backwards.Backwards f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Control.Applicative.Backwards.Backwards f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.Backwards.Backwards f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.Backwards.Backwards f)


-- | Making functors whose elements are notionally in the reverse order
--   from the original functor.
module Data.Functor.Reverse

-- | The same functor, but with <a>Foldable</a> and <a>Traversable</a>
--   instances that process the elements in the reverse order.
newtype Reverse f a
Reverse :: f a -> Reverse f a
[getReverse] :: Reverse f a -> f a
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Reverse.Reverse f a)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Reverse.Reverse f a)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Reverse.Reverse f a)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Reverse.Reverse f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Data.Functor.Reverse.Reverse f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Reverse.Reverse f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Reverse.Reverse f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Functor.Reverse.Reverse f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Functor.Reverse.Reverse f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Functor.Reverse.Reverse f)

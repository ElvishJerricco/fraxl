<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Monad.Trans.State.Lazy</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Monad-Trans-State-Lazy.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Control-Monad-Trans-State-Lazy.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">transformers-0.4.2.0: Concrete functor and monad transformers</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Andy Gill 2001,
                (c) Oregon Graduate Institute of Science and Technology, 2001</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ross@soi.city.ac.uk</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Control.Monad.Trans.State.Lazy</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">The State monad</a></li><li><a href="#g:2">The StateT monad transformer</a></li><li><a href="#g:3">State operations</a></li><li><a href="#g:4">Lifting other operations</a></li><li><a href="#g:5">Examples</a><ul><li><a href="#g:6">State monads</a></li><li><a href="#g:7">Counting</a></li><li><a href="#g:8">Labelling trees</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Lazy state monads, passing an updatable state through a computation.
 See below for examples.</p><p>Some computations may not require the full power of state transformers:</p><ul><li>For a read-only state, see <a href="Control-Monad-Trans-Reader.html">Control.Monad.Trans.Reader</a>.</li><li>To accumulate a value without using it on the way, see
   <a href="Control-Monad-Trans-Writer.html">Control.Monad.Trans.Writer</a>.</li></ul><p>In this version, sequencing of computations is lazy, so that for
 example the following produces a usable result:</p><pre>evalState (sequence $ repeat $ do { n &lt;- get; put (n*2); return n }) 1</pre><p>For a strict version with the same interface, see
 <a href="Control-Monad-Trans-State-Strict.html">Control.Monad.Trans.State.Strict</a>.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:State">State</a> s = <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s <a href="../base-4.8.2.0/Data-Functor-Identity.html#t:Identity">Identity</a></li><li class="src short"><a href="#v:state">state</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (s -&gt; (a, s)) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a</li><li class="src short"><a href="#v:runState">runState</a> :: <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a -&gt; s -&gt; (a, s)</li><li class="src short"><a href="#v:evalState">evalState</a> :: <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a -&gt; s -&gt; a</li><li class="src short"><a href="#v:execState">execState</a> :: <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a -&gt; s -&gt; s</li><li class="src short"><a href="#v:mapState">mapState</a> :: ((a, s) -&gt; (b, s)) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s b</li><li class="src short"><a href="#v:withState">withState</a> :: (s -&gt; s) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:StateT">StateT</a> s m a = <a href="#v:StateT">StateT</a> {<ul class="subs"><li><a href="#v:runStateT">runStateT</a> :: s -&gt; m (a, s)</li></ul>}</li><li class="src short"><a href="#v:evalStateT">evalStateT</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; s -&gt; m a</li><li class="src short"><a href="#v:execStateT">execStateT</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; s -&gt; m s</li><li class="src short"><a href="#v:mapStateT">mapStateT</a> :: (m (a, s) -&gt; n (b, s)) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s n b</li><li class="src short"><a href="#v:withStateT">withStateT</a> :: (s -&gt; s) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a</li><li class="src short"><a href="#v:get">get</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m s</li><li class="src short"><a href="#v:put">put</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; s -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m ()</li><li class="src short"><a href="#v:modify">modify</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (s -&gt; s) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m ()</li><li class="src short"><a href="#v:modify-39-">modify'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (s -&gt; s) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m ()</li><li class="src short"><a href="#v:gets">gets</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (s -&gt; a) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a</li><li class="src short"><a href="#v:liftCallCC">liftCallCC</a> :: <a href="Control-Monad-Signatures.html#t:CallCC">CallCC</a> m (a, s) (b, s) -&gt; <a href="Control-Monad-Signatures.html#t:CallCC">CallCC</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a b</li><li class="src short"><a href="#v:liftCallCC-39-">liftCallCC'</a> :: <a href="Control-Monad-Signatures.html#t:CallCC">CallCC</a> m (a, s) (b, s) -&gt; <a href="Control-Monad-Signatures.html#t:CallCC">CallCC</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a b</li><li class="src short"><a href="#v:liftCatch">liftCatch</a> :: <a href="Control-Monad-Signatures.html#t:Catch">Catch</a> e m (a, s) -&gt; <a href="Control-Monad-Signatures.html#t:Catch">Catch</a> e (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a</li><li class="src short"><a href="#v:liftListen">liftListen</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Signatures.html#t:Listen">Listen</a> w m (a, s) -&gt; <a href="Control-Monad-Signatures.html#t:Listen">Listen</a> w (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a</li><li class="src short"><a href="#v:liftPass">liftPass</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Signatures.html#t:Pass">Pass</a> w m (a, s) -&gt; <a href="Control-Monad-Signatures.html#t:Pass">Pass</a> w (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a</li></ul></div><div id="interface"><h1 id="g:1">The State monad</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:State" class="def">State</a> s = <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s <a href="../base-4.8.2.0/Data-Functor-Identity.html#t:Identity">Identity</a> <a href="src/Control-Monad-Trans-State-Lazy.html#State" class="link">Source</a></p><div class="doc"><p>A state monad parameterized by the type <code>s</code> of the state to carry.</p><p>The <code><a href="../base-4.8.2.0/Control-Monad.html#v:return">return</a></code> function leaves the state unchanged, while <code>&gt;&gt;=</code> uses
 the final state of the first computation as the initial state of
 the second.</p></div></div><div class="top"><p class="src"><a name="v:state" class="def">state</a> <a href="src/Control-Monad-Trans-State-Lazy.html#state" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (s -&gt; (a, s))</td><td class="doc"><p>pure state transformer</p></td></tr><tr><td class="src">-&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a</td><td class="doc"><p>equivalent state-passing computation</p></td></tr></table></div><div class="doc"><p>Construct a state monad computation from a function.
 (The inverse of <code><a href="Control-Monad-Trans-State-Lazy.html#v:runState">runState</a></code>.)</p></div></div><div class="top"><p class="src"><a name="v:runState" class="def">runState</a> <a href="src/Control-Monad-Trans-State-Lazy.html#runState" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a</td><td class="doc"><p>state-passing computation to execute</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; (a, s)</td><td class="doc"><p>return value and final state</p></td></tr></table></div><div class="doc"><p>Unwrap a state monad computation as a function.
 (The inverse of <code><a href="Control-Monad-Trans-State-Lazy.html#v:state">state</a></code>.)</p></div></div><div class="top"><p class="src"><a name="v:evalState" class="def">evalState</a> <a href="src/Control-Monad-Trans-State-Lazy.html#evalState" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a</td><td class="doc"><p>state-passing computation to execute</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>return value of the state computation</p></td></tr></table></div><div class="doc"><p>Evaluate a state computation with the given initial state
 and return the final value, discarding the final state.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:evalState">evalState</a></code> m s = <code><a href="../base-4.8.2.0/Data-Tuple.html#v:fst">fst</a></code> (<code><a href="Control-Monad-Trans-State-Lazy.html#v:runState">runState</a></code> m s)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:execState" class="def">execState</a> <a href="src/Control-Monad-Trans-State-Lazy.html#execState" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a</td><td class="doc"><p>state-passing computation to execute</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>final state</p></td></tr></table></div><div class="doc"><p>Evaluate a state computation with the given initial state
 and return the final state, discarding the final value.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:execState">execState</a></code> m s = <code><a href="../base-4.8.2.0/Data-Tuple.html#v:snd">snd</a></code> (<code><a href="Control-Monad-Trans-State-Lazy.html#v:runState">runState</a></code> m s)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:mapState" class="def">mapState</a> :: ((a, s) -&gt; (b, s)) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s b <a href="src/Control-Monad-Trans-State-Lazy.html#mapState" class="link">Source</a></p><div class="doc"><p>Map both the return value and final state of a computation using
 the given function.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:runState">runState</a></code> (<code><a href="Control-Monad-Trans-State-Lazy.html#v:mapState">mapState</a></code> f m) = f . <code><a href="Control-Monad-Trans-State-Lazy.html#v:runState">runState</a></code> m</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:withState" class="def">withState</a> :: (s -&gt; s) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:State">State</a> s a <a href="src/Control-Monad-Trans-State-Lazy.html#withState" class="link">Source</a></p><div class="doc"><p><code><code><a href="Control-Monad-Trans-State-Lazy.html#v:withState">withState</a></code> f m</code> executes action <code>m</code> on a state modified by
 applying <code>f</code>.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:withState">withState</a></code> f m = <code><a href="Control-Monad-Trans-State-Lazy.html#v:modify">modify</a></code> f &gt;&gt; m</pre></li></ul></div></div><h1 id="g:2">The StateT monad transformer</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:StateT" class="def">StateT</a> s m a <a href="src/Control-Monad-Trans-State-Lazy.html#StateT" class="link">Source</a></p><div class="doc"><p>A state transformer monad parameterized by:</p><ul><li><code>s</code> - The state.</li><li><code>m</code> - The inner monad.</li></ul><p>The <code><a href="../base-4.8.2.0/Control-Monad.html#v:return">return</a></code> function leaves the state unchanged, while <code>&gt;&gt;=</code> uses
 the final state of the first computation as the initial state of
 the second.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:StateT" class="def">StateT</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:runStateT" class="def">runStateT</a> :: s -&gt; m (a, s)</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:StateT" class="caption collapser" onclick="toggleSection('i:StateT')">Instances</p><div id="section.i:StateT" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a> m =&gt; <a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Control-Monad-Fix.html#t:MonadFix">MonadFix</a> m =&gt; <a href="../base-4.8.2.0/Control-Monad-Fix.html#t:MonadFix">MonadFix</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a> m, <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m) =&gt; <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a> m, <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m) =&gt; <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m =&gt; <a href="Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:evalStateT" class="def">evalStateT</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; s -&gt; m a <a href="src/Control-Monad-Trans-State-Lazy.html#evalStateT" class="link">Source</a></p><div class="doc"><p>Evaluate a state computation with the given initial state
 and return the final value, discarding the final state.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:evalStateT">evalStateT</a></code> m s = <code><a href="../base-4.8.2.0/Control-Monad.html#v:liftM">liftM</a></code> <code><a href="../base-4.8.2.0/Data-Tuple.html#v:fst">fst</a></code> (<code><a href="Control-Monad-Trans-State-Lazy.html#v:runStateT">runStateT</a></code> m s)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:execStateT" class="def">execStateT</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; s -&gt; m s <a href="src/Control-Monad-Trans-State-Lazy.html#execStateT" class="link">Source</a></p><div class="doc"><p>Evaluate a state computation with the given initial state
 and return the final state, discarding the final value.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:execStateT">execStateT</a></code> m s = <code><a href="../base-4.8.2.0/Control-Monad.html#v:liftM">liftM</a></code> <code><a href="../base-4.8.2.0/Data-Tuple.html#v:snd">snd</a></code> (<code><a href="Control-Monad-Trans-State-Lazy.html#v:runStateT">runStateT</a></code> m s)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:mapStateT" class="def">mapStateT</a> :: (m (a, s) -&gt; n (b, s)) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s n b <a href="src/Control-Monad-Trans-State-Lazy.html#mapStateT" class="link">Source</a></p><div class="doc"><p>Map both the return value and final state of a computation using
 the given function.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:runStateT">runStateT</a></code> (<code><a href="Control-Monad-Trans-State-Lazy.html#v:mapStateT">mapStateT</a></code> f m) = f . <code><a href="Control-Monad-Trans-State-Lazy.html#v:runStateT">runStateT</a></code> m</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:withStateT" class="def">withStateT</a> :: (s -&gt; s) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a <a href="src/Control-Monad-Trans-State-Lazy.html#withStateT" class="link">Source</a></p><div class="doc"><p><code><code><a href="Control-Monad-Trans-State-Lazy.html#v:withStateT">withStateT</a></code> f m</code> executes action <code>m</code> on a state modified by
 applying <code>f</code>.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:withStateT">withStateT</a></code> f m = <code><a href="Control-Monad-Trans-State-Lazy.html#v:modify">modify</a></code> f &gt;&gt; m</pre></li></ul></div></div><h1 id="g:3">State operations</h1><div class="top"><p class="src"><a name="v:get" class="def">get</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m s <a href="src/Control-Monad-Trans-State-Lazy.html#get" class="link">Source</a></p><div class="doc"><p>Fetch the current value of the state within the monad.</p></div></div><div class="top"><p class="src"><a name="v:put" class="def">put</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; s -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m () <a href="src/Control-Monad-Trans-State-Lazy.html#put" class="link">Source</a></p><div class="doc"><p><code><code><a href="Control-Monad-Trans-State-Lazy.html#v:put">put</a></code> s</code> sets the state within the monad to <code>s</code>.</p></div></div><div class="top"><p class="src"><a name="v:modify" class="def">modify</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (s -&gt; s) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m () <a href="src/Control-Monad-Trans-State-Lazy.html#modify" class="link">Source</a></p><div class="doc"><p><code><code><a href="Control-Monad-Trans-State-Lazy.html#v:modify">modify</a></code> f</code> is an action that updates the state to the result of
 applying <code>f</code> to the current state.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:modify">modify</a></code> f = <code><a href="Control-Monad-Trans-State-Lazy.html#v:get">get</a></code> &gt;&gt;= (<code><a href="Control-Monad-Trans-State-Lazy.html#v:put">put</a></code> . f)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:modify-39-" class="def">modify'</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (s -&gt; s) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m () <a href="src/Control-Monad-Trans-State-Lazy.html#modify%27" class="link">Source</a></p><div class="doc"><p>A variant of <code><a href="Control-Monad-Trans-State-Lazy.html#v:modify">modify</a></code> in which the computation is strict in the
 new state.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:modify-39-">modify'</a></code> f = <code><a href="Control-Monad-Trans-State-Lazy.html#v:get">get</a></code> &gt;&gt;= ((<code><a href="../base-4.8.2.0/Prelude.html#v:-36--33-">$!</a></code>) <code><a href="Control-Monad-Trans-State-Lazy.html#v:put">put</a></code> . f)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:gets" class="def">gets</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (s -&gt; a) -&gt; <a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m a <a href="src/Control-Monad-Trans-State-Lazy.html#gets" class="link">Source</a></p><div class="doc"><p>Get a specific component of the state, using a projection function
 supplied.</p><ul><li><pre><code><a href="Control-Monad-Trans-State-Lazy.html#v:gets">gets</a></code> f = <code><a href="../base-4.8.2.0/Control-Monad.html#v:liftM">liftM</a></code> f <code><a href="Control-Monad-Trans-State-Lazy.html#v:get">get</a></code></pre></li></ul></div></div><h1 id="g:4">Lifting other operations</h1><div class="top"><p class="src"><a name="v:liftCallCC" class="def">liftCallCC</a> :: <a href="Control-Monad-Signatures.html#t:CallCC">CallCC</a> m (a, s) (b, s) -&gt; <a href="Control-Monad-Signatures.html#t:CallCC">CallCC</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a b <a href="src/Control-Monad-Trans-State-Lazy.html#liftCallCC" class="link">Source</a></p><div class="doc"><p>Uniform lifting of a <code>callCC</code> operation to the new monad.
 This version rolls back to the original state on entering the
 continuation.</p></div></div><div class="top"><p class="src"><a name="v:liftCallCC-39-" class="def">liftCallCC'</a> :: <a href="Control-Monad-Signatures.html#t:CallCC">CallCC</a> m (a, s) (b, s) -&gt; <a href="Control-Monad-Signatures.html#t:CallCC">CallCC</a> (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a b <a href="src/Control-Monad-Trans-State-Lazy.html#liftCallCC%27" class="link">Source</a></p><div class="doc"><p>In-situ lifting of a <code>callCC</code> operation to the new monad.
 This version uses the current state on entering the continuation.
 It does not satisfy the laws of a monad transformer.</p></div></div><div class="top"><p class="src"><a name="v:liftCatch" class="def">liftCatch</a> :: <a href="Control-Monad-Signatures.html#t:Catch">Catch</a> e m (a, s) -&gt; <a href="Control-Monad-Signatures.html#t:Catch">Catch</a> e (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a <a href="src/Control-Monad-Trans-State-Lazy.html#liftCatch" class="link">Source</a></p><div class="doc"><p>Lift a <code>catchE</code> operation to the new monad.</p></div></div><div class="top"><p class="src"><a name="v:liftListen" class="def">liftListen</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Signatures.html#t:Listen">Listen</a> w m (a, s) -&gt; <a href="Control-Monad-Signatures.html#t:Listen">Listen</a> w (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a <a href="src/Control-Monad-Trans-State-Lazy.html#liftListen" class="link">Source</a></p><div class="doc"><p>Lift a <code>listen</code> operation to the new monad.</p></div></div><div class="top"><p class="src"><a name="v:liftPass" class="def">liftPass</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Signatures.html#t:Pass">Pass</a> w m (a, s) -&gt; <a href="Control-Monad-Signatures.html#t:Pass">Pass</a> w (<a href="Control-Monad-Trans-State-Lazy.html#t:StateT">StateT</a> s m) a <a href="src/Control-Monad-Trans-State-Lazy.html#liftPass" class="link">Source</a></p><div class="doc"><p>Lift a <code>pass</code> operation to the new monad.</p></div></div><h1 id="g:5">Examples</h1><h2 id="g:6">State monads</h2><div class="doc"><p>Parser from ParseLib with Hugs:</p><pre>type Parser a = StateT String [] a
   ==&gt; StateT (String -&gt; [(a,String)])</pre><p>For example, item can be written as:</p><pre>item = do (x:xs) &lt;- get
       put xs
       return x

type BoringState s a = StateT s Identity a
     ==&gt; StateT (s -&gt; Identity (a,s))

type StateWithIO s a = StateT s IO a
     ==&gt; StateT (s -&gt; IO (a,s))

type StateWithErr s a = StateT s Maybe a
     ==&gt; StateT (s -&gt; Maybe (a,s))</pre></div><h2 id="g:7">Counting</h2><div class="doc"><p>A function to increment a counter.
Taken from the paper &quot;Generalising Monads to Arrows&quot;,
John Hughes (<a href="http://www.cse.chalmers.se/~rjmh/">http://www.cse.chalmers.se/~rjmh/</a>), November 1998:</p><pre>tick :: State Int Int
tick = do n &lt;- get
          put (n+1)
          return n</pre><p>Add one to the given number using the state monad:</p><pre>plusOne :: Int -&gt; Int
plusOne n = execState tick n</pre><p>A contrived addition example. Works only with positive numbers:</p><pre>plus :: Int -&gt; Int -&gt; Int
plus n x = execState (sequence $ replicate n tick) x</pre></div><h2 id="g:8">Labelling trees</h2><div class="doc"><p>An example from <em>The Craft of Functional Programming</em>, Simon
Thompson (<a href="http://www.cs.kent.ac.uk/people/staff/sjt/">http://www.cs.kent.ac.uk/people/staff/sjt/</a>),
Addison-Wesley 1999: &quot;Given an arbitrary tree, transform it to a
tree of integers in which the original elements are replaced by
natural numbers, starting from 0.  The same element has to be
replaced by the same number at every occurrence, and when we meet
an as-yet-unvisited element we have to find a 'new' number to match
it with:&quot;</p><pre>data Tree a = Nil | Node a (Tree a) (Tree a) deriving (Show, Eq)
type Table a = [a]</pre><pre>numberTree :: Eq a =&gt; Tree a -&gt; State (Table a) (Tree Int)
numberTree Nil = return Nil
numberTree (Node x t1 t2) = do
    num &lt;- numberNode x
    nt1 &lt;- numberTree t1
    nt2 &lt;- numberTree t2
    return (Node num nt1 nt2)
  where
    numberNode :: Eq a =&gt; a -&gt; State (Table a) Int
    numberNode x = do
        table &lt;- get
        case elemIndex x table of
            Nothing -&gt; do
                put (table ++ [x])
                return (length table)
            Just i -&gt; return i</pre><p>numTree applies numberTree with an initial state:</p><pre>numTree :: (Eq a) =&gt; Tree a -&gt; Tree Int
numTree t = evalState (numberTree t) []</pre><pre>testTree = Node &quot;Zero&quot; (Node &quot;One&quot; (Node &quot;Two&quot; Nil Nil) (Node &quot;One&quot; (Node &quot;Zero&quot; Nil Nil) Nil)) Nil
numTree testTree =&gt; Node 0 (Node 1 (Node 2 Nil Nil) (Node 1 (Node 0 Nil Nil) Nil)) Nil</pre></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>
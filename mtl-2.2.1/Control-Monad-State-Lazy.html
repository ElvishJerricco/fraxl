<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Monad.State.Lazy</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Monad-State-Lazy.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">mtl-2.2.1: Monad classes, using functional dependencies</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Andy Gill 2001,
                (c) Oregon Graduate Institute of Science and Technology, 2001</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>libraries@haskell.org</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable (multi-param classes, functional dependencies)</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Control.Monad.State.Lazy</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">MonadState class</a></li><li><a href="#g:2">The State monad</a></li><li><a href="#g:3">The StateT monad transformer</a></li><li><a href="#g:4">Examples</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Lazy state monads.</p><p>This module is inspired by the paper
      <em>Functional Programming with Overloading and Higher-Order Polymorphism</em>,
        Mark P Jones (<a href="http://web.cecs.pdx.edu/~mpj/">http://web.cecs.pdx.edu/~mpj/</a>)
          Advanced School of Functional Programming, 1995.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="#t:MonadState">MonadState</a> s m | m -&gt; s <span class="keyword">where</span><ul class="subs"><li><a href="#v:get">get</a> :: m s</li><li><a href="#v:put">put</a> :: s -&gt; m ()</li><li><a href="#v:state">state</a> :: (s -&gt; (a, s)) -&gt; m a</li></ul></li><li class="src short"><a href="#v:modify">modify</a> :: <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; (s -&gt; s) -&gt; m ()</li><li class="src short"><a href="#v:modify-39-">modify'</a> :: <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; (s -&gt; s) -&gt; m ()</li><li class="src short"><a href="#v:gets">gets</a> :: <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; (s -&gt; a) -&gt; m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:State">State</a> s = <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s <a href="../base-4.8.2.0/Data-Functor-Identity.html#t:Identity">Identity</a></li><li class="src short"><a href="#v:runState">runState</a> :: <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a -&gt; s -&gt; (a, s)</li><li class="src short"><a href="#v:evalState">evalState</a> :: <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a -&gt; s -&gt; a</li><li class="src short"><a href="#v:execState">execState</a> :: <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a -&gt; s -&gt; s</li><li class="src short"><a href="#v:mapState">mapState</a> :: ((a, s) -&gt; (b, s)) -&gt; <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a -&gt; <a href="Control-Monad-State-Lazy.html#t:State">State</a> s b</li><li class="src short"><a href="#v:withState">withState</a> :: (s -&gt; s) -&gt; <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a -&gt; <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:StateT">StateT</a> s m a :: * -&gt; (* -&gt; *) -&gt; * -&gt; * = <a href="#v:StateT">StateT</a> {<ul class="subs"><li><a href="#v:runStateT">runStateT</a> :: s -&gt; m (a, s)</li></ul>}</li><li class="src short"><a href="#v:runStateT">runStateT</a> :: <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; s -&gt; m (a, s)</li><li class="src short"><a href="#v:evalStateT">evalStateT</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; s -&gt; m a</li><li class="src short"><a href="#v:execStateT">execStateT</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; s -&gt; m s</li><li class="src short"><a href="#v:mapStateT">mapStateT</a> :: (m (a, s) -&gt; n (b, s)) -&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s n b</li><li class="src short"><a href="#v:withStateT">withStateT</a> :: (s -&gt; s) -&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a</li><li class="src short">module <a href="../base-4.8.2.0/Control-Monad.html">Control.Monad</a></li><li class="src short">module <a href="../base-4.8.2.0/Control-Monad-Fix.html">Control.Monad.Fix</a></li><li class="src short">module <a href="Control-Monad-Trans.html">Control.Monad.Trans</a></li></ul></div><div id="interface"><h1 id="g:1">MonadState class</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a name="t:MonadState" class="def">MonadState</a> s m | m -&gt; s <span class="keyword">where</span></p><div class="doc"><p>Minimal definition is either both of <code>get</code> and <code>put</code> or just <code>state</code></p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Control-Monad-State-Lazy.html#v:state">state</a> | <a href="Control-Monad-State-Lazy.html#v:get">get</a>, <a href="Control-Monad-State-Lazy.html#v:put">put</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:get" class="def">get</a> :: m s</p><div class="doc"><p>Return the state from the internals of the monad.</p></div><p class="src"><a name="v:put" class="def">put</a> :: s -&gt; m ()</p><div class="doc"><p>Replace the state inside the monad.</p></div><p class="src"><a name="v:state" class="def">state</a> :: (s -&gt; (a, s)) -&gt; m a</p><div class="doc"><p>Embed a simple state action into the monad.</p></div></div><div class="subs instances"><p id="control.i:MonadState" class="caption collapser" onclick="toggleSection('i:MonadState')">Instances</p><div id="section.i:MonadState" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="../transformers-0.4.2.0/Control-Monad-Trans-Maybe.html#t:MaybeT">MaybeT</a> m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-List.html#t:ListT">ListT</a> m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="../transformers-0.4.2.0/Control-Monad-Trans-Identity.html#t:IdentityT">IdentityT</a> m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/Data-Monoid.html#t:Monoid">Monoid</a> w, <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m) =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-Writer-Strict.html#t:WriterT">WriterT</a> w m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/Data-Monoid.html#t:Monoid">Monoid</a> w, <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m) =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a> w m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-Reader.html#t:ReaderT">ReaderT</a> r m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-Except.html#t:ExceptT">ExceptT</a> e m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="Control-Monad-Error-Class.html#t:Error">Error</a> e, <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m) =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-Error.html#t:ErrorT">ErrorT</a> e m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-Cont.html#t:ContT">ContT</a> r m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-State-Strict.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../base-4.8.2.0/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-RWS-Strict.html#t:RWST">RWST</a> r w s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../base-4.8.2.0/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-RWS-Lazy.html#t:RWST">RWST</a> r w s m)</span></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:modify" class="def">modify</a> :: <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; (s -&gt; s) -&gt; m ()</p><div class="doc"><p>Monadic state transformer.</p><p>Maps an old state to a new state inside a state monad.
      The old state is thrown away.</p><pre>     Main&gt; :t modify ((+1) :: Int -&gt; Int)
     modify (...) :: (MonadState Int a) =&gt; a ()</pre><p>This says that <code>modify (+1)</code> acts over any
    Monad that is a member of the <code>MonadState</code> class,
    with an <code>Int</code> state.</p></div></div><div class="top"><p class="src"><a name="v:modify-39-" class="def">modify'</a> :: <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; (s -&gt; s) -&gt; m ()</p><div class="doc"><p>A variant of <code><a href="Control-Monad-State-Lazy.html#v:modify">modify</a></code> in which the computation is strict in the
 new state.</p></div></div><div class="top"><p class="src"><a name="v:gets" class="def">gets</a> :: <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s m =&gt; (s -&gt; a) -&gt; m a</p><div class="doc"><p>Gets specific component of the state, using a projection function
 supplied.</p></div></div><h1 id="g:2">The State monad</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:State" class="def">State</a> s = <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s <a href="../base-4.8.2.0/Data-Functor-Identity.html#t:Identity">Identity</a></p><div class="doc"><p>A state monad parameterized by the type <code>s</code> of the state to carry.</p><p>The <code><a href="../base-4.8.2.0/Control-Monad.html#v:return">return</a></code> function leaves the state unchanged, while <code>&gt;&gt;=</code> uses
 the final state of the first computation as the initial state of
 the second.</p></div></div><div class="top"><p class="src"><a name="v:runState" class="def">runState</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a</td><td class="doc"><p>state-passing computation to execute</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; (a, s)</td><td class="doc"><p>return value and final state</p></td></tr></table></div><div class="doc"><p>Unwrap a state monad computation as a function.
 (The inverse of <code><a href="../transformers-0.4.2.0/Control-Monad-Trans-State-Lazy.html#v:state">state</a></code>.)</p></div></div><div class="top"><p class="src"><a name="v:evalState" class="def">evalState</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a</td><td class="doc"><p>state-passing computation to execute</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>return value of the state computation</p></td></tr></table></div><div class="doc"><p>Evaluate a state computation with the given initial state
 and return the final value, discarding the final state.</p><ul><li><pre><code><a href="Control-Monad-State-Lazy.html#v:evalState">evalState</a></code> m s = <code><a href="../base-4.8.2.0/Data-Tuple.html#v:fst">fst</a></code> (<code><a href="Control-Monad-State-Lazy.html#v:runState">runState</a></code> m s)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:execState" class="def">execState</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a</td><td class="doc"><p>state-passing computation to execute</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>final state</p></td></tr></table></div><div class="doc"><p>Evaluate a state computation with the given initial state
 and return the final state, discarding the final value.</p><ul><li><pre><code><a href="Control-Monad-State-Lazy.html#v:execState">execState</a></code> m s = <code><a href="../base-4.8.2.0/Data-Tuple.html#v:snd">snd</a></code> (<code><a href="Control-Monad-State-Lazy.html#v:runState">runState</a></code> m s)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:mapState" class="def">mapState</a> :: ((a, s) -&gt; (b, s)) -&gt; <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a -&gt; <a href="Control-Monad-State-Lazy.html#t:State">State</a> s b</p><div class="doc"><p>Map both the return value and final state of a computation using
 the given function.</p><ul><li><pre><code><a href="Control-Monad-State-Lazy.html#v:runState">runState</a></code> (<code><a href="Control-Monad-State-Lazy.html#v:mapState">mapState</a></code> f m) = f . <code><a href="Control-Monad-State-Lazy.html#v:runState">runState</a></code> m</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:withState" class="def">withState</a> :: (s -&gt; s) -&gt; <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a -&gt; <a href="Control-Monad-State-Lazy.html#t:State">State</a> s a</p><div class="doc"><p><code><code><a href="Control-Monad-State-Lazy.html#v:withState">withState</a></code> f m</code> executes action <code>m</code> on a state modified by
 applying <code>f</code>.</p><ul><li><pre><code><a href="Control-Monad-State-Lazy.html#v:withState">withState</a></code> f m = <code><a href="../transformers-0.4.2.0/Control-Monad-Trans-State-Lazy.html#v:modify">modify</a></code> f &gt;&gt; m</pre></li></ul></div></div><h1 id="g:3">The StateT monad transformer</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:StateT" class="def">StateT</a> s m a :: * -&gt; (* -&gt; *) -&gt; * -&gt; *</p><div class="doc"><p>A state transformer monad parameterized by:</p><ul><li><code>s</code> - The state.</li><li><code>m</code> - The inner monad.</li></ul><p>The <code><a href="../base-4.8.2.0/Control-Monad.html#v:return">return</a></code> function leaves the state unchanged, while <code>&gt;&gt;=</code> uses
 the final state of the first computation as the initial state of
 the second.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:StateT" class="def">StateT</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:runStateT" class="def">runStateT</a> :: s -&gt; m (a, s)</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:StateT" class="caption collapser" onclick="toggleSection('i:StateT')">Instances</p><div id="section.i:StateT" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Writer-Class.html#t:MonadWriter">MonadWriter</a> w m =&gt; <a href="Control-Monad-Writer-Class.html#t:MonadWriter">MonadWriter</a> w (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-State-Lazy.html#t:MonadState">MonadState</a> s (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Reader-Class.html#t:MonadReader">MonadReader</a> r m =&gt; <a href="Control-Monad-Reader-Class.html#t:MonadReader">MonadReader</a> r (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Error-Class.html#t:MonadError">MonadError</a> e m =&gt; <a href="Control-Monad-Error-Class.html#t:MonadError">MonadError</a> e (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../transformers-0.4.2.0/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a> m =&gt; <a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a> (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Control-Monad-Fix.html#t:MonadFix">MonadFix</a> m =&gt; <a href="../base-4.8.2.0/Control-Monad-Fix.html#t:MonadFix">MonadFix</a> (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a> m, <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m) =&gt; <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/Data-Functor.html#t:Functor">Functor</a> m, <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m) =&gt; <a href="../base-4.8.2.0/Control-Applicative.html#t:Alternative">Alternative</a> (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> m =&gt; <a href="../base-4.8.2.0/Control-Monad.html#t:MonadPlus">MonadPlus</a> (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m =&gt; <a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Cont-Class.html#t:MonadCont">MonadCont</a> m =&gt; <a href="Control-Monad-Cont-Class.html#t:MonadCont">MonadCont</a> (<a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:runStateT" class="def">runStateT</a> :: <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; s -&gt; m (a, s)</p></div><div class="top"><p class="src"><a name="v:evalStateT" class="def">evalStateT</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; s -&gt; m a</p><div class="doc"><p>Evaluate a state computation with the given initial state
 and return the final value, discarding the final state.</p><ul><li><pre><code><a href="Control-Monad-State-Lazy.html#v:evalStateT">evalStateT</a></code> m s = <code><a href="../base-4.8.2.0/Control-Monad.html#v:liftM">liftM</a></code> <code><a href="../base-4.8.2.0/Data-Tuple.html#v:fst">fst</a></code> (<code><a href="Control-Monad-State-Lazy.html#v:runStateT">runStateT</a></code> m s)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:execStateT" class="def">execStateT</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; s -&gt; m s</p><div class="doc"><p>Evaluate a state computation with the given initial state
 and return the final state, discarding the final value.</p><ul><li><pre><code><a href="Control-Monad-State-Lazy.html#v:execStateT">execStateT</a></code> m s = <code><a href="../base-4.8.2.0/Control-Monad.html#v:liftM">liftM</a></code> <code><a href="../base-4.8.2.0/Data-Tuple.html#v:snd">snd</a></code> (<code><a href="Control-Monad-State-Lazy.html#v:runStateT">runStateT</a></code> m s)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:mapStateT" class="def">mapStateT</a> :: (m (a, s) -&gt; n (b, s)) -&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s n b</p><div class="doc"><p>Map both the return value and final state of a computation using
 the given function.</p><ul><li><pre><code><a href="Control-Monad-State-Lazy.html#v:runStateT">runStateT</a></code> (<code><a href="Control-Monad-State-Lazy.html#v:mapStateT">mapStateT</a></code> f m) = f . <code><a href="Control-Monad-State-Lazy.html#v:runStateT">runStateT</a></code> m</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:withStateT" class="def">withStateT</a> :: (s -&gt; s) -&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a -&gt; <a href="Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m a</p><div class="doc"><p><code><code><a href="Control-Monad-State-Lazy.html#v:withStateT">withStateT</a></code> f m</code> executes action <code>m</code> on a state modified by
 applying <code>f</code>.</p><ul><li><pre><code><a href="Control-Monad-State-Lazy.html#v:withStateT">withStateT</a></code> f m = <code><a href="../transformers-0.4.2.0/Control-Monad-Trans-State-Lazy.html#v:modify">modify</a></code> f &gt;&gt; m</pre></li></ul></div></div><div class="top"><p class="src">module <a href="../base-4.8.2.0/Control-Monad.html">Control.Monad</a></p></div><div class="top"><p class="src">module <a href="../base-4.8.2.0/Control-Monad-Fix.html">Control.Monad.Fix</a></p></div><div class="top"><p class="src">module <a href="Control-Monad-Trans.html">Control.Monad.Trans</a></p></div><h1 id="g:4">Examples</h1><div class="doc"><p>A function to increment a counter.  Taken from the paper
 <em>Generalising Monads to Arrows</em>, John
 Hughes (<a href="http://www.math.chalmers.se/~rjmh/">http://www.math.chalmers.se/~rjmh/</a>), November 1998:</p><pre>tick :: State Int Int
tick = do n &lt;- get
          put (n+1)
          return n</pre><p>Add one to the given number using the state monad:</p><pre>plusOne :: Int -&gt; Int
plusOne n = execState tick n</pre><p>A contrived addition example. Works only with positive numbers:</p><pre>plus :: Int -&gt; Int -&gt; Int
plus n x = execState (sequence $ replicate n tick) x</pre><p>An example from <em>The Craft of Functional Programming</em>, Simon
 Thompson (<a href="http://www.cs.kent.ac.uk/people/staff/sjt/">http://www.cs.kent.ac.uk/people/staff/sjt/</a>),
 Addison-Wesley 1999: &quot;Given an arbitrary tree, transform it to a
 tree of integers in which the original elements are replaced by
 natural numbers, starting from 0.  The same element has to be
 replaced by the same number at every occurrence, and when we meet
 an as-yet-unvisited element we have to find a 'new' number to match
 it with:&quot;</p><pre>data Tree a = Nil | Node a (Tree a) (Tree a) deriving (Show, Eq)
type Table a = [a]</pre><pre>numberTree :: Eq a =&gt; Tree a -&gt; State (Table a) (Tree Int)
numberTree Nil = return Nil
numberTree (Node x t1 t2)
       =  do num &lt;- numberNode x
             nt1 &lt;- numberTree t1
             nt2 &lt;- numberTree t2
             return (Node num nt1 nt2)
    where
    numberNode :: Eq a =&gt; a -&gt; State (Table a) Int
    numberNode x
       = do table &lt;- get
            (newTable, newPos) &lt;- return (nNode x table)
            put newTable
            return newPos
    nNode::  (Eq a) =&gt; a -&gt; Table a -&gt; (Table a, Int)
    nNode x table
       = case (findIndexInList (== x) table) of
         Nothing -&gt; (table ++ [x], length table)
         Just i  -&gt; (table, i)
    findIndexInList :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe Int
    findIndexInList = findIndexInListHelp 0
    findIndexInListHelp _ _ [] = Nothing
    findIndexInListHelp count f (h:t)
       = if (f h)
         then Just count
         else findIndexInListHelp (count+1) f t</pre><p>numTree applies numberTree with an initial state:</p><pre>numTree :: (Eq a) =&gt; Tree a -&gt; Tree Int
numTree t = evalState (numberTree t) []</pre><pre>testTree = Node &quot;Zero&quot; (Node &quot;One&quot; (Node &quot;Two&quot; Nil Nil) (Node &quot;One&quot; (Node &quot;Zero&quot; Nil Nil) Nil)) Nil
numTree testTree =&gt; Node 0 (Node 1 (Node 2 Nil Nil) (Node 1 (Node 0 Nil Nil) Nil)) Nil</pre><p>sumTree is a little helper function that does not use the State monad:</p><pre>sumTree :: (Num a) =&gt; Tree a -&gt; a
sumTree Nil = 0
sumTree (Node e t1 t2) = e + (sumTree t1) + (sumTree t2)</pre></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pretty-printing library
--   
--   This package contains a pretty-printing library, a set of API's that
--   provides a way to easily print out text in a consistent format of your
--   choosing. This is useful for compilers and related tools.
--   
--   This library was originally designed by John Hughes's and has since
--   been heavily modified by Simon Peyton Jones.
@package pretty
@version 1.1.2.0


-- | John Hughes's and Simon Peyton Jones's Pretty Printer Combinators
--   
--   Based on <i>The Design of a Pretty-printing Library</i> in Advanced
--   Functional Programming, Johan Jeuring and Erik Meijer (eds), LNCS 925
--   <a>http://www.cs.chalmers.se/~rjmh/Papers/pretty.ps</a>
module Text.PrettyPrint.HughesPJ

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> Doc

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
doubleQuotes :: Doc -> Doc

-- | Apply <a>parens</a> to <a>Doc</a> if boolean is true.
maybeParens :: Bool -> Doc -> Doc

-- | Apply <a>brackets</a> to <a>Doc</a> if boolean is true.
maybeBrackets :: Bool -> Doc -> Doc

-- | Apply <a>braces</a> to <a>Doc</a> if boolean is true.
maybeBraces :: Bool -> Doc -> Doc

-- | Apply <a>quotes</a> to <a>Doc</a> if boolean is true.
maybeQuotes :: Bool -> Doc -> Doc

-- | Apply <a>doubleQuotes</a> to <a>Doc</a> if boolean is true.
maybeDoubleQuotes :: Bool -> Doc -> Doc

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc] -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc -> Doc -> Doc

-- | List version of <a>$$</a>.
vcat :: [Doc] -> Doc

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc] -> Doc

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc] -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | <tt>first</tt> returns its first argument if it is non-empty,
--   otherwise its second.
first :: Doc -> Doc -> Doc

-- | Perform some simplification of a built up <tt>GDoc</tt>.
reduceDoc :: Doc -> RDoc

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>.
render :: Doc -> String

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
[mode] :: Style -> Mode

-- | Length of line, in chars
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc -> String

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Mode

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a
instance GHC.Generics.Selector Text.PrettyPrint.HughesPJ.S1_0_2Style
instance GHC.Generics.Selector Text.PrettyPrint.HughesPJ.S1_0_1Style
instance GHC.Generics.Selector Text.PrettyPrint.HughesPJ.S1_0_0Style
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_0Style
instance GHC.Generics.Datatype Text.PrettyPrint.HughesPJ.D1Style
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_3Mode
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_2Mode
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_1Mode
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_0Mode
instance GHC.Generics.Datatype Text.PrettyPrint.HughesPJ.D1Mode
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_7Doc
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_6Doc
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_5Doc
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_4Doc
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_3Doc
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_2Doc
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_1Doc
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_0Doc
instance GHC.Generics.Datatype Text.PrettyPrint.HughesPJ.D1Doc
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_2TextDetails
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_1TextDetails
instance GHC.Generics.Constructor Text.PrettyPrint.HughesPJ.C1_0TextDetails
instance GHC.Generics.Datatype Text.PrettyPrint.HughesPJ.D1TextDetails
instance GHC.Generics.Generic Text.PrettyPrint.HughesPJ.Style
instance GHC.Classes.Eq Text.PrettyPrint.HughesPJ.Style
instance GHC.Show.Show Text.PrettyPrint.HughesPJ.Style
instance GHC.Generics.Generic Text.PrettyPrint.HughesPJ.Mode
instance GHC.Classes.Eq Text.PrettyPrint.HughesPJ.Mode
instance GHC.Show.Show Text.PrettyPrint.HughesPJ.Mode
instance GHC.Generics.Generic Text.PrettyPrint.HughesPJ.Doc
instance GHC.Generics.Generic Text.PrettyPrint.HughesPJ.TextDetails
instance GHC.Classes.Eq Text.PrettyPrint.HughesPJ.TextDetails
instance GHC.Show.Show Text.PrettyPrint.HughesPJ.TextDetails
instance GHC.Base.Monoid Text.PrettyPrint.HughesPJ.Doc
instance Data.String.IsString Text.PrettyPrint.HughesPJ.Doc
instance GHC.Show.Show Text.PrettyPrint.HughesPJ.Doc
instance GHC.Classes.Eq Text.PrettyPrint.HughesPJ.Doc
instance Control.DeepSeq.NFData Text.PrettyPrint.HughesPJ.Doc
instance Control.DeepSeq.NFData Text.PrettyPrint.HughesPJ.TextDetails


-- | Pretty printing class, simlar to <a>Show</a> but nicer looking.
--   
--   Note that the precedence level is a <a>Rational</a> so there is an
--   unlimited number of levels. This module re-exports <a>HughesPJ</a>.
module Text.PrettyPrint.HughesPJClass

-- | Pretty printing class. The precedence level is used in a similar way
--   as in the <a>Show</a> class. Minimal complete definition is either
--   <a>pPrintPrec</a> or <a>pPrint</a>.
class Pretty a where pPrintPrec _ _ = pPrint pPrint = pPrintPrec prettyNormal 0 pPrintList l = brackets . fsep . punctuate comma . map (pPrintPrec l 0)
pPrintPrec :: Pretty a => PrettyLevel -> Rational -> a -> Doc
pPrint :: Pretty a => a -> Doc
pPrintList :: Pretty a => PrettyLevel -> [a] -> Doc

-- | Level of detail in the pretty printed output. Level 0 is the least
--   detail.
newtype PrettyLevel
PrettyLevel :: Int -> PrettyLevel

-- | The "normal" (Level 0) of detail.
prettyNormal :: PrettyLevel

-- | Pretty print a value with the <a>prettyNormal</a> level.
prettyShow :: (Pretty a) => a -> String

-- | Parenthesize an value if the boolean is true.

-- | <i>Deprecated: Please use <a>maybeParens</a> instead</i>
prettyParen :: Bool -> Doc -> Doc
instance GHC.Show.Show Text.PrettyPrint.HughesPJClass.PrettyLevel
instance GHC.Classes.Ord Text.PrettyPrint.HughesPJClass.PrettyLevel
instance GHC.Classes.Eq Text.PrettyPrint.HughesPJClass.PrettyLevel
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Int
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Integer.Type.Integer
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Float
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Double
instance Text.PrettyPrint.HughesPJClass.Pretty ()
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Bool
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Ordering
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Char
instance Text.PrettyPrint.HughesPJClass.Pretty a => Text.PrettyPrint.HughesPJClass.Pretty (GHC.Base.Maybe a)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b) => Text.PrettyPrint.HughesPJClass.Pretty (Data.Either.Either a b)
instance Text.PrettyPrint.HughesPJClass.Pretty a => Text.PrettyPrint.HughesPJClass.Pretty [a]
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b) => Text.PrettyPrint.HughesPJClass.Pretty (a, b)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d, Text.PrettyPrint.HughesPJClass.Pretty e) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d, e)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d, Text.PrettyPrint.HughesPJClass.Pretty e, Text.PrettyPrint.HughesPJClass.Pretty f) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d, e, f)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d, Text.PrettyPrint.HughesPJClass.Pretty e, Text.PrettyPrint.HughesPJClass.Pretty f, Text.PrettyPrint.HughesPJClass.Pretty g) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d, e, f, g)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d, Text.PrettyPrint.HughesPJClass.Pretty e, Text.PrettyPrint.HughesPJClass.Pretty f, Text.PrettyPrint.HughesPJClass.Pretty g, Text.PrettyPrint.HughesPJClass.Pretty h) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d, e, f, g, h)


-- | Provides a collection of pretty printer combinators, a set of API's
--   that provides a way to easily print out text in a consistent format of
--   your choosing.
--   
--   This module should be used as opposed to the
--   <a>Text.PrettyPrint.HughesPJ</a> module. Both are equivalent though as
--   this module simply re-exports the other.
module Text.PrettyPrint

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> Doc

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
doubleQuotes :: Doc -> Doc

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc] -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc -> Doc -> Doc

-- | List version of <a>$$</a>.
vcat :: [Doc] -> Doc

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc] -> Doc

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc] -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>.
render :: Doc -> String

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
[mode] :: Style -> Mode

-- | Length of line, in chars
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc -> String

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Mode

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails

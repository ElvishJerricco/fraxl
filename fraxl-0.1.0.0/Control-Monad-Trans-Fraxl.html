<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Monad.Trans.Fraxl</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Monad-Trans-Fraxl.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">fraxl-0.1.0.0: Cached and parallel data fetching.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Monad.Trans.Fraxl</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">The Fraxl Monad</a></li><li><a href="#g:2">The Sequence of Effects</a></li><li><a href="#g:3">Caching</a></li></ul></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:FreerT">FreerT</a> f = <a href="Control-Monad-Trans-Fraxl-Free.html#t:FreeT">FreeT</a> (<a href="../free-4.12.4/Control-Applicative-Free-Fast.html#t:Ap">Ap</a> f)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Fraxl">Fraxl</a> r = <a href="Control-Monad-Trans-Fraxl.html#t:FreerT">FreerT</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> r)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Fetch">Fetch</a> f m a = <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; m (<a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> m a)</li><li class="src short"><a href="#v:runFraxl">runFraxl</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a') -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; m a</li><li class="src short"><a href="#v:simpleAsyncFetch">simpleAsyncFetch</a> :: <a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m =&gt; (<span class="keyword">forall</span> x. f x -&gt; <a href="../base-4.8.2.0/System-IO.html#t:IO">IO</a> x) -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a</li><li class="src short"><a href="#v:fNil">fNil</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> m =&gt; <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> `[]`) m a</li><li class="src short"><a href="#v:-124-:-124-">(|:|)</a> :: <span class="keyword">forall</span> f r a m. <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a') -&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> r) m a') -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> (f : r)) m a</li><li class="src short"><span class="keyword">data</span> <a href="#t:ASeq">ASeq</a> f a :: (* -&gt; *) -&gt; * -&gt; * <span class="keyword">where</span><ul class="subs"><li><a href="#v:ANil">ANil</a> ::  <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f ()</li><li><a href="#v:ACons">ACons</a> ::  f a1 -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f (a1, u)</li></ul></li><li class="src short"><a href="#v:reduceASeq">reduceASeq</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; f u</li><li class="src short"><a href="#v:hoistASeq">hoistASeq</a> :: (<span class="keyword">forall</span> x. f x -&gt; g x) -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> g a</li><li class="src short"><a href="#v:traverseASeq">traverseASeq</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> h =&gt; (<span class="keyword">forall</span> x. f x -&gt; h (g x)) -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; h (<a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> g a)</li><li class="src short"><a href="#v:rebaseASeq">rebaseASeq</a> :: <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; (<span class="keyword">forall</span> x. (x -&gt; y) -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f x -&gt; z) -&gt; (v -&gt; u -&gt; y) -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f v -&gt; z</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:CachedFetch">CachedFetch</a> f a = <a href="#v:CachedFetch">CachedFetch</a> (f a)</li><li class="src short"><a href="#v:fetchCached">fetchCached</a> :: <span class="keyword">forall</span> t m f a. (<a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../transformers-0.4.2.0/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> t, <a href="../mtl-2.2.1/Control-Monad-State-Class.html#t:MonadState">MonadState</a> (<a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a>) (t m), <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> f, <a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> (t m)) =&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a') -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> (<a href="Control-Monad-Trans-Fraxl.html#t:CachedFetch">CachedFetch</a> f) (t m) a</li><li class="src short"><a href="#v:runCachedFraxl">runCachedFraxl</a> :: <span class="keyword">forall</span> m f a. (<a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> f) =&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a') -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a> -&gt; m (a, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a>)</li><li class="src short"><a href="#v:evalCachedFraxl">evalCachedFraxl</a> :: <span class="keyword">forall</span> m f a. (<a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> f) =&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a') -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; m a</li><li class="src short">module <a href="../dependent-sum-0.3.2.1/Data-GADT-Compare.html">Data.GADT.Compare</a></li></ul></div><div id="interface"><h1 id="g:1">The Fraxl Monad</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:FreerT" class="def">FreerT</a> f = <a href="Control-Monad-Trans-Fraxl-Free.html#t:FreeT">FreeT</a> (<a href="../free-4.12.4/Control-Applicative-Free-Fast.html#t:Ap">Ap</a> f)</p><div class="doc"><p>Fraxl is based on a particular Freer monad.
 This Freer monad has applicative optimization,
 which is used to parallelize effects.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Fraxl" class="def">Fraxl</a> r = <a href="Control-Monad-Trans-Fraxl.html#t:FreerT">FreerT</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> r)</p><div class="doc"><p>Fraxl is just the <code><a href="Control-Monad-Trans-Fraxl.html#t:FreerT">FreerT</a></code> monad transformer, applied with <code><a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a></code>.
 This is because <code><a href="Control-Monad-Trans-Fraxl.html#t:Fraxl">Fraxl</a></code> is just a free monad over a variety of data sources.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Fetch" class="def">Fetch</a> f m a = <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; m (<a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> m a)</p><div class="doc"><p>A data source is an effect <code>f</code> that operates in some monad <code>m</code>.
 Given a sequence of effects,
 a data source should use <code>m</code> to prepare a corresponding sequence of results.</p></div></div><div class="top"><p class="src"><a name="v:runFraxl" class="def">runFraxl</a> :: <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a') -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; m a</p><div class="doc"><p>Runs a Fraxl computation, using a given <code><a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a></code> function for <code>f</code>.
 This takes <code><a href="Control-Monad-Trans-Fraxl.html#t:FreerT">FreerT</a></code> as a parameter rather than <code><a href="Control-Monad-Trans-Fraxl.html#t:Fraxl">Fraxl</a></code>,
 because <code><a href="Control-Monad-Trans-Fraxl.html#t:Fraxl">Fraxl</a></code> is meant for a union of effects,
 but it should be possible to run a singleton effect.</p></div></div><div class="top"><p class="src"><a name="v:simpleAsyncFetch" class="def">simpleAsyncFetch</a> :: <a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m =&gt; (<span class="keyword">forall</span> x. f x -&gt; <a href="../base-4.8.2.0/System-IO.html#t:IO">IO</a> x) -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a</p><div class="doc"><p>A simple method of turning an <code><a href="../base-4.8.2.0/System-IO.html#t:IO">IO</a></code> bound computation
 into a <code>DataSource</code> <code><a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:fNil" class="def">fNil</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> m =&gt; <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> `[]`) m a</p><div class="doc"><p>Fetch empty union.
 Only necessary to terminate a list of <code><a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a></code> functions for <code>Fetch (Union r)</code></p></div></div><div class="top"><p class="src"><a name="v:-124-:-124-" class="def">(|:|)</a> :: <span class="keyword">forall</span> f r a m. <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a') -&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> r) m a') -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> (f : r)) m a <span class="fixity">infixr 5</span><span class="rightedge"></span></p><div class="doc"><p>Like '(:)' for constructing <code>Fetch (Union (f ': r))</code></p></div></div><h1 id="g:2">The Sequence of Effects</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ASeq" class="def">ASeq</a> f a :: (* -&gt; *) -&gt; * -&gt; * <span class="keyword">where</span></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ANil" class="def">ANil</a> ::  <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:ACons" class="def">ACons</a> ::  f a1 -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f (a1, u)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:reduceASeq" class="def">reduceASeq</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; f u</p><div class="doc"><p>reduceASeq a sequence of applicative effects into an applicative.</p></div></div><div class="top"><p class="src"><a name="v:hoistASeq" class="def">hoistASeq</a> :: (<span class="keyword">forall</span> x. f x -&gt; g x) -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> g a</p><div class="doc"><p>Transform a sequence of <code>f</code> into a sequence of <code>g</code>.</p></div></div><div class="top"><p class="src"><a name="v:traverseASeq" class="def">traverseASeq</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> h =&gt; (<span class="keyword">forall</span> x. f x -&gt; h (g x)) -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; h (<a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> g a)</p><div class="doc"><p>Traverse a sequence with resepect to its interpretation type <code>f</code>.</p></div></div><div class="top"><p class="src"><a name="v:rebaseASeq" class="def">rebaseASeq</a> :: <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; (<span class="keyword">forall</span> x. (x -&gt; y) -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f x -&gt; z) -&gt; (v -&gt; u -&gt; y) -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:ASeq">ASeq</a> f v -&gt; z</p><div class="doc"><p>It may not look like it, but this appends two sequences.
 See <a href="https://www.eyrie.org/~zednenem/2013/05/27/freeapp">Dave Menendez's work</a> for more explanation.</p></div></div><h1 id="g:3">Caching</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:CachedFetch" class="def">CachedFetch</a> f a</p><div class="doc"><p>Caching in Fraxl works by translating <code>FreerT f</code> into
 <code>FreerT (CachedFetch f)</code>, then running with <code>CachedFetch'</code>s DataSource.
 That instance requires <code>f</code> to to have a <code><a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a></code> instance.</p><p>The <code><a href="Control-Monad-Trans-Fraxl.html#t:CachedFetch">CachedFetch</a></code> instance uses a <code><a href="../mtl-2.2.1/Control-Monad-State-Class.html#t:MonadState">MonadState</a></code> to track cached requests.
 The state variable is a <code><a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a></code> from the 'dependent-map' package.
 Keys are requests, and values are <code><a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a></code>s of the results.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:CachedFetch" class="def">CachedFetch</a> (f a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:fetchCached" class="def">fetchCached</a> :: <span class="keyword">forall</span> t m f a. (<a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m, <a href="../transformers-0.4.2.0/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> t, <a href="../mtl-2.2.1/Control-Monad-State-Class.html#t:MonadState">MonadState</a> (<a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a>) (t m), <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> f, <a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> (t m)) =&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a') -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> (<a href="Control-Monad-Trans-Fraxl.html#t:CachedFetch">CachedFetch</a> f) (t m) a</p></div><div class="top"><p class="src"><a name="v:runCachedFraxl" class="def">runCachedFraxl</a> :: <span class="keyword">forall</span> m f a. (<a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> f) =&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a') -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a> -&gt; m (a, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a>)</p><div class="doc"><p>Runs a Fraxl computation with caching using a given starting cache.
 Alongside the result, it returns the final cache.</p></div></div><div class="top"><p class="src"><a name="v:evalCachedFraxl" class="def">evalCachedFraxl</a> :: <span class="keyword">forall</span> m f a. (<a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> f) =&gt; (<span class="keyword">forall</span> a'. <a href="Control-Monad-Trans-Fraxl.html#t:Fetch">Fetch</a> f m a') -&gt; <a href="Control-Monad-Trans-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; m a</p><div class="doc"><p>Like <code><a href="Control-Monad-Trans-Fraxl.html#v:runCachedFraxl">runCachedFraxl</a></code>, except it starts with an empty cache
 and discards the final cache.</p></div></div><div class="top"><p class="src">module <a href="../dependent-sum-0.3.2.1/Data-GADT-Compare.html">Data.GADT.Compare</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>
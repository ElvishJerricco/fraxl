-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cached and parallel data fetching.
--   
--   See Haxl for something similar.
@package fraxl
@version 0.1.0.0

module Control.Monad.Trans.Fraxl

-- | Fraxl is based on a particular Freer monad. This Freer monad has
--   applicative optimization, which is used to parallelize effects.
type FreerT f = FreeT (Ap f)

-- | Fraxl is just the <a>FreerT</a> monad transformer, applied with
--   <a>Union</a>. This is because <a>Fraxl</a> is just a free monad over a
--   variety of data sources.
type Fraxl r = FreerT (Union r)

-- | Data sources produce <a>Fetch</a> functions. They take a sequence of
--   effeects as an argument, and return a corresponding sequence of
--   monadic actions which are used to wait on the results.
type Fetch f m a = ASeq f a -> m (ASeq m a)

-- | A data source is an effect <tt>f</tt> that operates in some monad
--   <tt>m</tt>. Given a sequence of effects, a data source should use
--   <tt>m</tt> to prepare a corresponding sequence of results.
class Monad m => DataSource f m
fetch :: DataSource f m => Fetch f m q

-- | Runs a Fraxl computation. This takes <a>FreerT</a> as a parameter
--   rather than <a>Fraxl</a>, because <a>Fraxl</a> is meant for a union of
--   effects, but it should be possible to run a singleton effect.
runFraxl :: DataSource f m => FreerT f m a -> m a

-- | A simple method of turning an <a>IO</a> bound computation into a
--   <a>DataSource</a> <a>Fetch</a>.
simpleAsyncFetch :: MonadIO m => (forall x. f x -> IO x) -> Fetch f m a
data ASeq (f :: * -> *) a :: (* -> *) -> * -> *
ANil :: ASeq f ()
ACons :: f a1 -> ASeq f u -> ASeq f (a1, u)

-- | reduceASeq a sequence of applicative effects into an applicative.
reduceASeq :: Applicative f => ASeq f u -> f u

-- | Transform a sequence of <tt>f</tt> into a sequence of <tt>g</tt>.
hoistASeq :: (forall x. f x -> g x) -> ASeq f a -> ASeq g a

-- | Traverse a sequence with resepect to its interpretation type
--   <tt>f</tt>.
traverseASeq :: Applicative h => (forall x. f x -> h (g x)) -> ASeq f a -> h (ASeq g a)

-- | It may not look like it, but this appends two sequences. See <a>Dave
--   Menendez's work</a> for more explanation.
rebaseASeq :: ASeq f u -> (forall x. (x -> y) -> ASeq f x -> z) -> (v -> u -> y) -> ASeq f v -> z

-- | Caching in Fraxl works by translating <tt>FreerT f</tt> into
--   <tt>FreerT (CachedFetch f)</tt>, then running with
--   <tt>CachedFetch'</tt>s DataSource. That instance requires <tt>f</tt>
--   to to have a <a>GCompare</a> instance.
--   
--   The <a>CachedFetch</a> instance uses a <a>MonadState</a> to track
--   cached requests. The state variable is a <a>DMap</a> from the
--   'dependent-map' package. Keys are requests, and values are
--   <a>MVar</a>s of the results.
newtype CachedFetch f a
CachedFetch :: (f a) -> CachedFetch f a

-- | Runs a Fraxl computation with caching using a given starting cache.
--   Alongside the result, it returns the final cache.
runCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> DMap f MVar -> m (a, DMap f MVar)

-- | Like <a>runCachedFraxl</a>, except it starts with an empty cache and
--   discards the final cache.
evalCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> m a
instance GHC.Base.Monad m => Control.Monad.Trans.Fraxl.DataSource (Data.Dependent.OpenUnion.Union '[]) m
instance (Control.Monad.Trans.Fraxl.DataSource f m, Control.Monad.Trans.Fraxl.DataSource (Data.Dependent.OpenUnion.Union r) m) => Control.Monad.Trans.Fraxl.DataSource (Data.Dependent.OpenUnion.Union (f : r)) m
instance (Control.Monad.Trans.Fraxl.DataSource f m, Control.Monad.Trans.Class.MonadTrans t, Control.Monad.State.Class.MonadState (Data.Dependent.Map.Internal.DMap f GHC.MVar.MVar) (t m), Data.GADT.Compare.GCompare f, Control.Monad.IO.Class.MonadIO (t m)) => Control.Monad.Trans.Fraxl.DataSource (Control.Monad.Trans.Fraxl.CachedFetch f) (t m)

module Control.Monad.Fraxl.Class

-- | Class for Fraxl-capable monads.
class Monad m => MonadFraxl f m

-- | <a>dataFetch</a> is used to make a request of type <tt>f</tt>.
dataFetch :: MonadFraxl f m => f a -> m a
instance (Control.Monad.Trans.Fraxl.DataSource f m, Data.Dependent.OpenUnion.Member f r) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Fraxl.Fraxl r m)
instance Control.Monad.Trans.Fraxl.DataSource f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Fraxl.FreerT f m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.List.ListT m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Reader.ReaderT e m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.State.Strict.StateT s m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Writer.Strict.WriterT w m)

module Control.Monad.Fraxl

-- | Fraxl is based on a particular Freer monad. This Freer monad has
--   applicative optimization, which is used to parallelize effects.
type FreerT f = FreeT (Ap f)

-- | Fraxl is just the <a>FreerT</a> monad transformer, applied with
--   <a>Union</a>. This is because <a>Fraxl</a> is just a free monad over a
--   variety of data sources.
type Fraxl r = FreerT (Union r)

-- | Data sources produce <a>Fetch</a> functions. They take a sequence of
--   effeects as an argument, and return a corresponding sequence of
--   monadic actions which are used to wait on the results.
type Fetch f m a = ASeq f a -> m (ASeq m a)

-- | A data source is an effect <tt>f</tt> that operates in some monad
--   <tt>m</tt>. Given a sequence of effects, a data source should use
--   <tt>m</tt> to prepare a corresponding sequence of results.
class Monad m => DataSource f m
fetch :: DataSource f m => Fetch f m q

-- | Runs a Fraxl computation. This takes <a>FreerT</a> as a parameter
--   rather than <a>Fraxl</a>, because <a>Fraxl</a> is meant for a union of
--   effects, but it should be possible to run a singleton effect.
runFraxl :: DataSource f m => FreerT f m a -> m a

-- | A simple method of turning an <a>IO</a> bound computation into a
--   <a>DataSource</a> <a>Fetch</a>.
simpleAsyncFetch :: MonadIO m => (forall x. f x -> IO x) -> Fetch f m a
data ASeq (f :: * -> *) a :: (* -> *) -> * -> *
ANil :: ASeq f ()
ACons :: f a1 -> ASeq f u -> ASeq f (a1, u)

-- | reduceASeq a sequence of applicative effects into an applicative.
reduceASeq :: Applicative f => ASeq f u -> f u

-- | Transform a sequence of <tt>f</tt> into a sequence of <tt>g</tt>.
hoistASeq :: (forall x. f x -> g x) -> ASeq f a -> ASeq g a

-- | Traverse a sequence with resepect to its interpretation type
--   <tt>f</tt>.
traverseASeq :: Applicative h => (forall x. f x -> h (g x)) -> ASeq f a -> h (ASeq g a)

-- | It may not look like it, but this appends two sequences. See <a>Dave
--   Menendez's work</a> for more explanation.
rebaseASeq :: ASeq f u -> (forall x. (x -> y) -> ASeq f x -> z) -> (v -> u -> y) -> ASeq f v -> z

-- | Caching in Fraxl works by translating <tt>FreerT f</tt> into
--   <tt>FreerT (CachedFetch f)</tt>, then running with
--   <tt>CachedFetch'</tt>s DataSource. That instance requires <tt>f</tt>
--   to to have a <a>GCompare</a> instance.
--   
--   The <a>CachedFetch</a> instance uses a <a>MonadState</a> to track
--   cached requests. The state variable is a <a>DMap</a> from the
--   'dependent-map' package. Keys are requests, and values are
--   <a>MVar</a>s of the results.
newtype CachedFetch f a
CachedFetch :: (f a) -> CachedFetch f a

-- | Runs a Fraxl computation with caching using a given starting cache.
--   Alongside the result, it returns the final cache.
runCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> DMap f MVar -> m (a, DMap f MVar)

-- | Like <a>runCachedFraxl</a>, except it starts with an empty cache and
--   discards the final cache.
evalCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> m a

-- | Class for Fraxl-capable monads.
class Monad m => MonadFraxl f m

-- | <a>dataFetch</a> is used to make a request of type <tt>f</tt>.
dataFetch :: MonadFraxl f m => f a -> m a

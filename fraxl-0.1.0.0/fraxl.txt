-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cached and parallel data fetching.
--   
--   See Haxl for something similar.
@package fraxl
@version 0.1.0.0

module Control.Monad.Trans.Fraxl

-- | Fraxl is based on a particular Freer monad. This Freer monad has
--   applicative optimization, which is used to parallelize effects.
type FreerT f = FreeT (Ap f)

-- | Fraxl is just the <a>FreerT</a> monad transformer, applied with
--   <a>Union</a>. This is because <a>Fraxl</a> is just a free monad over a
--   variety of data sources.
type Fraxl r = FreerT (Union r)

-- | Data sources produce <a>Fetch</a> functions. They take a sequence of
--   effeects as an argument, and return a corresponding sequence of
--   monadic actions which are used to wait on the results.
type Fetch f m a = ASeq f a -> m (ASeq m a)

-- | A data source is an effect <tt>f</tt> that operates in some monad
--   <tt>m</tt>. Given a sequence of effects, a data source should use
--   <tt>m</tt> to prepare a corresponding sequence of results.
class Monad m => DataSource f m
fetch :: DataSource f m => Fetch f m q

-- | Runs a Fraxl computation. This takes <a>FreerT</a> as a parameter
--   rather than <a>Fraxl</a>, because <a>Fraxl</a> is meant for a union of
--   effects, but it should be possible to run a singleton effect.
runFraxl :: DataSource f m => FreerT f m a -> m a

-- | A simple method of turning an <a>IO</a> bound computation into a
--   <a>DataSource</a> <a>Fetch</a>.
simpleAsyncFetch :: MonadIO m => (forall x. f x -> IO x) -> Fetch f m a
data ASeq (f :: * -> *) a :: (* -> *) -> * -> *
ANil :: ASeq f ()
ACons :: f a1 -> ASeq f u -> ASeq f (a1, u)

-- | reduceASeq a sequence of applicative effects into an applicative.
reduceASeq :: Applicative f => ASeq f u -> f u

-- | Transform a sequence of <tt>f</tt> into a sequence of <tt>g</tt>.
hoistASeq :: (forall x. f x -> g x) -> ASeq f a -> ASeq g a

-- | Traverse a sequence with resepect to its interpretation type
--   <tt>f</tt>.
traverseASeq :: Applicative h => (forall x. f x -> h (g x)) -> ASeq f a -> h (ASeq g a)

-- | It may not look like it, but this appends two sequences. See <a>Dave
--   Menendez's work</a> for more explanation.
rebaseASeq :: ASeq f u -> (forall x. (x -> y) -> ASeq f x -> z) -> (v -> u -> y) -> ASeq f v -> z

-- | Caching in Fraxl works by translating <tt>FreerT f</tt> into
--   <tt>FreerT (CachedFetch f)</tt>, then running with
--   <tt>CachedFetch'</tt>s DataSource. That instance requires <tt>f</tt>
--   to to have a <a>GCompare</a> instance.
--   
--   The <a>CachedFetch</a> instance uses a <a>MonadState</a> to track
--   cached requests. The state variable is a <a>DMap</a> from the
--   'dependent-map' package. Keys are requests, and values are
--   <a>MVar</a>s of the results.
newtype CachedFetch f a
CachedFetch :: (f a) -> CachedFetch f a

-- | Runs a Fraxl computation with caching using a given starting cache.
--   Alongside the result, it returns the final cache.
runCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> DMap f MVar -> m (a, DMap f MVar)

-- | Like <a>runCachedFraxl</a>, except it starts with an empty cache and
--   discards the final cache.
evalCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> m a
instance GHC.Base.Monad m => Control.Monad.Trans.Fraxl.DataSource (Data.Dependent.OpenUnion.Union '[]) m
instance (Control.Monad.Trans.Fraxl.DataSource f m, Control.Monad.Trans.Fraxl.DataSource (Data.Dependent.OpenUnion.Union r) m) => Control.Monad.Trans.Fraxl.DataSource (Data.Dependent.OpenUnion.Union (f : r)) m
instance (Control.Monad.Trans.Fraxl.DataSource f m, Control.Monad.Trans.Class.MonadTrans t, Control.Monad.State.Class.MonadState (Data.Dependent.Map.Internal.DMap f GHC.MVar.MVar) (t m), Data.GADT.Compare.GCompare f, Control.Monad.IO.Class.MonadIO (t m)) => Control.Monad.Trans.Fraxl.DataSource (Control.Monad.Trans.Fraxl.CachedFetch f) (t m)

module Control.Monad.Fraxl.Class

-- | Class for Fraxl-capable monads.
class Monad m => MonadFraxl f m

-- | <a>dataFetch</a> is used to make a request of type <tt>f</tt>.
dataFetch :: MonadFraxl f m => f a -> m a
instance (Control.Monad.Trans.Fraxl.DataSource f m, Data.Dependent.OpenUnion.Member f r) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Fraxl.Fraxl r m)
instance Control.Monad.Trans.Fraxl.DataSource f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Fraxl.FreerT f m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.List.ListT m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Reader.ReaderT e m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.State.Strict.StateT s m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Writer.Strict.WriterT w m)


-- | Fraxl is a library based on Facebook's <a>Haxl</a>. The goal is to
--   decompose Haxl into more general parts, in order to form a stronger
--   composition with better type safety and purity.
--   
--   Usage ---
--   
--   Using Fraxl is fairly similar to Haxl. You define a request data type
--   (often a GADT), and a <a>DataSource</a> instance. With this, Fraxl is
--   able to perform requests concurrently.
--   
--   <pre>
--   data MySource a where
--     MyString :: MySource String
--     MyInt :: MySource Int
--   
--   class Monad m =&gt; DataSource f m
--     fetch :: ASeq f a -&gt; m (ASeq m a)
--   
--   instance MonadIO m =&gt; DataSource MySource m where
--     fetch ANil = return ANil
--     fetch (ACons f fs) = ((:&amp;) . liftIO . wait) <a>$</a> liftIO (async $ downloadSource f) <a>*</a> fetch fs
--   </pre>
--   
--   You'll notice a few things here. For one, a data source can choose
--   what monad it lives in. Unlike Haxl, which only lets you live in
--   <a>IO</a>, Fraxl is a monad transformer, allowing you to use arbitrary
--   underlying monads. Thus, maintaining state between fetches can be left
--   up to the data source. This can be used for several things, such as
--   caching or session management.
--   
--   `ASeq :: (* -&gt; *) -&gt; * -&gt; *` is similar to a heterogenous
--   list. It is the data structure used by the fast free applicative.
--   Interpreting this is akin to interpreting the free applicative.
--   
--   The <a>fetch</a> method takes a list of <tt>f</tt> requests, and for
--   each request, returns an <tt>m</tt> action that waits on the response.
--   That is, <a>fetch</a> should start background threads for requests,
--   and return all the actions for Fraxl to block with until they
--   complete. This way, Fraxl can have many requests start their work in
--   parallel, and call all their wait-actions together.
--   
--   Composition ---
--   
--   Fraxl is a composition of general tools. At the base of this
--   composition is a free monad transformer ([the basis of which is
--   described
--   here](http:/<i>elvishjerricco.github.io</i>2016<i>04</i>08/applicative-effects-in-free-monads.html)).
--   This is because Fraxl (and Haxl) is necessarily a free monad. It's
--   taking arbitrary data sources of kind `* -&gt; *`, and constructing a
--   monad out of them. Since there exists a free monad transformer with
--   applicative optimization, there's no reason not to use it and get the
--   transformer structure for free.
--   
--   <ul>
--   <li>*NOTE:** *This free monad is not in the latest version of
--   <tt>free</tt> yet. So <tt>free</tt> is used as a git submodule to gain
--   access to it.*</li>
--   </ul>
--   
--   The next layer of the composition is the free applicative. The free
--   monad with applicative optimization uses any applicative (rather than
--   any functor, as with the traditional free monad). Since the free
--   applicative uses any type of kind `* -&gt; *`, it is the perfect
--   candidate for this layer. It allows Fraxl to see all the requests made
--   in an applicative computation at once, which is how Fraxl can
--   parallelize them.
--   
--   The final layer is the data source layer. It is user-specified, but
--   will often be a dependent open union. The dependent open union is
--   essentially a nested either type over any number of types. If all of
--   those types are data sources, the dependent open union allows Fraxl to
--   handle all of them as one data source, in one layer of Fraxl. The nice
--   thing about this is that it makes it type safe to use a data source.
--   Whereas Haxl will simply trust that you know what you're doing, Fraxl
--   will make it a type error to forget to initialize a data source, or
--   call a computation without guaranteeing its data source is available.
--   
--   The data source layer can be easily modified. Caching is a
--   substitution of this layer that replaces the data source with one that
--   caches the results of the original. It does this with a dependent map,
--   whose keys are requests, and whose values are <tt>MVars</tt> of the
--   results. If an uncached request is requested, an empty <tt>MVar</tt>
--   is inserted into the cache map, the original <a>fetch</a> is called,
--   and the result is stored in the <tt>MVar</tt>. If a cached request is
--   requested, the wait-action returned will simply be <tt>readMVar</tt>.
module Control.Monad.Fraxl

-- | Fraxl is based on a particular Freer monad. This Freer monad has
--   applicative optimization, which is used to parallelize effects.
type FreerT f = FreeT (Ap f)

-- | Fraxl is just the <a>FreerT</a> monad transformer, applied with
--   <a>Union</a>. This is because <a>Fraxl</a> is just a free monad over a
--   variety of data sources.
type Fraxl r = FreerT (Union r)

-- | Data sources produce <a>Fetch</a> functions. They take a sequence of
--   effeects as an argument, and return a corresponding sequence of
--   monadic actions which are used to wait on the results.
type Fetch f m a = ASeq f a -> m (ASeq m a)

-- | A data source is an effect <tt>f</tt> that operates in some monad
--   <tt>m</tt>. Given a sequence of effects, a data source should use
--   <tt>m</tt> to prepare a corresponding sequence of results.
class Monad m => DataSource f m
fetch :: DataSource f m => Fetch f m q

-- | Runs a Fraxl computation. This takes <a>FreerT</a> as a parameter
--   rather than <a>Fraxl</a>, because <a>Fraxl</a> is meant for a union of
--   effects, but it should be possible to run a singleton effect.
runFraxl :: DataSource f m => FreerT f m a -> m a

-- | A simple method of turning an <a>IO</a> bound computation into a
--   <a>DataSource</a> <a>Fetch</a>.
simpleAsyncFetch :: MonadIO m => (forall x. f x -> IO x) -> Fetch f m a
data ASeq (f :: * -> *) a :: (* -> *) -> * -> *
ANil :: ASeq f ()
ACons :: f a1 -> ASeq f u -> ASeq f (a1, u)

-- | reduceASeq a sequence of applicative effects into an applicative.
reduceASeq :: Applicative f => ASeq f u -> f u

-- | Transform a sequence of <tt>f</tt> into a sequence of <tt>g</tt>.
hoistASeq :: (forall x. f x -> g x) -> ASeq f a -> ASeq g a

-- | Traverse a sequence with resepect to its interpretation type
--   <tt>f</tt>.
traverseASeq :: Applicative h => (forall x. f x -> h (g x)) -> ASeq f a -> h (ASeq g a)

-- | It may not look like it, but this appends two sequences. See <a>Dave
--   Menendez's work</a> for more explanation.
rebaseASeq :: ASeq f u -> (forall x. (x -> y) -> ASeq f x -> z) -> (v -> u -> y) -> ASeq f v -> z

-- | Caching in Fraxl works by translating <tt>FreerT f</tt> into
--   <tt>FreerT (CachedFetch f)</tt>, then running with
--   <tt>CachedFetch'</tt>s DataSource. That instance requires <tt>f</tt>
--   to to have a <a>GCompare</a> instance.
--   
--   The <a>CachedFetch</a> instance uses a <a>MonadState</a> to track
--   cached requests. The state variable is a <a>DMap</a> from the
--   'dependent-map' package. Keys are requests, and values are
--   <a>MVar</a>s of the results.
newtype CachedFetch f a
CachedFetch :: (f a) -> CachedFetch f a

-- | Runs a Fraxl computation with caching using a given starting cache.
--   Alongside the result, it returns the final cache.
runCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> DMap f MVar -> m (a, DMap f MVar)

-- | Like <a>runCachedFraxl</a>, except it starts with an empty cache and
--   discards the final cache.
evalCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> m a

-- | Class for Fraxl-capable monads.
class Monad m => MonadFraxl f m

-- | <a>dataFetch</a> is used to make a request of type <tt>f</tt>.
dataFetch :: MonadFraxl f m => f a -> m a

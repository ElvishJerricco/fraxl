-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cached and parallel data fetching.
--   
--   See Haxl for something similar.
@package fraxl
@version 0.1.0.0

module Control.Monad.Trans.Fraxl.Free

-- | The base functor for a free monad.
data FreeF f m a
Pure :: a -> FreeF f m a
Free :: f b -> FastTCQueue (Kleisli (FreeT f m)) b a -> FreeF f m a

-- | The "free monad transformer" for an applicative functor <tt>f</tt>
newtype FreeT f m a
FreeT :: m (FreeF f m a) -> FreeT f m a
[runFreeT] :: FreeT f m a -> m (FreeF f m a)

-- | The "free monad" for an applicative functor <tt>f</tt>.
type Free f = FreeT f Identity

-- | A version of lift that can be used with just a Functor for f.
liftF :: (Functor f, MonadFree f m) => f a -> m a

-- | Tear down a free monad transformer using iteration.
iterT :: (Applicative f, Monad m) => (f (m a) -> m a) -> FreeT f m a -> m a

-- | Tear down a free monad transformer using iteration over a transformer.
iterTM :: (Applicative f, Monad m, MonadTrans t, Monad (t m)) => (f (t m a) -> t m a) -> FreeT f m a -> t m a

-- | Lift a monad homomorphism from <tt>m</tt> to <tt>n</tt> into a monad
--   homomorphism from <tt><a>FreeT</a> f m</tt> to <tt><a>FreeT</a> f
--   n</tt>
--   
--   <pre>
--   <a>hoistFreeT</a> :: (<a>Monad</a> m, <a>Functor</a> f) =&gt; (m ~&gt; n) -&gt; <a>FreeT</a> f m ~&gt; <a>FreeT</a> f n
--   </pre>
hoistFreeT :: (Monad m, Applicative f) => (forall a. m a -> n a) -> FreeT f m b -> FreeT f n b

-- | Lift a natural transformation from <tt>f</tt> to <tt>g</tt> into a
--   monad homomorphism from <tt><a>FreeT</a> f m</tt> to <tt><a>FreeT</a>
--   g m</tt>
transFreeT :: (Applicative f, Monad m) => (forall a. f a -> g a) -> FreeT f m b -> FreeT g m b

-- | Pull out and join <tt>m</tt> layers of <tt><a>FreeT</a> f m a</tt>.
joinFreeT :: (Monad m, Traversable f, Applicative f) => FreeT f m a -> m (Free f a)

-- | Tear down a free monad transformer using Monad instance for <tt>t
--   m</tt>.
retractT :: (MonadTrans t, Monad (t m), Monad m) => FreeT (t m) m a -> t m a

-- | <a>retract</a> is the left inverse of <a>liftF</a>
--   
--   <pre>
--   <a>retract</a> . <a>liftF</a> = <a>id</a>
--   </pre>
retract :: Monad f => Free f a -> f a

-- | Tear down a <a>Free</a> <a>Monad</a> using iteration.
iter :: Applicative f => (f a -> a) -> Free f a -> a

-- | Like <a>iter</a> for monadic values.
iterM :: (Applicative f, Monad m) => (f (m a) -> m a) -> Free f a -> m a

-- | Monads provide substitution (<a>fmap</a>) and renormalization
--   (<a>join</a>):
--   
--   <pre>
--   m <a>&gt;&gt;=</a> f = <a>join</a> (<a>fmap</a> f m)
--   </pre>
--   
--   A free <a>Monad</a> is one that does no work during the normalization
--   step beyond simply grafting the two monadic values together.
--   
--   <tt>[]</tt> is not a free <a>Monad</a> (in this sense) because
--   <tt><a>join</a> [[a]]</tt> smashes the lists flat.
--   
--   On the other hand, consider:
--   
--   <pre>
--   data Tree a = Bin (Tree a) (Tree a) | Tip a
--   </pre>
--   
--   <pre>
--   instance <a>Monad</a> Tree where
--     <a>return</a> = Tip
--     Tip a <a>&gt;&gt;=</a> f = f a
--     Bin l r <a>&gt;&gt;=</a> f = Bin (l <a>&gt;&gt;=</a> f) (r <a>&gt;&gt;=</a> f)
--   </pre>
--   
--   This <a>Monad</a> is the free <a>Monad</a> of Pair:
--   
--   <pre>
--   data Pair a = Pair a a
--   </pre>
--   
--   And we could make an instance of <a>MonadFree</a> for it directly:
--   
--   <pre>
--   instance <a>MonadFree</a> Pair Tree where
--      <a>wrap</a> (Pair l r) = Bin l r
--   </pre>
--   
--   Or we could choose to program with <tt><a>Free</a> Pair</tt> instead
--   of <tt>Tree</tt> and thereby avoid having to define our own
--   <a>Monad</a> instance.
--   
--   Moreover, <a>Control.Monad.Free.Church</a> provides a <a>MonadFree</a>
--   instance that can improve the <i>asymptotic</i> complexity of code
--   that constructs free monads by effectively reassociating the use of
--   (<a>&gt;&gt;=</a>). You may also want to take a look at the
--   <tt>kan-extensions</tt> package
--   (<a>http://hackage.haskell.org/package/kan-extensions</a>).
--   
--   See <a>Free</a> for a more formal definition of the free <a>Monad</a>
--   for a <a>Functor</a>.
class Monad m => MonadFree (f :: * -> *) (m :: * -> *) | m -> f

-- | Add a layer.
--   
--   <pre>
--   wrap (fmap f x) â‰¡ wrap (fmap return x) &gt;&gt;= f
--   </pre>
wrap :: MonadFree f m => f (m a) -> m a
instance (GHC.Base.Applicative f, GHC.Base.Monad m) => GHC.Base.Functor (Control.Monad.Trans.Fraxl.Free.FreeF f m)
instance (GHC.Base.Applicative f, GHC.Base.Monad m) => GHC.Base.Functor (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Fraxl.Free.FreeT f)
instance (GHC.Base.Applicative f, GHC.Base.Monad m) => Control.Monad.Free.Class.MonadFree f (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, Control.Monad.Reader.Class.MonadReader r m) => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, Control.Monad.Writer.Class.MonadWriter w m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, Control.Monad.State.Class.MonadState s m) => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, Control.Monad.Error.Class.MonadError e m) => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, Control.Monad.Catch.MonadThrow m) => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Fraxl.Free.FreeT f m)
instance (GHC.Base.Applicative f, Control.Monad.Catch.MonadCatch m) => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.Fraxl.Free.FreeT f m)

module Control.Monad.Trans.Fraxl

-- | Fraxl is based on a particular Freer monad. This Freer monad has
--   applicative optimization, which is used to parallelize effects.
type FreerT f = FreeT (Ap f)

-- | Fraxl is just the <a>FreerT</a> monad transformer, applied with
--   <a>Union</a>. This is because <a>Fraxl</a> is just a free monad over a
--   variety of data sources.
type Fraxl r = FreerT (Union r)

-- | Data sources produce <a>Fetch</a> functions. They take a sequence of
--   effeects as an argument, and return a corresponding sequence of
--   monadic actions which are used to wait on the results.
type Fetch f m a = ASeq f a -> m (ASeq m a)

-- | A data source is an effect <tt>f</tt> that operates in some monad
--   <tt>m</tt>. Given a sequence of effects, a data source should use
--   <tt>m</tt> to prepare a corresponding sequence of results.
class Monad m => DataSource f m
fetch :: DataSource f m => Fetch f m q

-- | Runs a Fraxl computation. This takes <a>FreerT</a> as a parameter
--   rather than <a>Fraxl</a>, because <a>Fraxl</a> is meant for a union of
--   effects, but it should be possible to run a singleton effect.
runFraxl :: DataSource f m => FreerT f m a -> m a

-- | A simple method of turning an <a>IO</a> bound computation into a
--   <a>DataSource</a> <a>Fetch</a>.
simpleAsyncFetch :: MonadIO m => (forall x. f x -> IO x) -> Fetch f m a
data ASeq (f :: * -> *) a :: (* -> *) -> * -> *
ANil :: ASeq f ()
ACons :: f a1 -> ASeq f u -> ASeq f (a1, u)

-- | reduceASeq a sequence of applicative effects into an applicative.
reduceASeq :: Applicative f => ASeq f u -> f u

-- | Transform a sequence of <tt>f</tt> into a sequence of <tt>g</tt>.
hoistASeq :: (forall x. f x -> g x) -> ASeq f a -> ASeq g a

-- | Traverse a sequence with resepect to its interpretation type
--   <tt>f</tt>.
traverseASeq :: Applicative h => (forall x. f x -> h (g x)) -> ASeq f a -> h (ASeq g a)

-- | It may not look like it, but this appends two sequences. See <a>Dave
--   Menendez's work</a> for more explanation.
rebaseASeq :: ASeq f u -> (forall x. (x -> y) -> ASeq f x -> z) -> (v -> u -> y) -> ASeq f v -> z

-- | Caching in Fraxl works by translating <tt>FreerT f</tt> into
--   <tt>FreerT (CachedFetch f)</tt>, then running with
--   <tt>CachedFetch'</tt>s DataSource. That instance requires <tt>f</tt>
--   to to have a <a>GCompare</a> instance.
--   
--   The <a>CachedFetch</a> instance uses a <a>MonadState</a> to track
--   cached requests. The state variable is a <a>DMap</a> from the
--   'dependent-map' package. Keys are requests, and values are
--   <a>MVar</a>s of the results.
newtype CachedFetch f a
CachedFetch :: (f a) -> CachedFetch f a

-- | Runs a Fraxl computation with caching using a given starting cache.
--   Alongside the result, it returns the final cache.
runCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> DMap f MVar -> m (a, DMap f MVar)

-- | Like <a>runCachedFraxl</a>, except it starts with an empty cache and
--   discards the final cache.
evalCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> m a
instance GHC.Base.Monad m => Control.Monad.Trans.Fraxl.DataSource (Data.Dependent.OpenUnion.Union '[]) m
instance (Control.Monad.Trans.Fraxl.DataSource f m, Control.Monad.Trans.Fraxl.DataSource (Data.Dependent.OpenUnion.Union r) m) => Control.Monad.Trans.Fraxl.DataSource (Data.Dependent.OpenUnion.Union (f : r)) m
instance (Control.Monad.Trans.Fraxl.DataSource f m, Control.Monad.Trans.Class.MonadTrans t, Control.Monad.State.Class.MonadState (Data.Dependent.Map.Internal.DMap f GHC.MVar.MVar) (t m), Data.GADT.Compare.GCompare f, Control.Monad.IO.Class.MonadIO (t m)) => Control.Monad.Trans.Fraxl.DataSource (Control.Monad.Trans.Fraxl.CachedFetch f) (t m)

module Control.Monad.Fraxl.Class

-- | Class for Fraxl-capable monads.
class Monad m => MonadFraxl f m

-- | <a>dataFetch</a> is used to make a request of type <tt>f</tt>.
dataFetch :: MonadFraxl f m => f a -> m a
instance (Control.Monad.Trans.Fraxl.DataSource f m, Data.Dependent.OpenUnion.Member f r) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Fraxl.Fraxl r m)
instance Control.Monad.Trans.Fraxl.DataSource f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Fraxl.FreerT f m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.List.ListT m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Reader.ReaderT e m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Fraxl.Class.MonadFraxl f m => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.State.Strict.StateT s m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Control.Monad.Fraxl.Class.MonadFraxl f m, GHC.Base.Monoid w) => Control.Monad.Fraxl.Class.MonadFraxl f (Control.Monad.Trans.Writer.Strict.WriterT w m)


-- | Fraxl is a library based on Facebook's <a>Haxl</a>. The goal is to
--   decompose Haxl into more general parts, in order to form a stronger
--   composition with better type safety and purity.
--   
--   <h1>Usage</h1>
--   
--   Using Fraxl is fairly similar to Haxl. You define a request data type
--   (often a GADT), and a <a>DataSource</a> instance. With this, Fraxl is
--   able to perform requests concurrently.
--   
--   <pre>
--   data MySource a where
--     MyString :: MySource String
--     MyInt :: MySource Int
--   
--   class Monad m =&gt; DataSource f m
--     fetch :: ASeq f a -&gt; m (ASeq m a)
--   
--   instance MonadIO m =&gt; DataSource MySource m where
--     fetch ANil = return ANil
--     fetch (ACons f fs) = (ACons . liftIO . wait) <a>$</a> liftIO (async $ downloadSource f) <a>*</a> fetch fs
--   </pre>
--   
--   You'll notice a few things here. For one, a data source can choose
--   what monad it lives in. Unlike Haxl, which only lets you live in
--   <a>IO</a>, Fraxl is a monad transformer, allowing you to use arbitrary
--   underlying monads. Thus, maintaining state between fetches can be left
--   up to the data source. This can be used for several things, such as
--   caching or session management.
--   
--   <tt>ASeq :: (* -&gt; *) -&gt; * -&gt; *</tt> is similar to a
--   heterogenous list. It is the data structure used by the fast free
--   applicative. Interpreting this is akin to interpreting the free
--   applicative.
--   
--   The <a>fetch</a> method takes a list of <tt>f</tt> requests, and for
--   each request, returns an <tt>m</tt> action that waits on the response.
--   That is, <a>fetch</a> should start background threads for requests,
--   and return all the actions for Fraxl to block with until they
--   complete. This way, Fraxl can have many requests start their work in
--   parallel, and call all their wait-actions together.
--   
--   <h1>Composition</h1>
--   
--   Fraxl is a composition of general tools. At the base of this
--   composition is a free monad transformer ([the basis of which is
--   described
--   here](http:/<i>elvishjerricco.github.io</i>2016<i>04</i>08/applicative-effects-in-free-monads.html)).
--   This is because Fraxl (and Haxl) is necessarily a free monad. It's
--   taking arbitrary data sources of kind <tt>* -&gt; *</tt>, and
--   constructing a monad out of them. Since there exists a free monad
--   transformer with applicative optimization, there's no reason not to
--   use it and get the transformer structure for free.
--   
--   <b>NOTE:</b> <i>This free monad is not in the latest version of
--   <tt>free</tt> yet.</i> <i>So <tt>free</tt> is used as a git submodule
--   to gain access to it.</i>
--   
--   The next layer of the composition is the free applicative. The free
--   monad with applicative optimization uses any applicative (rather than
--   any functor, as with the traditional free monad). Since the free
--   applicative uses any type of kind <tt>* -&gt; *</tt>, it is the
--   perfect candidate for this layer. It allows Fraxl to see all the
--   requests made in an applicative computation at once, which is how
--   Fraxl can parallelize them.
--   
--   The final layer is the data source layer. It is user-specified, but
--   will often be a dependent open union. The dependent open union is
--   essentially a nested either type over any number of types. If all of
--   those types are data sources, the dependent open union allows Fraxl to
--   handle all of them as one data source, in one layer of Fraxl. The nice
--   thing about this is that it makes it type safe to use a data source.
--   Whereas Haxl will simply trust that you know what you're doing, Fraxl
--   will make it a type error to forget to initialize a data source, or
--   call a computation without guaranteeing its data source is available.
--   
--   The data source layer can be easily modified. Caching is a
--   substitution of this layer that replaces the data source with one that
--   caches the results of the original. It does this with a dependent map,
--   whose keys are requests, and whose values are <tt>MVars</tt> of the
--   results. If an uncached request is requested, an empty <tt>MVar</tt>
--   is inserted into the cache map, the original <tt>fetch</tt> is called,
--   and the result is stored in the <tt>MVar</tt>. If a cached request is
--   requested, the wait-action returned will simply be <tt>readMVar</tt>.
module Control.Monad.Fraxl

-- | Fraxl is based on a particular Freer monad. This Freer monad has
--   applicative optimization, which is used to parallelize effects.
type FreerT f = FreeT (Ap f)

-- | Fraxl is just the <a>FreerT</a> monad transformer, applied with
--   <a>Union</a>. This is because <a>Fraxl</a> is just a free monad over a
--   variety of data sources.
type Fraxl r = FreerT (Union r)

-- | Data sources produce <a>Fetch</a> functions. They take a sequence of
--   effeects as an argument, and return a corresponding sequence of
--   monadic actions which are used to wait on the results.
type Fetch f m a = ASeq f a -> m (ASeq m a)

-- | A data source is an effect <tt>f</tt> that operates in some monad
--   <tt>m</tt>. Given a sequence of effects, a data source should use
--   <tt>m</tt> to prepare a corresponding sequence of results.
class Monad m => DataSource f m
fetch :: DataSource f m => Fetch f m q

-- | Runs a Fraxl computation. This takes <a>FreerT</a> as a parameter
--   rather than <a>Fraxl</a>, because <a>Fraxl</a> is meant for a union of
--   effects, but it should be possible to run a singleton effect.
runFraxl :: DataSource f m => FreerT f m a -> m a

-- | A simple method of turning an <a>IO</a> bound computation into a
--   <a>DataSource</a> <a>Fetch</a>.
simpleAsyncFetch :: MonadIO m => (forall x. f x -> IO x) -> Fetch f m a
data ASeq (f :: * -> *) a :: (* -> *) -> * -> *
ANil :: ASeq f ()
ACons :: f a1 -> ASeq f u -> ASeq f (a1, u)

-- | reduceASeq a sequence of applicative effects into an applicative.
reduceASeq :: Applicative f => ASeq f u -> f u

-- | Transform a sequence of <tt>f</tt> into a sequence of <tt>g</tt>.
hoistASeq :: (forall x. f x -> g x) -> ASeq f a -> ASeq g a

-- | Traverse a sequence with resepect to its interpretation type
--   <tt>f</tt>.
traverseASeq :: Applicative h => (forall x. f x -> h (g x)) -> ASeq f a -> h (ASeq g a)

-- | It may not look like it, but this appends two sequences. See <a>Dave
--   Menendez's work</a> for more explanation.
rebaseASeq :: ASeq f u -> (forall x. (x -> y) -> ASeq f x -> z) -> (v -> u -> y) -> ASeq f v -> z

-- | Caching in Fraxl works by translating <tt>FreerT f</tt> into
--   <tt>FreerT (CachedFetch f)</tt>, then running with
--   <tt>CachedFetch'</tt>s DataSource. That instance requires <tt>f</tt>
--   to to have a <a>GCompare</a> instance.
--   
--   The <a>CachedFetch</a> instance uses a <a>MonadState</a> to track
--   cached requests. The state variable is a <a>DMap</a> from the
--   'dependent-map' package. Keys are requests, and values are
--   <a>MVar</a>s of the results.
newtype CachedFetch f a
CachedFetch :: (f a) -> CachedFetch f a

-- | Runs a Fraxl computation with caching using a given starting cache.
--   Alongside the result, it returns the final cache.
runCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> DMap f MVar -> m (a, DMap f MVar)

-- | Like <a>runCachedFraxl</a>, except it starts with an empty cache and
--   discards the final cache.
evalCachedFraxl :: (MonadIO m, DataSource f m, GCompare f) => FreerT f m a -> m a

-- | Class for Fraxl-capable monads.
class Monad m => MonadFraxl f m

-- | <a>dataFetch</a> is used to make a request of type <tt>f</tt>.
dataFetch :: MonadFraxl f m => f a -> m a

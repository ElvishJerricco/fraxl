<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Monad.Fraxl</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Monad-Fraxl.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">fraxl-0.1.0.0: Cached and parallel data fetching.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Monad.Fraxl</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">The Fraxl Monad</a></li><li><a href="#g:2">The Sequence of Effects</a></li><li><a href="#g:3">Caching</a></li><li><a href="#g:4">Fraxl Monads</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Fraxl is a library based on Facebook's <a href="https://github.com/facebook/Haxl">Haxl</a>.
The goal is to decompose Haxl into more general parts,
in order to form a stronger composition with better type safety and purity.</p><h1>Usage</h1><p>Using Fraxl is fairly similar to Haxl.
You define a request data type (often a GADT), and a <code><a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a></code> instance.
With this, Fraxl is able to perform requests concurrently.</p><pre>data MySource a where
  MyString :: MySource String
  MyInt :: MySource Int

class Monad m =&gt; DataSource f m
  fetch :: ASeq f a -&gt; m (ASeq m a)

instance MonadIO m =&gt; DataSource MySource m where
  fetch ANil = return ANil
  fetch (ACons f fs) = (ACons . liftIO . wait) <a href="$">$</a> liftIO (async $ downloadSource f) <a href="*">*</a> fetch fs
</pre><p>You'll notice a few things here.
For one, a data source can choose what monad it lives in.
Unlike Haxl, which only lets you live in <code><a href="../base-4.8.2.0/System-IO.html#t:IO">IO</a></code>,
Fraxl is a monad transformer, allowing you to use arbitrary underlying monads.
Thus, maintaining state between fetches can be left up to the data source.
This can be used for several things, such as caching or session management.</p><p><code>ASeq :: (* -&gt; *) -&gt; * -&gt; *</code> is similar to a heterogenous list.
It is the data structure used by the fast free applicative.
Interpreting this is akin to interpreting the free applicative.</p><p>The <code><a href="Control-Monad-Fraxl.html#v:fetch">fetch</a></code> method takes a list of <code>f</code> requests,
and for each request, returns an <code>m</code> action that waits on the response.
That is, <code><a href="Control-Monad-Fraxl.html#v:fetch">fetch</a></code> should start background threads for requests,
and return all the actions for Fraxl to block with until they complete.
This way, Fraxl can have many requests start their work in parallel,
and call all their wait-actions together.</p><h1>Composition</h1><p>Fraxl is a composition of general tools.
At the base of this composition is a free monad transformer
([the basis of which is described here](http:/<em>elvishjerricco.github.io</em>2016<em>04</em>08/applicative-effects-in-free-monads.html)).
This is because Fraxl (and Haxl) is necessarily a free monad.
It's taking arbitrary data sources of kind <code>* -&gt; *</code>,
and constructing a monad out of them.
Since there exists a free monad transformer with applicative optimization,
there's no reason not to use it and get the transformer structure for free.</p><p><strong>NOTE:</strong> <em>This free monad is not in the latest version of <code>free</code> yet.</em>
<em>So <code>free</code> is used as a git submodule to gain access to it.</em></p><p>The next layer of the composition is the free applicative.
The free monad with applicative optimization uses any applicative
(rather than any functor, as with the traditional free monad).
Since the free applicative uses any type of kind <code>* -&gt; *</code>,
it is the perfect candidate for this layer.
It allows Fraxl to see all the requests made in
an applicative computation at once, which is how Fraxl can parallelize them.</p><p>The final layer is the data source layer.
It is user-specified, but will often be a dependent open union.
The dependent open union is essentially a nested either type
over any number of types.
If all of those types are data sources, the dependent open union allows
Fraxl to handle all of them as one data source, in one layer of Fraxl.
The nice thing about this is that it makes it type safe to use a data source.
Whereas Haxl will simply trust that you know what you're doing,
Fraxl will make it a type error to forget to initialize a data source,
or call a computation without guaranteeing its data source is available.</p><p>The data source layer can be easily modified.
Caching is a substitution of this layer that replaces the data
source with one that caches the results of the original.
It does this with a dependent map, whose keys are requests,
and whose values are <code>MVars</code> of the results.
If an uncached request is requested,
an empty <code>MVar</code> is inserted into the cache map, the original <code>fetch</code> is called,
and the result is stored in the <code>MVar</code>.
If a cached request is requested,
the wait-action returned will simply be <code>readMVar</code>.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:FreerT">FreerT</a> f = <a href="Control-Monad-Trans-Fraxl-Free.html#t:FreeT">FreeT</a> (<a href="../free-4.12.4/Control-Applicative-Free-Fast.html#t:Ap">Ap</a> f)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Fraxl">Fraxl</a> r = <a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> r)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Fetch">Fetch</a> f m a = <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; m (<a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> m a)</li><li class="src short"><span class="keyword">class</span> <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="#t:DataSource">DataSource</a> f m <span class="keyword">where</span><ul class="subs"><li><a href="#v:fetch">fetch</a> :: <a href="Control-Monad-Fraxl.html#t:Fetch">Fetch</a> f m q</li></ul></li><li class="src short"><a href="#v:runFraxl">runFraxl</a> :: <span class="keyword">forall</span> f m a. <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; m a</li><li class="src short"><a href="#v:simpleAsyncFetch">simpleAsyncFetch</a> :: <a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m =&gt; (<span class="keyword">forall</span> x. f x -&gt; <a href="../base-4.8.2.0/System-IO.html#t:IO">IO</a> x) -&gt; <a href="Control-Monad-Fraxl.html#t:Fetch">Fetch</a> f m a</li><li class="src short"><span class="keyword">data</span> <a href="#t:ASeq">ASeq</a> f a :: (* -&gt; *) -&gt; * -&gt; * <span class="keyword">where</span><ul class="subs"><li><a href="#v:ANil">ANil</a> ::  <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f ()</li><li><a href="#v:ACons">ACons</a> ::  f a1 -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f (a1, u)</li></ul></li><li class="src short"><a href="#v:reduceASeq">reduceASeq</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; f u</li><li class="src short"><a href="#v:hoistASeq">hoistASeq</a> :: (<span class="keyword">forall</span> x. f x -&gt; g x) -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> g a</li><li class="src short"><a href="#v:traverseASeq">traverseASeq</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> h =&gt; (<span class="keyword">forall</span> x. f x -&gt; h (g x)) -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; h (<a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> g a)</li><li class="src short"><a href="#v:rebaseASeq">rebaseASeq</a> :: <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; (<span class="keyword">forall</span> x. (x -&gt; y) -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f x -&gt; z) -&gt; (v -&gt; u -&gt; y) -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f v -&gt; z</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:CachedFetch">CachedFetch</a> f a = <a href="#v:CachedFetch">CachedFetch</a> (f a)</li><li class="src short"><a href="#v:runCachedFraxl">runCachedFraxl</a> :: <span class="keyword">forall</span> m f a. (<a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m, <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> f) =&gt; <a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a> -&gt; m (a, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a>)</li><li class="src short"><a href="#v:evalCachedFraxl">evalCachedFraxl</a> :: <span class="keyword">forall</span> m f a. (<a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m, <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> f) =&gt; <a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; m a</li><li class="src short">module <a href="../dependent-sum-0.3.2.1/Data-GADT-Compare.html">Data.GADT.Compare</a></li><li class="src short"><span class="keyword">class</span> <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="#t:MonadFraxl">MonadFraxl</a> f m <span class="keyword">where</span><ul class="subs"><li><a href="#v:dataFetch">dataFetch</a> :: f a -&gt; m a</li></ul></li></ul></div><div id="interface"><h1 id="g:1">The Fraxl Monad</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:FreerT" class="def">FreerT</a> f = <a href="Control-Monad-Trans-Fraxl-Free.html#t:FreeT">FreeT</a> (<a href="../free-4.12.4/Control-Applicative-Free-Fast.html#t:Ap">Ap</a> f)</p><div class="doc"><p>Fraxl is based on a particular Freer monad.
 This Freer monad has applicative optimization,
 which is used to parallelize effects.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Fraxl" class="def">Fraxl</a> r = <a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> r)</p><div class="doc"><p>Fraxl is just the <code><a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a></code> monad transformer, applied with <code><a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a></code>.
 This is because <code><a href="Control-Monad-Fraxl.html#t:Fraxl">Fraxl</a></code> is just a free monad over a variety of data sources.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Fetch" class="def">Fetch</a> f m a = <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; m (<a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> m a)</p><div class="doc"><p>Data sources produce <code><a href="Control-Monad-Fraxl.html#t:Fetch">Fetch</a></code> functions.
 They take a sequence of effeects as an argument,
 and return a corresponding sequence of monadic actions
 which are used to wait on the results.</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a name="t:DataSource" class="def">DataSource</a> f m <span class="keyword">where</span></p><div class="doc"><p>A data source is an effect <code>f</code> that operates in some monad <code>m</code>.
 Given a sequence of effects,
 a data source should use <code>m</code> to prepare a corresponding sequence of results.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:fetch" class="def">fetch</a> :: <a href="Control-Monad-Fraxl.html#t:Fetch">Fetch</a> f m q</p></div><div class="subs instances"><p id="control.i:DataSource" class="caption collapser" onclick="toggleSection('i:DataSource')">Instances</p><div id="section.i:DataSource" class="show"><table><tr><td class="src clearfix"><span class="inst-left">(<a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m, <a href="../transformers-0.4.2.0/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> t, <a href="../mtl-2.2.1/Control-Monad-State-Class.html#t:MonadState">MonadState</a> (<a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> * f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a>) (t m), <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> * f, <a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> (t m)) =&gt; <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> (<a href="Control-Monad-Fraxl.html#t:CachedFetch">CachedFetch</a> f) (t m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m, <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> * r) m) =&gt; <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> * ((:) (* -&gt; *) f r)) m</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> (<a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Union">Union</a> * ([] (* -&gt; *))) m</span></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:runFraxl" class="def">runFraxl</a> :: <span class="keyword">forall</span> f m a. <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; m a</p><div class="doc"><p>Runs a Fraxl computation.
 This takes <code><a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a></code> as a parameter rather than <code><a href="Control-Monad-Fraxl.html#t:Fraxl">Fraxl</a></code>,
 because <code><a href="Control-Monad-Fraxl.html#t:Fraxl">Fraxl</a></code> is meant for a union of effects,
 but it should be possible to run a singleton effect.</p></div></div><div class="top"><p class="src"><a name="v:simpleAsyncFetch" class="def">simpleAsyncFetch</a> :: <a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m =&gt; (<span class="keyword">forall</span> x. f x -&gt; <a href="../base-4.8.2.0/System-IO.html#t:IO">IO</a> x) -&gt; <a href="Control-Monad-Fraxl.html#t:Fetch">Fetch</a> f m a</p><div class="doc"><p>A simple method of turning an <code><a href="../base-4.8.2.0/System-IO.html#t:IO">IO</a></code> bound computation
 into a <code><a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a></code> <code><a href="Control-Monad-Fraxl.html#t:Fetch">Fetch</a></code>.</p></div></div><h1 id="g:2">The Sequence of Effects</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ASeq" class="def">ASeq</a> f a :: (* -&gt; *) -&gt; * -&gt; * <span class="keyword">where</span></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ANil" class="def">ANil</a> ::  <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:ACons" class="def">ACons</a> ::  f a1 -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f (a1, u)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:reduceASeq" class="def">reduceASeq</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; f u</p><div class="doc"><p>reduceASeq a sequence of applicative effects into an applicative.</p></div></div><div class="top"><p class="src"><a name="v:hoistASeq" class="def">hoistASeq</a> :: (<span class="keyword">forall</span> x. f x -&gt; g x) -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> g a</p><div class="doc"><p>Transform a sequence of <code>f</code> into a sequence of <code>g</code>.</p></div></div><div class="top"><p class="src"><a name="v:traverseASeq" class="def">traverseASeq</a> :: <a href="../base-4.8.2.0/Control-Applicative.html#t:Applicative">Applicative</a> h =&gt; (<span class="keyword">forall</span> x. f x -&gt; h (g x)) -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f a -&gt; h (<a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> g a)</p><div class="doc"><p>Traverse a sequence with resepect to its interpretation type <code>f</code>.</p></div></div><div class="top"><p class="src"><a name="v:rebaseASeq" class="def">rebaseASeq</a> :: <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f u -&gt; (<span class="keyword">forall</span> x. (x -&gt; y) -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f x -&gt; z) -&gt; (v -&gt; u -&gt; y) -&gt; <a href="Control-Monad-Fraxl.html#t:ASeq">ASeq</a> f v -&gt; z</p><div class="doc"><p>It may not look like it, but this appends two sequences.
 See <a href="https://www.eyrie.org/~zednenem/2013/05/27/freeapp">Dave Menendez's work</a> for more explanation.</p></div></div><h1 id="g:3">Caching</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:CachedFetch" class="def">CachedFetch</a> f a</p><div class="doc"><p>Caching in Fraxl works by translating <code>FreerT f</code> into
 <code>FreerT (CachedFetch f)</code>, then running with <code>CachedFetch'</code>s DataSource.
 That instance requires <code>f</code> to to have a <code><a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a></code> instance.</p><p>The <code><a href="Control-Monad-Fraxl.html#t:CachedFetch">CachedFetch</a></code> instance uses a <code><a href="../mtl-2.2.1/Control-Monad-State-Class.html#t:MonadState">MonadState</a></code> to track cached requests.
 The state variable is a <code><a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a></code> from the 'dependent-map' package.
 Keys are requests, and values are <code><a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a></code>s of the results.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:CachedFetch" class="def">CachedFetch</a> (f a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:CachedFetch" class="caption collapser" onclick="toggleSection('i:CachedFetch')">Instances</p><div id="section.i:CachedFetch" class="show"><table><tr><td class="src clearfix"><span class="inst-left">(<a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m, <a href="../transformers-0.4.2.0/Control-Monad-Trans-Class.html#t:MonadTrans">MonadTrans</a> t, <a href="../mtl-2.2.1/Control-Monad-State-Class.html#t:MonadState">MonadState</a> (<a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> * f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a>) (t m), <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> * f, <a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> (t m)) =&gt; <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> (<a href="Control-Monad-Fraxl.html#t:CachedFetch">CachedFetch</a> f) (t m)</span></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:runCachedFraxl" class="def">runCachedFraxl</a> :: <span class="keyword">forall</span> m f a. (<a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m, <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> f) =&gt; <a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a> -&gt; m (a, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:DMap">DMap</a> f <a href="../base-4.8.2.0/Control-Concurrent-MVar.html#t:MVar">MVar</a>)</p><div class="doc"><p>Runs a Fraxl computation with caching using a given starting cache.
 Alongside the result, it returns the final cache.</p></div></div><div class="top"><p class="src"><a name="v:evalCachedFraxl" class="def">evalCachedFraxl</a> :: <span class="keyword">forall</span> m f a. (<a href="../transformers-0.4.2.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> m, <a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m, <a href="../dependent-map-0.2.1.0/Data-Dependent-Map.html#t:GCompare">GCompare</a> f) =&gt; <a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a> f m a -&gt; m a</p><div class="doc"><p>Like <code><a href="Control-Monad-Fraxl.html#v:runCachedFraxl">runCachedFraxl</a></code>, except it starts with an empty cache
 and discards the final cache.</p></div></div><div class="top"><p class="src">module <a href="../dependent-sum-0.3.2.1/Data-GADT-Compare.html">Data.GADT.Compare</a></p></div><h1 id="g:4">Fraxl Monads</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="../base-4.8.2.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a name="t:MonadFraxl" class="def">MonadFraxl</a> f m <span class="keyword">where</span></p><div class="doc"><p>Class for Fraxl-capable monads.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:dataFetch" class="def">dataFetch</a> :: f a -&gt; m a</p><div class="doc"><p><code><a href="Control-Monad-Fraxl.html#v:dataFetch">dataFetch</a></code> is used to make a request of type <code>f</code>.</p></div></div><div class="subs instances"><p id="control.i:MonadFraxl" class="caption collapser" onclick="toggleSection('i:MonadFraxl')">Instances</p><div id="section.i:MonadFraxl" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../transformers-0.4.2.0/Control-Monad-Trans-Maybe.html#t:MaybeT">MaybeT</a> m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../mtl-2.2.1/Control-Monad-List.html#t:ListT">ListT</a> m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../comonad-4.2.7.2/Control-Comonad-Trans-Identity.html#t:IdentityT">IdentityT</a> m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m, <a href="../base-4.8.2.0/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../mtl-2.2.1/Control-Monad-Writer-Strict.html#t:WriterT">WriterT</a> w m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m, <a href="../base-4.8.2.0/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../mtl-2.2.1/Control-Monad-Writer-Lazy.html#t:WriterT">WriterT</a> w m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../mtl-2.2.1/Control-Monad-State-Strict.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../mtl-2.2.1/Control-Monad-State-Lazy.html#t:StateT">StateT</a> s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../mtl-2.2.1/Control-Monad-Reader.html#t:ReaderT">ReaderT</a> e m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../mtl-2.2.1/Control-Monad-Except.html#t:ExceptT">ExceptT</a> e m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../mtl-2.2.1/Control-Monad-Cont.html#t:ContT">ContT</a> r m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="Control-Monad-Fraxl.html#t:FreerT">FreerT</a> f m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="Control-Monad-Fraxl.html#t:DataSource">DataSource</a> f m, <a href="../dependent-open-union-0.1.0.0/Data-Dependent-OpenUnion.html#t:Member">Member</a> * f r) =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="Control-Monad-Fraxl.html#t:Fraxl">Fraxl</a> r m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m, <a href="../base-4.8.2.0/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../mtl-2.2.1/Control-Monad-RWS-Strict.html#t:RWST">RWST</a> r w s m)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f m, <a href="../base-4.8.2.0/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Control-Monad-Fraxl.html#t:MonadFraxl">MonadFraxl</a> f (<a href="../mtl-2.2.1/Control-Monad-RWS-Lazy.html#t:RWST">RWST</a> r w s m)</span></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>
-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Semigroupoids: Category sans id
--   
--   Provides a wide array of (semi)groupoids and operations for working
--   with them.
--   
--   A <a>Semigroupoid</a> is a <a>Category</a> without the requirement of
--   identity arrows for every object in the category.
--   
--   A <a>Category</a> is any <a>Semigroupoid</a> for which the Yoneda
--   lemma holds.
--   
--   When working with comonads you often have the <tt>&lt;*&gt;</tt>
--   portion of an <tt>Applicative</tt>, but not the <tt>pure</tt>. This
--   was captured in Uustalu and Vene's "Essence of Dataflow Programming"
--   in the form of the <tt>ComonadZip</tt> class in the days before
--   <tt>Applicative</tt>. Apply provides a weaker invariant, but for the
--   comonads used for data flow programming (found in the streams
--   package), this invariant is preserved. Applicative function
--   composition forms a semigroupoid.
--   
--   Similarly many structures are nearly a comonad, but not quite, for
--   instance lists provide a reasonable <a>extend</a> operation in the
--   form of <a>tails</a>, but do not always contain a value.
--   
--   Ideally the following relationships would hold:
--   
--   <pre>
--   Foldable ----&gt; Traversable &lt;--- Functor ------&gt; Alt ---------&gt; Plus           Semigroupoid
--        |               |            |                              |                  |
--        v               v            v                              v                  v
--   Foldable1 ---&gt; Traversable1     Apply --------&gt; Applicative -&gt; Alternative      Category
--                                     |               |              |                  |
--                                     v               v              v                  v
--                                   Bind ---------&gt; Monad -------&gt; MonadPlus          Arrow
--   </pre>
--   
--   Apply, Bind, and Extend (not shown) give rise the Static, Kleisli and
--   Cokleisli semigroupoids respectively.
--   
--   This lets us remove many of the restrictions from various monad
--   transformers as in many cases the binding operation or
--   <tt>&lt;*&gt;</tt> operation does not require them.
--   
--   Finally, to work with these weaker structures it is beneficial to have
--   containers that can provide stronger guarantees about their contents,
--   so versions of <a>Traversable</a> and <a>Foldable</a> that can be
--   folded with just a <a>Semigroup</a> are added.
@package semigroupoids
@version 5.0.1


-- | Placeholders for missing instances of <a>Traversable</a>, and
--   <a>Foldable</a> until base catches up and adds them. Many of these are
--   re-exports from the `base-orphans` package.
module Data.Traversable.Instances


module Data.Semigroup.Foldable.Class
class Foldable t => Foldable1 t where foldMap1 f = maybe (error "foldMap1") id . getOption . foldMap (Option . Just . f) fold1 = foldMap1 id
fold1 :: (Foldable1 t, Semigroup m) => t m -> m
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m
class Bifoldable t => Bifoldable1 t where bifold1 = bifoldMap1 id id bifoldMap1 f g = maybe (error "bifoldMap1") id . getOption . bifoldMap (Option . Just . f) (Option . Just . g)
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Semigroup.Foldable.Class.Bifoldable1 Data.Semigroup.Arg
instance Data.Semigroup.Foldable.Class.Bifoldable1 Data.Either.Either
instance Data.Semigroup.Foldable.Class.Bifoldable1 (,)
instance Data.Semigroup.Foldable.Class.Bifoldable1 ((,,) x)
instance Data.Semigroup.Foldable.Class.Bifoldable1 ((,,,) x y)
instance Data.Semigroup.Foldable.Class.Bifoldable1 ((,,,,) x y z)
instance Data.Semigroup.Foldable.Class.Bifoldable1 Control.Applicative.Const
instance Data.Semigroup.Foldable.Class.Bifoldable1 Data.Tagged.Tagged
instance (Data.Semigroup.Foldable.Class.Bifoldable1 p, Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Biff.Biff p f g)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Clown.Clown f)
instance Data.Semigroup.Foldable.Class.Bifoldable1 p => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Flip.Flip p)
instance Data.Semigroup.Foldable.Class.Bifoldable1 p => Data.Semigroup.Foldable.Class.Foldable1 (Data.Bifunctor.Join.Join p)
instance Data.Semigroup.Foldable.Class.Foldable1 g => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Joker.Joker g)
instance (Data.Semigroup.Foldable.Class.Bifoldable1 f, Data.Semigroup.Foldable.Class.Bifoldable1 g) => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Product.Product f g)
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Bifoldable1 p) => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Tannen.Tannen f p)
instance Data.Semigroup.Foldable.Class.Bifoldable1 p => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Tree.Tree
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Functor.Identity.Identity
instance Data.Semigroup.Foldable.Class.Foldable1 m => Data.Semigroup.Foldable.Class.Foldable1 (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Control.Applicative.Backwards.Backwards f)
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Foldable1 (Data.Functor.Compose.Compose f g)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Control.Applicative.Lift.Lift f)
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Foldable1 (Data.Functor.Product.Product f g)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Data.Functor.Reverse.Reverse f)
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Foldable1 (Data.Functor.Sum.Sum f g)
instance Data.Semigroup.Foldable.Class.Foldable1 Data.List.NonEmpty.NonEmpty
instance Data.Semigroup.Foldable.Class.Foldable1 ((,) a)
instance Data.Semigroup.Foldable.Class.Foldable1 g => Data.Semigroup.Foldable.Class.Foldable1 (Data.Bifunctor.Joker.Joker g a)


module Data.Functor.Extend
class Functor w => Extend w where extended f = fmap f . duplicated duplicated = extended id

-- | <pre>
--   duplicated = extended id
--   fmap (fmap f) . duplicated = duplicated . fmap f
--   </pre>
duplicated :: Extend w => w a -> w (w a)

-- | <pre>
--   extended f  = fmap f . duplicated
--   </pre>
extended :: Extend w => (w a -> b) -> w a -> w b
instance Data.Functor.Extend.Extend []
instance Data.Functor.Extend.Extend GHC.Base.Maybe
instance Data.Functor.Extend.Extend (Data.Either.Either a)
instance Data.Functor.Extend.Extend ((,) e)
instance Data.Semigroup.Semigroup m => Data.Functor.Extend.Extend ((->) m)
instance Data.Functor.Extend.Extend Data.Sequence.Seq
instance Data.Functor.Extend.Extend Data.Tree.Tree
instance Data.Functor.Extend.Extend w => Data.Functor.Extend.Extend (Control.Comonad.Trans.Env.EnvT e w)
instance Data.Functor.Extend.Extend w => Data.Functor.Extend.Extend (Control.Comonad.Trans.Store.StoreT s w)
instance (Data.Functor.Extend.Extend w, Data.Semigroup.Semigroup m) => Data.Functor.Extend.Extend (Control.Comonad.Trans.Traced.TracedT m w)
instance Data.Functor.Extend.Extend Data.Functor.Identity.Identity
instance Data.Functor.Extend.Extend w => Data.Functor.Extend.Extend (Control.Monad.Trans.Identity.IdentityT w)
instance Data.Functor.Extend.Extend Data.List.NonEmpty.NonEmpty
instance (Data.Functor.Extend.Extend f, Data.Functor.Extend.Extend g) => Data.Functor.Extend.Extend (Data.Functor.Sum.Sum f g)


-- | This module is used to resolve the cyclic we get from defining these
--   classes here rather than in a package upstream. Otherwise we'd get
--   orphaned heads for many instances on the types in
--   <tt>transformers</tt> and <tt>bifunctors</tt>.
module Data.Functor.Bind.Class

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Functor f => Apply f where a .> b = const id <$> a <.> b a <. b = const <$> a <.> b
(<.>) :: Apply f => f (a -> b) -> f a -> f b

-- | <pre>
--   a  .&gt; b = const id &lt;$&gt; a &lt;.&gt; b
--   </pre>
(.>) :: Apply f => f a -> f b -> f b

-- | <pre>
--   a &lt;. b = const &lt;$&gt; a &lt;.&gt; b
--   </pre>
(<.) :: Apply f => f a -> f b -> f a

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
[unwrapApplicative] :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
[runMaybeApply] :: MaybeApply f a -> Either (f a) a

-- | A <a>Monad</a> sans <a>return</a>.
--   
--   Minimal definition: Either <a>join</a> or <a>&gt;&gt;-</a>
--   
--   If defining both, then the following laws (the default definitions)
--   must hold:
--   
--   <pre>
--   join = (&gt;&gt;- id)
--   m &gt;&gt;- f = join (fmap f m)
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   induced definition of &lt;.&gt;: f &lt;.&gt; x = f &gt;&gt;- (&lt;$&gt; x)
--   </pre>
--   
--   Finally, there are two associativity conditions:
--   
--   <pre>
--   associativity of (&gt;&gt;-):    (m &gt;&gt;- f) &gt;&gt;- g == m &gt;&gt;- (\x -&gt; f x &gt;&gt;- g)
--   associativity of join:     join . join = join . fmap join
--   </pre>
--   
--   These can both be seen as special cases of the constraint that
--   
--   <pre>
--   associativity of (-&gt;-): (f -&gt;- g) -&gt;- h = f -&gt;- (g -&gt;- h)
--   </pre>
class Apply m => Bind m where m >>- f = join (fmap f m) join = (>>- id)
(>>-) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a
apDefault :: Bind f => f (a -> b) -> f a -> f b
returning :: Functor f => f a -> (a -> b) -> f b
class Bifunctor p => Biapply p where a .>> b = bimap (const id) (const id) <<$>> a <<.>> b a <<. b = bimap const const <<$>> a <<.>> b
(<<.>>) :: Biapply p => p (a -> b) (c -> d) -> p a c -> p b d

-- | <pre>
--   a <a>.&gt;</a> b ≡ <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>>) :: Biapply p => p a b -> p c d -> p c d

-- | <pre>
--   a <a>&lt;.</a> b ≡ <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<<.) :: Biapply p => p a b -> p c d -> p a b
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Control.Applicative.Backwards.Backwards f)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Apply (Data.Functor.Compose.Compose f g)
instance Data.Semigroup.Semigroup f => Data.Functor.Bind.Class.Apply (Data.Functor.Constant.Constant f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Control.Applicative.Lift.Lift f)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Apply (Data.Functor.Product.Product f g)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Functor.Reverse.Reverse f)
instance Data.Semigroup.Semigroup m => Data.Functor.Bind.Class.Apply ((,) m)
instance Data.Functor.Bind.Class.Apply Data.List.NonEmpty.NonEmpty
instance Data.Functor.Bind.Class.Apply (Data.Either.Either a)
instance Data.Semigroup.Semigroup m => Data.Functor.Bind.Class.Apply (Control.Applicative.Const m)
instance Data.Functor.Bind.Class.Apply ((->) m)
instance Data.Functor.Bind.Class.Apply Control.Applicative.ZipList
instance Data.Functor.Bind.Class.Apply []
instance Data.Functor.Bind.Class.Apply GHC.Types.IO
instance Data.Functor.Bind.Class.Apply GHC.Base.Maybe
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Option
instance Data.Functor.Bind.Class.Apply Data.Functor.Identity.Identity
instance Data.Functor.Bind.Class.Apply w => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Identity.IdentityT w)
instance GHC.Base.Monad m => Data.Functor.Bind.Class.Apply (Control.Applicative.WrappedMonad m)
instance Control.Arrow.Arrow a => Data.Functor.Bind.Class.Apply (Control.Applicative.WrappedArrow a b)
instance GHC.Classes.Ord k => Data.Functor.Bind.Class.Apply (Data.Map.Base.Map k)
instance Data.Functor.Bind.Class.Apply Data.IntMap.Base.IntMap
instance Data.Functor.Bind.Class.Apply Data.Sequence.Seq
instance Data.Functor.Bind.Class.Apply Data.Tree.Tree
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Bind.Class.Apply m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Functor.Bind.Class.Apply m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.List.ListT m)
instance (Data.Functor.Bind.Class.Apply m, Data.Semigroup.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Data.Functor.Bind.Class.Apply m, Data.Semigroup.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Data.Functor.Bind.Class.Bind m, Data.Semigroup.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Data.Functor.Bind.Class.Bind m, Data.Semigroup.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Cont.ContT r m)
instance (Data.Semigroup.Semigroup e, Data.Functor.Bind.Class.Apply w) => Data.Functor.Bind.Class.Apply (Control.Comonad.Trans.Env.EnvT e w)
instance (Data.Functor.Bind.Class.Apply w, Data.Semigroup.Semigroup s) => Data.Functor.Bind.Class.Apply (Control.Comonad.Trans.Store.StoreT s w)
instance Data.Functor.Bind.Class.Apply w => Data.Functor.Bind.Class.Apply (Control.Comonad.Trans.Traced.TracedT m w)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Bind.Class.WrappedApplicative f)
instance GHC.Base.Applicative f => Data.Functor.Bind.Class.Apply (Data.Functor.Bind.Class.WrappedApplicative f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Bind.Class.WrappedApplicative f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Functor.Bind.Class.WrappedApplicative f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Bind.Class.MaybeApply f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Functor.Bind.Class.MaybeApply f)
instance Data.Functor.Bind.Class.Apply f => GHC.Base.Applicative (Data.Functor.Bind.Class.MaybeApply f)
instance Data.Functor.Extend.Extend f => Data.Functor.Extend.Extend (Data.Functor.Bind.Class.MaybeApply f)
instance Control.Comonad.Comonad f => Control.Comonad.Comonad (Data.Functor.Bind.Class.MaybeApply f)
instance Data.Functor.Bind.Class.Apply (Control.Comonad.Cokleisli w a)
instance Data.Semigroup.Semigroup m => Data.Functor.Bind.Class.Bind ((,) m)
instance Data.Functor.Bind.Class.Bind (Data.Either.Either a)
instance (Data.Functor.Bind.Class.Bind f, Data.Functor.Bind.Class.Bind g) => Data.Functor.Bind.Class.Bind (Data.Functor.Product.Product f g)
instance Data.Functor.Bind.Class.Bind ((->) m)
instance Data.Functor.Bind.Class.Bind []
instance Data.Functor.Bind.Class.Bind Data.List.NonEmpty.NonEmpty
instance Data.Functor.Bind.Class.Bind GHC.Types.IO
instance Data.Functor.Bind.Class.Bind GHC.Base.Maybe
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Option
instance Data.Functor.Bind.Class.Bind Data.Functor.Identity.Identity
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Identity.IdentityT m)
instance GHC.Base.Monad m => Data.Functor.Bind.Class.Bind (Control.Applicative.WrappedMonad m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Maybe.MaybeT m)
instance (Data.Functor.Bind.Class.Apply m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.List.ListT m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Reader.ReaderT e m)
instance (Data.Functor.Bind.Class.Bind m, Data.Semigroup.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Data.Functor.Bind.Class.Bind m, Data.Semigroup.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.State.Strict.StateT s m)
instance (Data.Functor.Bind.Class.Bind m, Data.Semigroup.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Data.Functor.Bind.Class.Bind m, Data.Semigroup.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Cont.ContT r m)
instance GHC.Classes.Ord k => Data.Functor.Bind.Class.Bind (Data.Map.Base.Map k)
instance Data.Functor.Bind.Class.Bind Data.IntMap.Base.IntMap
instance Data.Functor.Bind.Class.Bind Data.Sequence.Seq
instance Data.Functor.Bind.Class.Bind Data.Tree.Tree
instance Data.Functor.Bind.Class.Biapply (,)
instance Data.Functor.Bind.Class.Biapply Data.Semigroup.Arg
instance Data.Semigroup.Semigroup x => Data.Functor.Bind.Class.Biapply ((,,) x)
instance (Data.Semigroup.Semigroup x, Data.Semigroup.Semigroup y) => Data.Functor.Bind.Class.Biapply ((,,,) x y)
instance (Data.Semigroup.Semigroup x, Data.Semigroup.Semigroup y, Data.Semigroup.Semigroup z) => Data.Functor.Bind.Class.Biapply ((,,,,) x y z)
instance Data.Functor.Bind.Class.Biapply Control.Applicative.Const
instance Data.Functor.Bind.Class.Biapply Data.Tagged.Tagged
instance (Data.Functor.Bind.Class.Biapply p, Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Biff.Biff p f g)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Clown.Clown f)
instance Data.Functor.Bind.Class.Biapply p => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Flip.Flip p)
instance Data.Functor.Bind.Class.Apply g => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Joker.Joker g)
instance Data.Functor.Bind.Class.Biapply p => Data.Functor.Bind.Class.Apply (Data.Bifunctor.Join.Join p)
instance (Data.Functor.Bind.Class.Biapply p, Data.Functor.Bind.Class.Biapply q) => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Product.Product p q)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Biapply p) => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Tannen.Tannen f p)
instance Data.Functor.Bind.Class.Biapply p => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Wrapped.WrappedBifunctor p)


module Data.Functor.Apply

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Functor f => Apply f where a .> b = const id <$> a <.> b a <. b = const <$> a <.> b
(<.>) :: Apply f => f (a -> b) -> f a -> f b

-- | <pre>
--   a  .&gt; b = const id &lt;$&gt; a &lt;.&gt; b
--   </pre>
(.>) :: Apply f => f a -> f b -> f b

-- | <pre>
--   a &lt;. b = const &lt;$&gt; a &lt;.&gt; b
--   </pre>
(<.) :: Apply f => f a -> f b -> f a

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply w => (a -> b -> c) -> w a -> w b -> w c

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
[unwrapApplicative] :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
[runMaybeApply] :: MaybeApply f a -> Either (f a) a


module Data.Semigroup.Bifoldable
class Bifoldable t => Bifoldable1 t where bifold1 = bifoldMap1 id id bifoldMap1 f g = maybe (error "bifoldMap1") id . getOption . bifoldMap (Option . Just . f) (Option . Just . g)
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
bitraverse1_ :: (Bifoldable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f ()
bifor1_ :: (Bifoldable1 t, Apply f) => t a c -> (a -> f b) -> (c -> f d) -> f ()
bisequenceA1_ :: (Bifoldable1 t, Apply f) => t (f a) (f b) -> f ()

-- | Usable default for foldMap, but only if you define bifoldMap1 yourself
bifoldMapDefault1 :: (Bifoldable1 t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Functor.Bind.Class.Apply f => Data.Semigroup.Semigroup (Data.Semigroup.Bifoldable.Act f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Bifoldable.Act f)


module Data.Functor.Bind

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Functor f => Apply f where a .> b = const id <$> a <.> b a <. b = const <$> a <.> b
(<.>) :: Apply f => f (a -> b) -> f a -> f b

-- | <pre>
--   a  .&gt; b = const id &lt;$&gt; a &lt;.&gt; b
--   </pre>
(.>) :: Apply f => f a -> f b -> f b

-- | <pre>
--   a &lt;. b = const &lt;$&gt; a &lt;.&gt; b
--   </pre>
(<.) :: Apply f => f a -> f b -> f a

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply w => (a -> b -> c) -> w a -> w b -> w c

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
[unwrapApplicative] :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
[runMaybeApply] :: MaybeApply f a -> Either (f a) a

-- | A <a>Monad</a> sans <a>return</a>.
--   
--   Minimal definition: Either <a>join</a> or <a>&gt;&gt;-</a>
--   
--   If defining both, then the following laws (the default definitions)
--   must hold:
--   
--   <pre>
--   join = (&gt;&gt;- id)
--   m &gt;&gt;- f = join (fmap f m)
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   induced definition of &lt;.&gt;: f &lt;.&gt; x = f &gt;&gt;- (&lt;$&gt; x)
--   </pre>
--   
--   Finally, there are two associativity conditions:
--   
--   <pre>
--   associativity of (&gt;&gt;-):    (m &gt;&gt;- f) &gt;&gt;- g == m &gt;&gt;- (\x -&gt; f x &gt;&gt;- g)
--   associativity of join:     join . join = join . fmap join
--   </pre>
--   
--   These can both be seen as special cases of the constraint that
--   
--   <pre>
--   associativity of (-&gt;-): (f -&gt;- g) -&gt;- h = f -&gt;- (g -&gt;- h)
--   </pre>
class Apply m => Bind m where m >>- f = join (fmap f m) join = (>>- id)
(>>-) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a
(-<<) :: Bind m => (a -> m b) -> m a -> m b
(-<-) :: Bind m => (b -> m c) -> (a -> m b) -> a -> m c
(->-) :: Bind m => (a -> m b) -> (b -> m c) -> a -> m c
apDefault :: Bind f => f (a -> b) -> f a -> f b
returning :: Functor f => f a -> (a -> b) -> f b


module Data.Functor.Alt

-- | Laws:
--   
--   <pre>
--   &lt;!&gt; is associative:             (a &lt;!&gt; b) &lt;!&gt; c = a &lt;!&gt; (b &lt;!&gt; c)
--   &lt;$&gt; left-distributes over &lt;!&gt;:  f &lt;$&gt; (a &lt;!&gt; b) = (f &lt;$&gt; a) &lt;!&gt; (f &lt;$&gt; b)
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>&lt;!&gt;</a> should
--   equal <a>&lt;|&gt;</a>.
--   
--   Ideally, an instance of <a>Alt</a> also satisfies the "left
--   distributon" law of MonadPlus with respect to <a>&lt;.&gt;</a>:
--   
--   <pre>
--   &lt;.&gt; right-distributes over &lt;!&gt;: (a &lt;!&gt; b) &lt;.&gt; c = (a &lt;.&gt; c) &lt;!&gt; (b &lt;.&gt; c)
--   </pre>
--   
--   But <a>Maybe</a>, <a>IO</a>, <tt><a>Either</a> a</tt>,
--   <tt><a>ErrorT</a> e m</tt>, and <tt>STM</tt> satisfy the alternative
--   "left catch" law instead:
--   
--   <pre>
--   pure a &lt;!&gt; b = pure a
--   </pre>
--   
--   However, this variation cannot be stated purely in terms of the
--   dependencies of <a>Alt</a>.
--   
--   When and if MonadPlus is successfully refactored, this class should
--   also be refactored to remove these instances.
--   
--   The right distributive law should extend in the cases where the a
--   <a>Bind</a> or <a>Monad</a> is provided to yield variations of the
--   right distributive law:
--   
--   <pre>
--   (m &lt;!&gt; n) &gt;&gt;- f = (m &gt;&gt;- f) &lt;!&gt; (m &gt;&gt;- f)
--   (m &lt;!&gt; n) &gt;&gt;= f = (m &gt;&gt;= f) &lt;!&gt; (m &gt;&gt;= f)
--   </pre>
class Functor f => Alt f where some v = some_v where many_v = some_v <!> pure [] some_v = (:) <$> v <*> many_v many v = many_v where many_v = some_v <!> pure [] some_v = (:) <$> v <*> many_v

-- | <a>&lt;|&gt;</a> without a required <tt>empty</tt>
(<!>) :: Alt f => f a -> f a -> f a
some :: (Alt f, Applicative f) => f a -> f [a]
many :: (Alt f, Applicative f) => f a -> f [a]
instance Data.Functor.Alt.Alt (Data.Either.Either a)
instance Data.Functor.Alt.Alt GHC.Types.IO
instance Data.Functor.Alt.Alt []
instance Data.Functor.Alt.Alt GHC.Base.Maybe
instance Data.Functor.Alt.Alt Data.Semigroup.Option
instance GHC.Base.MonadPlus m => Data.Functor.Alt.Alt (Control.Applicative.WrappedMonad m)
instance Control.Arrow.ArrowPlus a => Data.Functor.Alt.Alt (Control.Applicative.WrappedArrow a b)
instance GHC.Classes.Ord k => Data.Functor.Alt.Alt (Data.Map.Base.Map k)
instance Data.Functor.Alt.Alt Data.IntMap.Base.IntMap
instance Data.Functor.Alt.Alt Data.Sequence.Seq
instance Data.Functor.Alt.Alt Data.List.NonEmpty.NonEmpty
instance GHC.Base.Alternative f => Data.Functor.Alt.Alt (Data.Functor.Bind.Class.WrappedApplicative f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Reader.ReaderT e f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f) => Data.Functor.Alt.Alt (Control.Monad.Trans.Maybe.MaybeT f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f) => Data.Functor.Alt.Alt (Control.Monad.Trans.Error.ErrorT e f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f, Data.Semigroup.Semigroup e) => Data.Functor.Alt.Alt (Control.Monad.Trans.Except.ExceptT e f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Alt.Alt (Control.Monad.Trans.List.ListT f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.State.Strict.StateT e f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.State.Lazy.StateT e f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Writer.Strict.WriterT w f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Writer.Lazy.WriterT w f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.RWS.Strict.RWST r w s f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.RWS.Lazy.RWST r w s f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Applicative.Backwards.Backwards f)
instance (Data.Functor.Alt.Alt f, GHC.Base.Functor g) => Data.Functor.Alt.Alt (Data.Functor.Compose.Compose f g)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Applicative.Lift.Lift f)
instance (Data.Functor.Alt.Alt f, Data.Functor.Alt.Alt g) => Data.Functor.Alt.Alt (Data.Functor.Product.Product f g)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Data.Functor.Reverse.Reverse f)


module Data.Semigroup.Foldable
class Foldable t => Foldable1 t where foldMap1 f = maybe (error "foldMap1") id . getOption . foldMap (Option . Just . f) fold1 = foldMap1 id
fold1 :: (Foldable1 t, Semigroup m) => t m -> m
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | Insert an <tt>m</tt> between each pair of 't m'. Equivalent to
--   <a>intercalateMap1</a> with <a>id</a> as the second argument.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| ["how", "are", "you"]
--   "hello, how, are, you"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| []
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 mempty $ "I" :| ["Am", "Fine", "You?"]
--   "IAmFineYou?"
--   </pre>
intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m

-- | Insert <tt>m</tt> between each pair of <tt>m</tt> derived from
--   <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| [False, True]
--   "True False True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| []
--   "True"
--   </pre>
intercalateMap1 :: (Foldable1 t, Semigroup m) => m -> (a -> m) -> t a -> m
traverse1_ :: (Foldable1 t, Apply f) => (a -> f b) -> t a -> f ()
for1_ :: (Foldable1 t, Apply f) => t a -> (a -> f b) -> f ()
sequenceA1_ :: (Foldable1 t, Apply f) => t (f a) -> f ()

-- | Usable default for foldMap, but only if you define foldMap1 yourself
foldMapDefault1 :: (Foldable1 t, Monoid m) => (a -> m) -> t a -> m
asum1 :: (Foldable1 t, Alt m) => t (m a) -> m a
instance Data.Semigroup.Semigroup a => Data.Semigroup.Semigroup (Data.Semigroup.Foldable.JoinWith a)
instance Data.Functor.Bind.Class.Apply f => Data.Semigroup.Semigroup (Data.Semigroup.Foldable.Act f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Foldable.Act f)
instance Data.Functor.Alt.Alt f => Data.Semigroup.Semigroup (Data.Semigroup.Foldable.Alt_ f a)


module Data.Semigroup.Traversable.Class
class (Bifoldable1 t, Bitraversable t) => Bitraversable1 t where bitraverse1 f g = bisequence1 . bimap f g bisequence1 = bitraverse1 id id
bitraverse1 :: (Bitraversable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f (t b d)
bisequence1 :: (Bitraversable1 t, Apply f) => t (f a) (f b) -> f (t a b)
class (Foldable1 t, Traversable t) => Traversable1 t where sequence1 = traverse1 id traverse1 f = sequence1 . fmap f
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
sequence1 :: (Traversable1 t, Apply f) => t (f b) -> f (t b)
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Semigroup.Arg
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Either.Either
instance Data.Semigroup.Traversable.Class.Bitraversable1 (,)
instance Data.Semigroup.Traversable.Class.Bitraversable1 ((,,) x)
instance Data.Semigroup.Traversable.Class.Bitraversable1 ((,,,) x y)
instance Data.Semigroup.Traversable.Class.Bitraversable1 ((,,,,) x y z)
instance Data.Semigroup.Traversable.Class.Bitraversable1 Control.Applicative.Const
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Tagged.Tagged
instance (Data.Semigroup.Traversable.Class.Bitraversable1 p, Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Biff.Biff p f g)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Clown.Clown f)
instance Data.Semigroup.Traversable.Class.Bitraversable1 p => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Flip.Flip p)
instance Data.Semigroup.Traversable.Class.Bitraversable1 p => Data.Semigroup.Traversable.Class.Traversable1 (Data.Bifunctor.Join.Join p)
instance Data.Semigroup.Traversable.Class.Traversable1 g => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Joker.Joker g)
instance (Data.Semigroup.Traversable.Class.Bitraversable1 f, Data.Semigroup.Traversable.Class.Bitraversable1 g) => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Product.Product f g)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Bitraversable1 p) => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Tannen.Tannen f p)
instance Data.Semigroup.Traversable.Class.Bitraversable1 p => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Functor.Identity.Identity
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Backwards.Backwards f)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Compose.Compose f g)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Lift.Lift f)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Product.Product f g)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Reverse.Reverse f)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Sum.Sum f g)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Tree.Tree
instance Data.Semigroup.Traversable.Class.Traversable1 Data.List.NonEmpty.NonEmpty
instance Data.Semigroup.Traversable.Class.Traversable1 ((,) a)
instance Data.Semigroup.Traversable.Class.Traversable1 g => Data.Semigroup.Traversable.Class.Traversable1 (Data.Bifunctor.Joker.Joker g a)


module Data.Semigroup.Bitraversable
class (Bifoldable1 t, Bitraversable t) => Bitraversable1 t where bitraverse1 f g = bisequence1 . bimap f g bisequence1 = bitraverse1 id id
bitraverse1 :: (Bitraversable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f (t b d)
bisequence1 :: (Bitraversable1 t, Apply f) => t (f a) (f b) -> f (t a b)
bifoldMap1Default :: (Bitraversable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m


module Data.Semigroup.Traversable
class (Foldable1 t, Traversable t) => Traversable1 t where sequence1 = traverse1 id traverse1 f = sequence1 . fmap f
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
sequence1 :: (Traversable1 t, Apply f) => t (f b) -> f (t b)
foldMap1Default :: (Traversable1 f, Semigroup m) => (a -> m) -> f a -> m


module Data.Functor.Bind.Trans

-- | A subset of monad transformers can transform any <a>Bind</a> as well.
class MonadTrans t => BindTrans t
liftB :: (BindTrans t, Bind b) => b a -> t b a
instance Data.Functor.Bind.Trans.BindTrans Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Reader.ReaderT e)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Writer.Strict.WriterT w)
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.State.Strict.StateT s)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Cont.ContT r)


module Data.Functor.Plus

-- | Laws:
--   
--   <pre>
--   zero &lt;!&gt; m = m
--   m &lt;!&gt; zero = m
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>zero</a> should equal
--   <a>empty</a>.
class Alt f => Plus f
zero :: Plus f => f a
instance Data.Functor.Plus.Plus GHC.Types.IO
instance Data.Functor.Plus.Plus []
instance Data.Functor.Plus.Plus GHC.Base.Maybe
instance Data.Functor.Plus.Plus Data.Semigroup.Option
instance GHC.Base.MonadPlus m => Data.Functor.Plus.Plus (Control.Applicative.WrappedMonad m)
instance Control.Arrow.ArrowPlus a => Data.Functor.Plus.Plus (Control.Applicative.WrappedArrow a b)
instance GHC.Classes.Ord k => Data.Functor.Plus.Plus (Data.Map.Base.Map k)
instance Data.Functor.Plus.Plus Data.IntMap.Base.IntMap
instance Data.Functor.Plus.Plus Data.Sequence.Seq
instance GHC.Base.Alternative f => Data.Functor.Plus.Plus (Data.Functor.Bind.Class.WrappedApplicative f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Reader.ReaderT e f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f) => Data.Functor.Plus.Plus (Control.Monad.Trans.Maybe.MaybeT f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f, Control.Monad.Trans.Error.Error e) => Data.Functor.Plus.Plus (Control.Monad.Trans.Error.ErrorT e f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f, Data.Semigroup.Semigroup e, GHC.Base.Monoid e) => Data.Functor.Plus.Plus (Control.Monad.Trans.Except.ExceptT e f)
instance (Data.Functor.Bind.Class.Apply f, GHC.Base.Applicative f) => Data.Functor.Plus.Plus (Control.Monad.Trans.List.ListT f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.State.Strict.StateT e f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.State.Lazy.StateT e f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Writer.Strict.WriterT w f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Writer.Lazy.WriterT w f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.RWS.Strict.RWST r w s f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.RWS.Lazy.RWST r w s f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Applicative.Backwards.Backwards f)
instance (Data.Functor.Plus.Plus f, GHC.Base.Functor g) => Data.Functor.Plus.Plus (Data.Functor.Compose.Compose f g)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Applicative.Lift.Lift f)
instance (Data.Functor.Plus.Plus f, Data.Functor.Plus.Plus g) => Data.Functor.Plus.Plus (Data.Functor.Product.Product f g)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Data.Functor.Reverse.Reverse f)


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid

-- | <a>Category</a> sans <a>id</a>
class Semigroupoid c
o :: Semigroupoid c => c j k -> c i j -> c i k
newtype WrappedCategory k a b
WrapCategory :: k a b -> WrappedCategory k a b
[unwrapCategory] :: WrappedCategory k a b -> k a b
newtype Semi m a b
Semi :: m -> Semi m a b
[getSemi] :: Semi m a b -> m
instance Data.Semigroupoid.Semigroupoid (->)
instance Data.Semigroupoid.Semigroupoid (,)
instance Data.Functor.Bind.Class.Bind m => Data.Semigroupoid.Semigroupoid (Control.Arrow.Kleisli m)
instance Data.Functor.Extend.Extend w => Data.Semigroupoid.Semigroupoid (Control.Comonad.Cokleisli w)
instance Data.Semigroupoid.Semigroupoid Data.Functor.Contravariant.Op
instance forall (k :: BOX) (k1 :: k -> k -> *). Control.Category.Category k1 => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.WrappedCategory k1)
instance forall (k :: BOX) (k1 :: k -> k -> *). Control.Category.Category k1 => Control.Category.Category (Data.Semigroupoid.WrappedCategory k1)
instance Data.Semigroup.Semigroup m => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.Semi m)
instance GHC.Base.Monoid m => Control.Category.Category (Data.Semigroupoid.Semi m)


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid.Dual
newtype Dual k a b
Dual :: k b a -> Dual k a b
[getDual] :: Dual k a b -> k b a
instance forall (k :: BOX) (k1 :: k -> k -> *). Data.Semigroupoid.Semigroupoid k1 => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.Dual.Dual k1)
instance forall (k :: BOX) (k1 :: k -> k -> *). Control.Category.Category k1 => Control.Category.Category (Data.Semigroupoid.Dual.Dual k1)


module Data.Groupoid

-- | semigroupoid with inverses. This technically should be a category with
--   inverses, except we need to use Ob to define the valid objects for the
--   category
class Semigroupoid k => Groupoid k
inv :: Groupoid k => k a b -> k b a
instance forall (k :: BOX) (k1 :: k -> k -> *). Data.Groupoid.Groupoid k1 => Data.Groupoid.Groupoid (Data.Semigroupoid.Dual.Dual k1)


module Data.Isomorphism
data Iso k a b
Iso :: k a b -> k b a -> Iso k a b
[embed] :: Iso k a b -> k a b
[project] :: Iso k a b -> k b a
instance forall (k :: BOX) (k1 :: k -> k -> *). Data.Semigroupoid.Semigroupoid k1 => Data.Semigroupoid.Semigroupoid (Data.Isomorphism.Iso k1)
instance forall (k :: BOX) (k1 :: k -> k -> *). Data.Semigroupoid.Semigroupoid k1 => Data.Groupoid.Groupoid (Data.Isomorphism.Iso k1)
instance forall (k :: BOX) (k1 :: k -> k -> *). Control.Category.Category k1 => Control.Category.Category (Data.Isomorphism.Iso k1)


module Data.Semigroupoid.Static
newtype Static f a b
Static :: f (a -> b) -> Static f a b
[runStatic] :: Static f a b -> f (a -> b)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Data.Semigroupoid.Static.Static f a)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Semigroupoid.Static.Static f a)
instance (Data.Functor.Extend.Extend f, Data.Semigroup.Semigroup a) => Data.Functor.Extend.Extend (Data.Semigroupoid.Static.Static f a)
instance (Control.Comonad.Comonad f, GHC.Base.Monoid a) => Control.Comonad.Comonad (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Bind.Class.Apply f => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Applicative f => Control.Category.Category (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Applicative f => Control.Arrow.Arrow (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Alternative f => Control.Arrow.ArrowZero (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Alternative f => Control.Arrow.ArrowPlus (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Applicative f => Control.Arrow.ArrowChoice (Data.Semigroupoid.Static.Static f)


module Data.Semigroupoid.Ob
class Semigroupoid k => Ob k a
semiid :: Ob k a => k a a
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Monad m) => Data.Semigroupoid.Ob.Ob (Control.Arrow.Kleisli m) a
instance (Data.Functor.Extend.Extend w, Control.Comonad.Comonad w) => Data.Semigroupoid.Ob.Ob (Control.Comonad.Cokleisli w) a
instance Data.Semigroupoid.Ob.Ob (->) a


module Data.Bifunctor.Apply

-- | Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor (p :: * -> * -> *)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c
class Bifunctor p => Biapply p where a .>> b = bimap (const id) (const id) <<$>> a <<.>> b a <<. b = bimap const const <<$>> a <<.>> b
(<<.>>) :: Biapply p => p (a -> b) (c -> d) -> p a c -> p b d

-- | <pre>
--   a <a>.&gt;</a> b ≡ <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>>) :: Biapply p => p a b -> p c d -> p c d

-- | <pre>
--   a <a>&lt;.</a> b ≡ <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<<.) :: Biapply p => p a b -> p c d -> p a b
(<<$>>) :: (a -> b) -> a -> b
(<<..>>) :: Biapply p => p a c -> p (a -> b) (c -> d) -> p b d

-- | Lift binary functions
bilift2 :: Biapply w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f

-- | Lift ternary functions
bilift3 :: Biapply w => (a -> b -> c -> d) -> (e -> f -> g -> h) -> w a e -> w b f -> w c g -> w d h
